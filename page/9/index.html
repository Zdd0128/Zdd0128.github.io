<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="左大大的博客">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="左大大的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="左大大">
<meta property="article:tag" content="Python Linux Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>左大大的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">左大大的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="左大大"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">左大大</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/29/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/29/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/" class="post-title-link" itemprop="url">面向过程编程与函数式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-29 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-29T17:27:55+08:00">2018-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向过程编程与函数式"><a href="#面向过程编程与函数式" class="headerlink" title="面向过程编程与函数式"></a>面向过程编程与函数式</h1><h3 id="一-编程范式"><a href="#一-编程范式" class="headerlink" title="一 .编程范式"></a>一 .编程范式</h3><p>编程范式指的就是编程的套路，打个比方，如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程、函数式、面向对象等，本节我们主要介绍前两者。</p>
<h3 id="二-面向过程"><a href="#二-面向过程" class="headerlink" title="二 面向过程"></a>二 面向过程</h3><p>”面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤，即先干什么再干什么……，基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。</p>
<p>详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</p>
<p> 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一：基于本章所学，我们可以用函数去实现这一个个的步骤</span></span><br><span class="line"><span class="comment"># 1、本地数据打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup</span>(<span class="params">folder</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到备份目录: %s&quot;</span> %folder)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在备份...&#x27;</span>)</span><br><span class="line">    zip_file=<span class="string">&#x27;/tmp/backup_%s.zip&#x27;</span> %time.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;备份成功，备份文件为: %s&#x27;</span> %zip_file)</span><br><span class="line">    <span class="keyword">return</span> zip_file</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、上传至云服务器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">    link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> link</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、检测备份文件可用性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#二：依次调用</span></span><br><span class="line"><span class="comment"># 步骤一：本地数据打包</span></span><br><span class="line">zip_file = data_backup(<span class="string">r&quot;/Users/egon/欧美100G高清无码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：上传至云服务器</span></span><br><span class="line">link=cloud_upload(zip_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：检测备份文件的可用性</span></span><br><span class="line">data_backup_check(link)</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.优点:</span><br><span class="line">	将复杂的问题流程化，进而简单化</span><br><span class="line">2.缺点:</span><br><span class="line">	牵一发而动全身，扩展性差</span><br><span class="line">3.应用场景:</span><br><span class="line">	面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。</span><br></pre></td></tr></table></figure>

<h3 id="三-函数式"><a href="#三-函数式" class="headerlink" title="三 .函数式"></a>三 .函数式</h3><p>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</p>
<h4 id="3-1-匿名函数与lambda"><a href="#3-1-匿名函数与lambda" class="headerlink" title="3.1 匿名函数与lambda"></a>3.1 匿名函数与lambda</h4><p> 对比使用def关键字创建的是有名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数，语法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数<span class="number">1</span>,参数<span class="number">2</span>,...: expression</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、定义</span><br><span class="line">	<span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">   	 	<span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、调用</span><br><span class="line">方式一：</span><br><span class="line">	res=(<span class="keyword">lambda</span> x,y,z:x+y+z)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">	func=<span class="keyword">lambda</span> x,y,z:x+y+z <span class="comment"># “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的</span></span><br><span class="line">	res=func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">salaries=&#123;</span><br><span class="line">    <span class="string">&#x27;siry&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;tom&#x27;</span>:<span class="number">7000</span>,</span><br><span class="line">    <span class="string">&#x27;lili&#x27;</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">&#x27;jack&#x27;</span>:<span class="number">2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想取得薪水的最大值和最小值，我们可以使用内置函数max和min（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(salaries)</span><br><span class="line">=&gt; <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="built_in">min</span>(salaries)</span><br><span class="line">==&gt; <span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>内置max和min都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字</span></span><br><span class="line"><span class="built_in">max</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k]) </span><br><span class="line">==&gt; <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line"><span class="built_in">min</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k])</span><br><span class="line">==&gt; <span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(salaries)</span><br><span class="line">==&gt; [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;siry&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-2-map、reduce、filter"><a href="#3-2-map、reduce、filter" class="headerlink" title="3.2 map、reduce、filter"></a>3.2 map、reduce、filter</h4><p>函数map、reduce、filter都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>要求一：对array的每个元素做平方处理，可以使用map函数</p>
<p>map函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,array)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">==&gt; &lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x1033f45f8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>解析：map会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而map函数得到的结果仍然是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(res) <span class="comment">#使用list可以依次迭代res，取得的值作为列表元素</span></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p>要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数</p>
<p>reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce </span><br><span class="line">res=reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">==&gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>​        1 没有初始值，reduce函数会先迭代一次array得到的值作为初始值，作为第一个值数传给x，然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为3</p>
<p>​        2 将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，依次类推，知道迭代完array的所有元素，得到最终的结果15也可以为reduce指定初始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res=reduce(<span class="keyword">lambda</span> x,y:x+y,array,<span class="number">100</span>) &gt;&gt;&gt; res</span><br><span class="line">==&gt; <span class="number">115</span></span><br></pre></td></tr></table></figure>

<p>要求三：对array进行过滤操作，这就用到了filter函数，比如过滤出大于3的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;<span class="number">3</span>,array)</span><br></pre></td></tr></table></figure>

<p>解析：filter函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而filter函数得到的结果仍然是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(res) </span><br><span class="line">==&gt; [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>​        我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者的功能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-28 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-28T17:27:55+08:00">2018-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h4 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、面向过程编程</span><br><span class="line">    核心是过程二字，过程指的是解决的步骤，即先干啥、再干啥、后干啥</span><br><span class="line">    基于该思想写程序就在设计一条条的流水线</span><br><span class="line"></span><br><span class="line">    优点：复杂的问题流程化、进而简单化</span><br><span class="line">    缺点：牵一发而动全身，扩展性差</span><br><span class="line"></span><br><span class="line">2、面向对象编程</span><br><span class="line">    核心是“对象”二字，对象指的是盛放相关的数据与功能的容器</span><br><span class="line">    基于该思想编写程序就在创造一个个的容器来把相关的东西盛到一起</span><br><span class="line"></span><br><span class="line">    优点：扩展性强</span><br><span class="line">    缺点：加大了编程的复杂度</span><br></pre></td></tr></table></figure>

<h2 id="一-对象的概念"><a href="#一-对象的概念" class="headerlink" title="一.对象的概念"></a>一.对象的概念</h2><p>”面向对象“的核心是“对象”二字，而对象的精髓在于“整合“，什么意思？</p>
<p>所有的程序都是由”数据”与“功能“组成，因而编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。在学习”对象“之前，程序中的数据与功能是分离开的，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据：name、age、sex</span></span><br><span class="line">name=<span class="string">&#x27;lili&#x27;</span></span><br><span class="line">age=<span class="number">18</span></span><br><span class="line">sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能：tell_info</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_info</span>(<span class="params">name,age,sex</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s:%s:%s&gt;&#x27;</span> %(name,age,sex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时若想执行查看个人信息的功能，需要同时拿来两样东西，一类是功能tell_info，另外一类则是多个数据name、age、sex，然后才能执行，非常麻烦</span></span><br><span class="line">tell_info(name,age,sex)</span><br></pre></td></tr></table></figure>

<p>在学习了“对象”之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说”对象“就是一个盛放数据与功能的容器/箱子/盒子。</p>
<p>如果把”数据“比喻为”睫毛膏“、”眼影“、”唇彩“等化妆所需要的原材料；把”功能“比喻为眼线笔、眉笔等化妆所需要的工具，那么”对象“就是一个彩妆盒，彩妆盒可以把”原材料“与”工具“都装到一起</p>
<p>如果我们把”化妆“比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了化妆所需的所有原材料与功能，这比起你分别拿来原材料与功能才能执行，要方便的多。</p>
<p> 在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性</p>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调:"></a>强调:</h4><p>​            软件质量属性包含很多方面，面向对象解决的仅仅只是扩展性问题</p>
<p><img src="https://pic1.zhimg.com/80/v2-be68cd9e27b83c937cf44dbe7a2cf56c_720w.jpg" alt="img"></p>
<h2 id="二-类与对象"><a href="#二-类与对象" class="headerlink" title="二.类与对象"></a>二.类与对象</h2><p>类即类别/种类，是面向对象分析和设计的基石，如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类。有了类的好处是：我们可以把同一类对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间。所以，如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器。</p>
<p><img src="https://pic2.zhimg.com/v2-0b1c2138d316307c0c830aa1df3aa1e1_r.jpg" alt="preview"></p>
<p> 综上所述，虽然我们是先介绍对象后介绍类，但是需要强调的是：在程序中，必须要事先定义类，然后再调用类产生对象（调用类拿到的返回值就是对象）。产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间、减少代码冗余的机制，面向对象编程最终的核心仍然是去使用对象。</p>
<h2 id="三-面向对象编程"><a href="#三-面向对象编程" class="headerlink" title="三.面向对象编程"></a>三.面向对象编程</h2><h3 id="3-1-类的定义与实例化"><a href="#3-1-类的定义与实例化" class="headerlink" title="3.1 类的定义与实例化"></a>3.1 类的定义与实例化</h3><p>面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用，但程序中要用到的数据以及功能那么多，如何找到相关连的呢？我需要先提取选课系统里的角色：学生、老师、课程等，然后显而易见的是：学生有学生相关的数据于功能，老师有老师相关的数据与功能，我们单以学生为例，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生的数据有</span></span><br><span class="line">学校</span><br><span class="line">名字</span><br><span class="line">年龄</span><br><span class="line">性别</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生的功能有</span></span><br><span class="line">选课</span><br></pre></td></tr></table></figure>

<p>详细的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生1：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=李建刚</span><br><span class="line">        性别=男</span><br><span class="line">        年龄=<span class="number">28</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生2：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=王大力</span><br><span class="line">        性别=女</span><br><span class="line">        年龄=<span class="number">18</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br></pre></td></tr></table></figure>

<p>我们可以总结出一个学生类，用来存放学生们相同的数据与功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生类</span></span><br><span class="line">    相同的特征:</span><br><span class="line">        学校=清华大学</span><br><span class="line">    相同的功能：</span><br><span class="line">        选课</span><br></pre></td></tr></table></figure>

<p>基于上述分析的结果，我们接下来需要做的就是在程序中定义出类，然后调用类产生对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="comment"># 类的命名应该使用“驼峰体”</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span> <span class="comment"># 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> <span class="comment"># 功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>打印Student.__dict__来查看类这个容器内盛放的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Student.__dict__)</span><br><span class="line">==&gt;  &#123;..., <span class="string">&#x27;school&#x27;</span>: <span class="string">&#x27;清华大学&#x27;</span>, <span class="string">&#x27;choose&#x27;</span>: &lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;, ...&#125;</span><br></pre></td></tr></table></figure>

<p>调用类的过程称为将类实例化，拿到的返回值就是程序中的对象，或称为一个实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu1=Student() <span class="comment"># 每实例化一次Student类就得到一个学生对象</span></span><br><span class="line">stu2=Student()</span><br></pre></td></tr></table></figure>

<p>如此stu1、stu2、stu3全都一样了（只有类中共有的内容，而没有各自独有的数据），想在实例化的过程中就为三位学生定制各自独有的数据：姓名，性别，年龄，需要我们在类内部新增一个__init__方法,如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>然后我们重新实例出三位学生</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1=Student(<span class="string">&#x27;李建刚&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">28</span>)</span><br><span class="line">stu2=Student(<span class="string">&#x27;王大力&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">stu3=Student(<span class="string">&#x27;牛嗷嗷&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">38</span>)</span><br></pre></td></tr></table></figure>

<p>单拿stu1的产生过程来分析，调用类会先产生一个空对象stu1，然后将stu1连同调用类时括号内的参数一起传给Student.<strong>init</strong>(stu1,’李建刚’,’男’,28)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex, age</span>):</span></span><br><span class="line">    self.name = name  <span class="comment"># stu1.name = &#x27;李建刚&#x27;</span></span><br><span class="line">    self.sex = sex    <span class="comment"># stu1.sex = &#x27;男&#x27;</span></span><br><span class="line">    self.age = age    <span class="comment"># stu1.age = 28</span></span><br></pre></td></tr></table></figure>

<p>会产生对象的名称空间，同样可以用__dict__查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(stu1.__dict__)</span><br><span class="line">==&gt; &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李建刚&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容</p>
<p><img src="https://pic2.zhimg.com/80/v2-c3bb7aefce6ffee1029b1ae5dee72689_720w.jpg" alt="img"></p>
<p>存的目的是为了用，那么如何访问对象或者类中存放的内容呢？</p>
<h3 id="3-2-属性访问"><a href="#3-2-属性访问" class="headerlink" title="3.2 属性访问"></a>3.2 属性访问</h3><h4 id="3-2-1-类属性与对象属性"><a href="#3-2-1-类属性与对象属性" class="headerlink" title="3.2.1 类属性与对象属性"></a>3.2.1 类属性与对象属性</h4><p>在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.<strong>dict</strong>[‘school’]，但Python提供了专门的属性访问语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student.school <span class="comment"># 访问数据属性，等同于Student.__dict__[&#x27;school&#x27;]</span></span><br><span class="line">==&gt; <span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line">Student.choose <span class="comment"># 访问函数属性，等同于Student.__dict__[&#x27;choose&#x27;]</span></span><br><span class="line">==&gt; &lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;</span><br><span class="line"><span class="comment"># 除了查看属性外，我们还可以使用Student.attrib=value(修改或新增属性),用del Student.attrib删除属性。</span></span><br></pre></td></tr></table></figure>

<p>操作对象的属性也是一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stu1.name <span class="comment"># 查看，等同于obj1.__dict__[‘name&#x27;]</span></span><br><span class="line">==&gt; <span class="string">&#x27;李建刚&#x27;</span></span><br><span class="line">stu1.course=’python’ <span class="comment"># 新增，等同于obj1.__dict__[‘course&#x27;]=&#x27;python&#x27;</span></span><br><span class="line">stu1.age=<span class="number">38</span> <span class="comment"># 修改，等同于obj1.__dict__[‘age&#x27;]=38</span></span><br><span class="line"><span class="keyword">del</span> obj1.course <span class="comment"># 删除，等同于del obj1.__dict__[&#x27;course&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-属性查找顺序与绑定方法"><a href="#3-2-2-属性查找顺序与绑定方法" class="headerlink" title="3.2.2 属性查找顺序与绑定方法"></a>3.2.2 属性查找顺序与绑定方法</h4><p>对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找</p>
<p><strong>1、类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id都一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.school)) <span class="comment"># 4301108704</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.school)) <span class="comment"># 4301108704</span></span><br></pre></td></tr></table></figure>

<p><strong>2、类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.choose(stu1) <span class="comment"># 李建刚 is choosing a course</span></span><br><span class="line">Student.choose(stu2) <span class="comment"># 王大力 is choosing a course</span></span><br><span class="line">Student.choose(stu3) <span class="comment"># 牛嗷嗷 is choosing a course</span></span><br></pre></td></tr></table></figure>

<p>但其实类中定义的函数主要是给对象使用的，而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.choose)) <span class="comment"># 4335426280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.choose)) <span class="comment"># 4300433608</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.choose)) <span class="comment"># 4300433625</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.choose)) <span class="comment"># 4300433694</span></span><br></pre></td></tr></table></figure>

<p>绑定到对象的方法特殊之处在于，绑定给谁就应该由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法__init__也是一样的道理）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1.choose()  <span class="comment"># 等同于Student.choose(stu1)</span></span><br><span class="line">stu2.choose()  <span class="comment"># 等同于Student.choose(stu2)</span></span><br><span class="line">stu3.choose()  <span class="comment"># 等同于Student.choose(stu3)</span></span><br></pre></td></tr></table></figure>

<p>绑定到不同对象的choose技能，虽然都是选课，但李建刚选的课，不会选给王大力，这正是”绑定“二字的精髓所在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">	绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h4><p>在上述介绍类与对象的使用过程中，我们更多的是站在底层原理的角度去介绍类与对象之间的关联关系，如果只是站在使用的角度，我们无需考虑语法“对象.属性”中”属性“到底源自于哪里，只需要知道是通过对象获取到的就可以了，所以说，对象是一个高度整合的产物，有了对象，我们只需要使用”对象.xxx“的语法就可以得到跟这个对象相关的所有数据与功能，十分方便且解耦合程度极高。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结:"></a>四.总结:</h2><h5 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">类的作用:</span><br><span class="line">	类是用来解决对象之间代码冗余问题的</span><br><span class="line">	</span><br><span class="line">类定义阶段发生的三件事:</span><br><span class="line">    1、会执行类体的代码</span><br><span class="line">    2、会产生一个类的名称空间，用来将类体代码运行过程中产生的名字都丢进去</span><br><span class="line">    3、将名称空间的内存地址绑定给类名</span><br><span class="line">    </span><br><span class="line">调用类也发生了三件事:</span><br><span class="line">    1、会创建空对象（调用__new__方法来创建的空对象）</span><br><span class="line">    2、会自动触发类中__init__函数的运行，__init__(空对象,&quot;zqw&quot;,18,&#x27;male&#x27;)，完成对象的初始化操作</span><br><span class="line">    3、返回该对象，赋值给stu1_dic</span><br><span class="line">    注意：__init__不能有返回值</span><br><span class="line">    </span><br><span class="line">类中有两种属性</span><br><span class="line">	1、数据属性</span><br><span class="line">	2、函数属性</span><br><span class="line">	</span><br><span class="line">类中的属性其实是为对象准备</span><br><span class="line">	1、类的属性是直接共享给所有对象用的</span><br><span class="line">	2、类的函数属性是绑定给对象用的</span><br></pre></td></tr></table></figure>

<h5 id="2-绑定方法"><a href="#2-绑定方法" class="headerlink" title="2.绑定方法"></a>2.绑定方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">	不管是类中的方法，还是类中函数，默认情况下都是绑定给对象使用的</span><br><span class="line">	</span><br><span class="line">类中定义的函数分为两大类:</span><br><span class="line">	一：绑定方法：绑定给谁就应该由谁来调用，谁来调用就会将自己当作第一个参数自动传入</span><br><span class="line">        绑定给对象:哪个对象来调用就将哪个对象当作第一个参数自动传入</span><br><span class="line">        绑定给类:绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍是类</span><br><span class="line">	二：非绑定方法：不与任何人绑定，意味着谁都可以来调用，但是无论谁来调用就是一个普通函数，没有自动传参的效果</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">	绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法(即普通函数)</span><br><span class="line"></span><br><span class="line">ps:类中定义了同名的对象方法、类方法、静态方法时，调用方法会优先执行最后定义的方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">绑定给类(@classmethod):</span><br><span class="line">	绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍是类</span><br><span class="line">	class Mysql:</span><br><span class="line">    def __init__(self, ip, port):</span><br><span class="line">        self.id = self.create_id()</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    def tell_info(self):</span><br><span class="line">        print(&quot;&lt;%s:%s&gt;&quot; % (self.ip, self.port))</span><br><span class="line"></span><br><span class="line">    @classmethod	# 默认参数cls，可以直接用类名调用，可以与类属性交互</span><br><span class="line">    def from_conf(cls):</span><br><span class="line">        return cls(&#x27;2.2.2&#x27;,6666)</span><br><span class="line"></span><br><span class="line">    res = Mysql.from_conf()</span><br><span class="line">    print(res.__dict__)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">非绑定方法(@staticmethod):</span><br><span class="line">	不与任何人绑定，意味着谁都可以来调用，但是无论谁来调用就是一个普通函数，没有自动传参的效果</span><br><span class="line">	class Mysql:</span><br><span class="line">    def __init__(self, ip, port):</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    def tell_info(self):</span><br><span class="line">        print(&quot;&lt;%s:%s&gt;&quot; % (self.ip, self.port))</span><br><span class="line"></span><br><span class="line">    @staticmethod	#静态方法:让类里的方法直接被类调用，就像正常的函数一样</span><br><span class="line">    def create_id(name):</span><br><span class="line">        import uuid</span><br><span class="line">        return uuid.uuid4(),name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    obj = Mysql(&#x27;1.1.1.1&#x27;, 3306)</span><br><span class="line"></span><br><span class="line">    res,msg = obj.create_id(&#x27;zqw&#x27;)</span><br><span class="line">    print(res,msg)</span><br></pre></td></tr></table></figure>

<h5 id="3-classmethod和staticmethod区别"><a href="#3-classmethod和staticmethod区别" class="headerlink" title="3.classmethod和staticmethod区别"></a>3.classmethod和staticmethod区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相同：都可以直接被类调用，不需要实例化</span><br><span class="line">不同:</span><br><span class="line">    1.类方法必须有一个cls参数表示这个类，可以使用类属性</span><br><span class="line">    2.静态方法不需要，静态方法不能直接使用,有几个参数传几个参数</span><br></pre></td></tr></table></figure>

<h5 id="4-实例-类-静态"><a href="#4-实例-类-静态" class="headerlink" title="4.实例,类,静态"></a>4.实例,类,静态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例方法</span><br><span class="line">    定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)；</span><br><span class="line">    调用：只能由实例对象调用。</span><br><span class="line"></span><br><span class="line">类方法</span><br><span class="line">    定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法(不能传实例的属性和方法)</span><br><span class="line">    调用：实例对象和类对象都可以调用(实例对象调用毫无意义)</span><br><span class="line"></span><br><span class="line">静态方法</span><br><span class="line">    定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</span><br><span class="line">    调用：实例对象和类对象都可以调用</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/20/%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/20/%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">反射、内置方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-20 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-20T17:27:55+08:00">2018-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="反射、内置方法"><a href="#反射、内置方法" class="headerlink" title="反射、内置方法"></a>反射、内置方法</h1><h3 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射：</span><br><span class="line">	通过字符串来操作属性</span><br></pre></td></tr></table></figure>

<p>python是动态语言，而反射(reflection)机制被视为动态语言的关键。</p>
<p>反射机制指的是在程序的运行状态中</p>
<p>对于任意一个类，都可以知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用他的任意方法和属性。</p>
<p>这种动态获取程序信息以及动态调用对象的功能称为反射机制。</p>
<p>在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数dir来获取任意一个类或者对象的属性列表，列表中全为字符串格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,gender</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.age=age</span><br><span class="line">         self.gender=gender</span><br><span class="line"> </span><br><span class="line">obj=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"><span class="built_in">dir</span>(obj) <span class="comment"># 列表中查看到的属性全为字符串</span></span><br><span class="line">==&gt; [......,<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>接下来就是想办法通过字符串来操作对象的属性了，这就涉及到内置函数hasattr、getattr、setattr、delattr的使用了（Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,full_name</span>):</span></span><br><span class="line">        self.full_name =full_name</span><br><span class="line"></span><br><span class="line">t=Teacher(<span class="string">&#x27;Egon Lin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hasattr(object,&#x27;name&#x27;)</span></span><br><span class="line"><span class="built_in">hasattr</span>(t,<span class="string">&#x27;full_name&#x27;</span>) <span class="comment"># 按字符串&#x27;full_name&#x27;判断有无属性t.full_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getattr(object, &#x27;name&#x27;, default=None)</span></span><br><span class="line"><span class="built_in">getattr</span>(t,<span class="string">&#x27;full_name&#x27;</span>,<span class="literal">None</span>) <span class="comment"># 等同于t.full_name,不存在该属性则返回默认值None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setattr(x, &#x27;y&#x27;, v)</span></span><br><span class="line"><span class="built_in">setattr</span>(t,<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>) <span class="comment"># 等同于t.age=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delattr(x, &#x27;y&#x27;)</span></span><br><span class="line"><span class="built_in">delattr</span>(t,<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 等同于del t.age</span></span><br></pre></td></tr></table></figure>

<p>基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FtpServer</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>            inp=<span class="built_in">input</span>(<span class="string">&#x27;input your cmd&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line"><span class="meta">... </span>            cmd,file=inp.split()</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd): <span class="comment"># 根据用户输入的cmd，判断对象self有无对应的方法属性</span></span><br><span class="line"><span class="meta">... </span>                func=<span class="built_in">getattr</span>(self,cmd) <span class="comment"># 根据字符串cmd，获取对象self对应的方法属性</span></span><br><span class="line"><span class="meta">... </span>                func(file)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,file</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Downloading %s...&#x27;</span> %file)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,file</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Uploading %s...&#x27;</span> %file)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server=FtpServer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.serve_forever()</span><br><span class="line"><span class="built_in">input</span> your cmd&gt;&gt;: get a.txt</span><br><span class="line">Downloading a.txt...</span><br><span class="line"><span class="built_in">input</span> your cmd&gt;&gt;: put a.txt</span><br><span class="line">Uploading a.txt...</span><br></pre></td></tr></table></figure>

<h3 id="二-内置方法"><a href="#二-内置方法" class="headerlink" title="二 内置方法"></a>二 内置方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内置方法:</span><br><span class="line">	在满足某种条件下会自动触发执行</span><br></pre></td></tr></table></figure>

<p>Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。</p>
<p>__str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        self.age=age</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>	<span class="comment"># 打印对象时自动触发执行，将返回值当作打印结果</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;&lt;Name:%s Age:%s&gt;&#x27;</span> %(self.name,self.age) <span class="comment">#返回类型必须是字符串</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p=People(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p) <span class="comment">#触发p.__str__()，拿到返回值后进行打印</span></span><br><span class="line">&lt;Name:lili Age:<span class="number">18</span>&gt;</span><br></pre></td></tr></table></figure>

<p>__del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ip,port</span>):</span></span><br><span class="line">        self.conn=connect(ip,port) <span class="comment"># 伪代码，发起网络连接，需要占用系统资源</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn.close() <span class="comment"># 关闭网络连接，回收系统资源</span></span><br><span class="line"></span><br><span class="line">obj=MySQL(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">3306</span>) <span class="comment"># 在对象obj被删除时，自动触发obj.__del__()</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/19/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/19/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">多态性与鸭子类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-19 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-19T17:27:55+08:00">2018-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多态性与鸭子类型"><a href="#多态性与鸭子类型" class="headerlink" title="多态性与鸭子类型"></a>多态性与鸭子类型</h1><h3 id="一-多态与多态性"><a href="#一-多态与多态性" class="headerlink" title="一.多态与多态性"></a>一.多态与多态性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.什么是多态?</span><br><span class="line">	同一种事物有多种形态</span><br><span class="line">2.什么是多态性?</span><br><span class="line">	我们可以在不用知道对象具体类型的前提下，而直接使用对象</span><br><span class="line">3.多态性好处:</span><br><span class="line">	增强了程序的灵活性和可扩展性</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span> <span class="comment">#同一类事物:动物</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之一:猫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;喵喵喵&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之二:狗</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;汪汪汪&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之三:猪</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;哼哼哼&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化得到三个对象</span></span><br><span class="line">cat=Cat()</span><br><span class="line">dog=Dog()</span><br><span class="line">pig=Pig()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat.talk()</span><br><span class="line">==&gt; 喵喵喵</span><br><span class="line">dog.talk()</span><br><span class="line">==&gt; 汪汪汪</span><br><span class="line">pig.talk()</span><br><span class="line">==&gt; 哼哼哼</span><br></pre></td></tr></table></figure>

<p>更进一步,我们可以定义一个统一的接口来使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Talk</span>(<span class="params">animal</span>):</span></span><br><span class="line">     animal.talk()</span><br><span class="line"> </span><br><span class="line">Talk(cat)</span><br><span class="line">==&gt; 喵喵喵</span><br><span class="line">Talk(dog)</span><br><span class="line">==&gt; 汪汪汪</span><br><span class="line">Talk(pig)</span><br><span class="line">==&gt; 哼哼哼</span><br></pre></td></tr></table></figure>

<p>Python中一切皆对象，本身就支持多态性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以在不考虑三者类型的情况下直接使用统计三个对象的长度</span></span><br><span class="line">s.__len__()</span><br><span class="line">l.__len__()</span><br><span class="line">t.__len__()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置了一个统一的接口</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">len</span>(l)</span><br><span class="line"><span class="built_in">len</span>(t)</span><br></pre></td></tr></table></figure>

<p>多态性的好处在于增强了程序的灵活性和可扩展性，比如通过继承Animal类创建了一个新的类，实例化得到的对象obj，可以使用相同的方式使用obj.talk()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的另外一种形态：狼</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;嗷...&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">wolf=Wolf() <span class="comment"># 实例出一头狼</span></span><br><span class="line">wolf.talk() <span class="comment"># 使用者根本无需关心wolf是什么类型而调用talk</span></span><br><span class="line">==&gt; 嗷...</span><br></pre></td></tr></table></figure>

<p>综上我们得知，多态性的本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象，可以通过在父类引入抽象类的概念来硬性限制子类必须有某些方法名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment"># 该装饰器限制子类必须定义有一个名为talk的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span> <span class="comment"># 抽象方法中无需实现具体的功能</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment"># 但凡继承Animal的子类都必须遵循Animal规定的标准</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cat=Cat() <span class="comment"># 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化</span></span><br></pre></td></tr></table></figure>

<h3 id="二-鸭子类型"><a href="#二-鸭子类型" class="headerlink" title="二.鸭子类型"></a>二.鸭子类型</h3><p>但其实我们完全可以不依赖于继承，只需要制造出外观和行为相同对象，同样可以实现不考虑对象类型而使用对象，这正是Python崇尚的“鸭子类型”（duck typing）：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子”。比起继承的方式，鸭子类型在某种程度上实现了程序的松耦合度，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二者看起来都像文件,因而就可以当文件一样去用，然而它们并没有直接的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Txt</span>:</span> <span class="comment">#Txt类有两个与文件类型同名的方法，即read和write</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span>:</span> <span class="comment">#Disk类也有两个与文件类型同名的方法：read和write</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/19/%E5%B0%81%E8%A3%85,%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/19/%E5%B0%81%E8%A3%85,%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/" class="post-title-link" itemprop="url">编程语言与Python介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-19 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-19T17:27:55+08:00">2018-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="封装-继承与派生"><a href="#封装-继承与派生" class="headerlink" title="封装,继承与派生"></a>封装,继承与派生</h1><h2 id="一-封装"><a href="#一-封装" class="headerlink" title="一.封装"></a>一.封装</h2><h3 id="一-引入"><a href="#一-引入" class="headerlink" title="一.引入"></a>一.引入</h3><pre><code>     面向对象编程有三大特性：封装、继承、多态，其中最重要的一个特性就是封装。封装指的就是把数据与功能都整合到一起，听起来是不是很熟悉，没错，我们之前所说的”整合“二字其实就是封装的通俗说法。除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：隐藏与开放接口
</code></pre>
<h3 id="二-隐藏属性"><a href="#二-隐藏属性" class="headerlink" title="二.隐藏属性"></a>二.隐藏属性</h3><p>Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成“_类名__属性名”的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __N=<span class="number">0</span> <span class="comment"># 变形为_Foo__N</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 定义函数时，会检测函数语法，所以__开头的属性也会变形</span></span><br><span class="line">        self.__x=<span class="number">10</span> <span class="comment"># 变形为self._Foo__x</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f1</span>(<span class="params">self</span>):</span> <span class="comment"># 变形为_Foo__f1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__f1 run&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span>  <span class="comment"># 定义函数时，会检测函数语法，所以__开头的属性也会变形</span></span><br><span class="line">        self.__f1() <span class="comment">#变形为self._Foo__f1()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__N) <span class="comment"># 报错AttributeError:类Foo没有属性__N</span></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obbj.__x) <span class="comment"># 报错AttributeError:对象obj没有属性__x</span></span><br></pre></td></tr></table></figure>

<p>这种变形需要注意的问题是：</p>
<p><strong>1、在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如Foo._A__N，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Foo.__dict__)</span><br><span class="line">==&gt; mappingproxy(&#123;..., <span class="string">&#x27;_Foo__N&#x27;</span>: <span class="number">0</span>, ...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">==&gt; &#123;<span class="string">&#x27;_Foo__x&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo._Foo__N)</span><br><span class="line">==&gt; <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(obj._Foo__x)</span><br><span class="line">==&gt; <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(obj._Foo__N)</span><br><span class="line">==&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>2、在类内部是可以直接访问双下滑线开头的属性的，比如self.__f1()，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.f2()</span><br><span class="line">==&gt; __f1 run</span><br></pre></td></tr></table></figure>

<p><strong>3、变形操作只在类定义阶段发生一次,在类定义之后的赋值操作，不会变形。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Foo.__M=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(Foo.__dict__)</span><br><span class="line">==&gt; mappingproxy(&#123;..., <span class="string">&#x27;__M&#x27;</span>: <span class="number">100</span>,...&#125;)</span><br><span class="line"><span class="built_in">print</span>(Foo.__M)</span><br><span class="line">==&gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line">obj.__y=<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">==&gt; &#123;<span class="string">&#x27;__y&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;_Foo__x&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(obj.__y)</span><br><span class="line">==&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="三-开放接口"><a href="#三-开放接口" class="headerlink" title="三.开放接口"></a>三.开放接口</h3><p><strong>定义属性就是为了使用，所以隐藏并不是目的</strong></p>
<h4 id="3-1-隐藏数据属性"><a href="#3-1-隐藏数据属性" class="headerlink" title="3.1 隐藏数据属性"></a>3.1 隐藏数据属性</h4><p>将数据隐藏起来就限制了类外部对数据的直接操作，然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.隐藏数据属性的目的: 为了严格控制某一属性的操作</span><br><span class="line">class People:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        print(&quot;名字:%s&quot; % self.__name)</span><br><span class="line"></span><br><span class="line">    def set_name(self, v):</span><br><span class="line">        if type(v) is not str:</span><br><span class="line">            print(&quot;名字必须是str类型小垃圾&quot;)</span><br><span class="line">            return</span><br><span class="line">        self.__name = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = People(&#x27;egon&#x27;, 18)</span><br><span class="line"></span><br><span class="line">obj.get_name()</span><br><span class="line">obj.set_name(123)</span><br><span class="line">obj.get_name()</span><br></pre></td></tr></table></figure>

<h4 id="3-2-隐藏函数属性"><a href="#3-2-隐藏函数属性" class="headerlink" title="3.2 隐藏函数属性"></a>3.2 隐藏函数属性</h4><p>目的的是为了隔离复杂度，例如ATM程序的取款功能,该功能有很多其他功能组成，比如插卡、身份认证、输入金额、打印小票、取钱等，而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2.隐藏函数属性的目的：隔离复杂度</span><br><span class="line">class ATM:</span><br><span class="line">     def __card(self): #插卡</span><br><span class="line">         print(&#x27;插卡&#x27;)</span><br><span class="line">     def __auth(self): #身份认证</span><br><span class="line">         print(&#x27;用户认证&#x27;)</span><br><span class="line">     def __input(self): #输入金额</span><br><span class="line">         print(&#x27;输入取款金额&#x27;)</span><br><span class="line">     def __print_bill(self): #打印小票</span><br><span class="line">         print(&#x27;打印账单&#x27;)</span><br><span class="line">     def __take_money(self): #取钱</span><br><span class="line">         print(&#x27;取款&#x27;)</span><br><span class="line">     def withdraw(self): #取款功能</span><br><span class="line">         self.__card()</span><br><span class="line">         self.__auth()</span><br><span class="line">         self.__input()</span><br><span class="line">         self.__print_bill()</span><br><span class="line">         self.__take_money()</span><br><span class="line"></span><br><span class="line">obj=ATM()</span><br><span class="line">obj.withdraw()</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<p>​        隐藏属性与开放接口，本质就是为了明确地区分内外，类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑。</p>
<h3 id="四-property"><a href="#四-property" class="headerlink" title="四 property"></a>四 property</h3><p>BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">体质指数（BMI）=体重（kg）÷身高^<span class="number">2</span>（m）</span><br><span class="line">EX：70kg÷（<span class="number">1.75</span>×<span class="number">1.75</span>）=<span class="number">22.86</span></span><br></pre></td></tr></table></figure>

<p>身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能，为此Python专门提供了一个<strong>装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果</strong>，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,weight,height</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.weight=weight</span><br><span class="line">         self.height=height</span><br><span class="line"><span class="meta">     @property</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">bmi</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self.weight / (self.height**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">obj=People(<span class="string">&#x27;lili&#x27;</span>,<span class="number">75</span>,<span class="number">1.85</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.bmi) <span class="comment">#触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果</span></span><br><span class="line"><span class="number">21.913805697589478</span></span><br></pre></td></tr></table></figure>

<p>使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">         self.__NAME=val <span class="comment">#将属性隐藏起来</span></span><br><span class="line"><span class="meta">     @property</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self.__NAME</span><br><span class="line"><span class="meta">     @name.setter</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,value</span>):</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value,<span class="built_in">str</span>):  <span class="comment">#在设定值之前进行类型检查</span></span><br><span class="line">             <span class="keyword">raise</span> TypeError(<span class="string">&#x27;%s must be str&#x27;</span> %value)</span><br><span class="line">         self.__NAME=value <span class="comment">#通过类型检查后,将值value存放到真实的位置self.__NAME</span></span><br><span class="line"><span class="meta">     @name.deleter</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">raise</span> PermissionError(<span class="string">&#x27;Can not delete&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f=Foo(<span class="string">&#x27;lili&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.name)</span><br><span class="line">==&gt; lili</span><br><span class="line">f.name=<span class="string">&#x27;LiLi&#x27;</span> <span class="comment">#触发name.setter装饰器对应的函数name(f,’Egon&#x27;)</span></span><br><span class="line">f.name=<span class="number">123</span> <span class="comment">#触发name.setter对应的的函数name(f,123),抛出异常TypeError</span></span><br><span class="line"><span class="keyword">del</span> f.name <span class="comment">#触发name.deleter对应的函数name(f),抛出异常PermissionError</span></span><br></pre></td></tr></table></figure>

<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__开头的属性隐藏有四个特点：</span><br><span class="line">    1、并不是真正的隐藏，只是一种语法意义上的变形</span><br><span class="line">    2、该变形操作只在类定义阶段扫描语法时发生一次，类定义之后__开头的属性不会变形</span><br><span class="line">    3、该隐藏对外不对内,类内部可以直接使用,外不无法直接使用</span><br><span class="line"></span><br><span class="line">隐藏属性和隐藏函数:</span><br><span class="line">	1.隐藏数据属性的目的: 为了严格控制某一属性的操作</span><br><span class="line">	2.隐藏函数属性的目的：隔离复杂度</span><br></pre></td></tr></table></figure>

<h2 id="二-继承"><a href="#二-继承" class="headerlink" title="二.继承"></a>二.继承</h2><h3 id="一-继承介绍"><a href="#一-继承介绍" class="headerlink" title="一.继承介绍"></a>一.继承介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、什么是继承?</span><br><span class="line">    1.继承是一种新建子类的方式，新建的类称之为子类/派生类，被继承的称之为父类/基类</span><br><span class="line">    2.子类会遗传父类的属性</span><br><span class="line"></span><br><span class="line">2、为何要用继承?</span><br><span class="line">    1.类是解决对象之间冗余问题的</span><br><span class="line">    2.继承可以解决类与类之间的冗余问题</span><br><span class="line"></span><br><span class="line">3、如何继承?</span><br><span class="line">    在python中支持多继承</span><br><span class="line"></span><br><span class="line">    在python3中如果一个类没有继承任何父类，那么默认继承object类</span><br><span class="line"></span><br><span class="line">    但凡是继承了object类的子类，以及该子类的子子孙孙类都能用到object内的功能，称之为新式类</span><br><span class="line">    没有继承了object类的子类，以及该子类的子子孙孙类都能用不到object内的功能，称之为经典类</span><br><span class="line"></span><br><span class="line">ps：只有在python2中才区分经典类与新式类，python3中都是新式类</span><br></pre></td></tr></table></figure>

<p>继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass1</span>:</span> <span class="comment">#定义父类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass2</span>:</span> <span class="comment">#定义父类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span>(<span class="params">ParentClass1</span>):</span> <span class="comment">#单继承</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span>(<span class="params">ParentClass1,ParentClass2</span>):</span> <span class="comment">#多继承</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>通过类的内置属性__bases__可以查看类继承的所有父类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>SubClass2.__bases__</span><br><span class="line">(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ParentClass1</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ParentClass2</span>&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p>在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。而在Python3中，即使没有显式地继承object，也会默认继承该类，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ParentClass1.__bases__</span><br><span class="line">(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">object</span>&#x27;&gt;,)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">ParentClass2</span>.<span class="title">__bases__</span></span></span><br><span class="line"><span class="class">(<span class="params">&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;,</span>)</span></span><br></pre></td></tr></table></figure>

<p>因而在Python3中统一都是新式类，关于经典类与新式类的区别，我们稍后讨论</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示：<span class="built_in">object</span>类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__</span><br></pre></td></tr></table></figure>

<h3 id="二-继承与抽象"><a href="#二-继承与抽象" class="headerlink" title="二.继承与抽象"></a>二.继承与抽象</h3><p>要找出类与类之间的继承关系，需要先抽象，再继承。抽象即总结相似之处，总结对象之间的相似之处得到类，总结类与类之间的相似之处就可以得到父类，如下图所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-10df80634dbda00e4dcb4113c2a75b3c_720w.jpg" alt="img"></p>
<p>基于抽象的结果，我们就找到了继承关系</p>
<p><img src="https://pic1.zhimg.com/80/v2-d22528a722bfbb1765b99d1d75d8f1a4_720w.jpg" alt="img"></p>
<p>基于上图我们可以看出类与类之间的继承指的是什么’是’什么的关系（比如人类，猪类，猴类都是动物类）。子类可以继承／遗传父类所有的属性，因而继承可以用来解决类与类之间的代码重用性问题。比如我们按照定义Student类的方式再定义一个Teacher类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>类Teacher与Student之间存在重复的代码，老师与学生都是人类，所以我们可以得出如下继承关系，实现代码重用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">People</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">People</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>Teacher类内并没有定义__init__方法，但是会从父类中找到__init__,因而仍然可以正常实例化，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">teacher1=Teacher(<span class="string">&#x27;lili&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(teacher1.school,teacher1.name,teacher1.sex,teacher1.age)</span><br><span class="line">==&gt; (<span class="string">&#x27;清华大学&#x27;</span>, <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h3 id="三-属性查找"><a href="#三-属性查找" class="headerlink" title="三.属性查找"></a>三.属性查找</h3><p>有了继承关系，对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f2&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        self.f1()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">Foo</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.f2()</span><br><span class="line">Foo.f2</span><br><span class="line">Foo.f1</span><br></pre></td></tr></table></figure>

<p>b.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即b.f1()，仍会按照：对象本身-&gt;类Bar-&gt;父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Foo.f1</p>
<p>父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__f1</span>(<span class="params">self</span>):</span> <span class="comment"># 变形为_Foo__fa</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>) </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f2&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        self.__f1() <span class="comment"># 变形为self._Foo__fa,因而只会调用自己所在的类中的方法</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">Foo</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__f1</span>(<span class="params">self</span>):</span> <span class="comment"># 变形为_Bar__f1</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.f2() <span class="comment">#在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法</span></span><br><span class="line">Foo.f2</span><br><span class="line">Foo.f1</span><br></pre></td></tr></table></figure>

<h3 id="四-继承的实现原理"><a href="#四-继承的实现原理" class="headerlink" title="四 继承的实现原理"></a>四 继承的实现原理</h3><h4 id="4-1-菱形问题"><a href="#4-1-菱形问题" class="headerlink" title="4.1 菱形问题"></a>4.1 菱形问题</h4><p> 大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Diamond_problem">Diamond problem</a>菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c6088a106bbf1fc46de0cca9c03a037_720w.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。</span><br></pre></td></tr></table></figure>

<p>这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和/或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B,C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = D()</span><br><span class="line">obj.test() <span class="comment"># 结果为：from B</span></span><br></pre></td></tr></table></figure>

<p>要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理</p>
<h4 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h4><p>python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法<strong>解析顺序(MRO)列表</strong>，该MRO列表就是一个简单的所有基类的线性顺序列表，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.mro()) <span class="comment"># 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法</span></span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">D</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">B</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">A</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure>

<p>python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个<strong>C3线性化算法</strong>来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>子类会先于父类被检查</span><br><span class="line"><span class="number">2.</span>多个父类会根据它们在列表中的顺序被检查</span><br><span class="line"><span class="number">3.</span>如果对下一个类存在两个合法的选择,选择第一个父类</span><br></pre></td></tr></table></figure>

<p>所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps：	</span><br><span class="line">    <span class="number">1.</span>由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，</span><br><span class="line">    <span class="number">2.</span>由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去，</span><br></pre></td></tr></table></figure>

<h4 id="4-3-深度优先和广度优先"><a href="#4-3-深度优先和广度优先" class="headerlink" title="4.3 深度优先和广度优先"></a>4.3 深度优先和广度优先</h4><p><strong>多继承关系为非菱形结构</strong>，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p>
<p><img src="https://pic4.zhimg.com/80/v2-64faa1a6e825277233fe2bf40401b99b_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from E&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from F&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">E</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">F</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">B, C, D</span>):</span></span><br><span class="line">    <span class="comment"># def test(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;from A&#x27;)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.mro())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.F&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">obj = A()</span><br><span class="line">obj.test() <span class="comment"># 结果为：from B</span></span><br><span class="line"><span class="comment"># 可依次注释上述类中的方法test来进行验证</span></span><br></pre></td></tr></table></figure>

<p><strong>多继承关系为菱形结构</strong>，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：<strong>深度优先和广度优先</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-e95d9f13b01af6eb7da3b5043442f697_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span>:</span> <span class="comment"># 在python2中，未继承object的类及其子类，都是经典类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from G&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from E&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from F&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">E</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">F</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">B,C,D</span>):</span></span><br><span class="line">    <span class="comment"># def test(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;from A&#x27;)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = A()</span><br><span class="line">obj.test() <span class="comment"># 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object</span></span><br><span class="line"><span class="comment"># 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-08eb8fd2226110ae845da74805cb98fb_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from G&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from E&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from F&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">E</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">F</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">B,C,D</span>):</span></span><br><span class="line">    <span class="comment"># def test(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;from A&#x27;)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = A()</span><br><span class="line">obj.test() <span class="comment"># 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object</span></span><br><span class="line"><span class="comment"># 可依次注释上述类中的方法test来进行验证</span></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">单继承下属性查找:</span><br><span class="line">	先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找……</span><br><span class="line">多继承下属性查找:</span><br><span class="line">	1.非菱形继承关系</span><br><span class="line">		非菱形继承关系下，新式类与经典的属性查找属性都一样，都是一个分支一个分支地找下取</span><br><span class="line">	2.菱形继承关系</span><br><span class="line">		菱形继承/死亡钻石：一个类继承的多条分支最终汇聚到一个非object类上</span><br><span class="line">			新式类：广度优先，最后找“大脑袋”(object)</span><br><span class="line">			经典类：深度优先，在第一条分支就会检索到“大脑袋”(object)</span><br><span class="line">注意:</span><br><span class="line">	多个类最终都继承object类不属于菱形问题</span><br></pre></td></tr></table></figure>

<h4 id="4-4-Pyton-Mixins机制"><a href="#4-4-Pyton-Mixins机制" class="headerlink" title="4.4 Pyton Mixins机制"></a>4.4 Pyton Mixins机制</h4><p> 一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？</p>
<p> 答案是有，我们还是拿交通工具来举例子:</p>
<p> 民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span>  <span class="comment"># 交通工具</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        飞行功能相应的代码        </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am flying&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CivilAircraft</span>(<span class="params">Vehicle</span>):</span>  <span class="comment"># 民航飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helicopter</span>(<span class="params">Vehicle</span>):</span>  <span class="comment"># 直升飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">Vehicle</span>):</span>  <span class="comment"># 汽车并不会飞，但按照上述继承关系，汽车也能飞了</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）</p>
<p>怎么办？？？为了尽可能地重用代码，那就只好在定义出一个飞行器的类，然后让民航飞机和直升飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么解决？ 不同的语言给出了不同的方法，让我们先来了解Java的处理方法。Java提供了接口interface功能，来实现多重继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类：交通工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口：飞行器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类：实现了飞行器接口的类，在该类中实现具体的fly方法，这样下面民航飞机与直升飞机在实现fly时直接重用即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableImpl</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 民航飞机，继承自交通工具类，并实现了飞行器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CivilAircraft</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CivilAircraft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyable = <span class="keyword">new</span> FlyableImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyable.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直升飞机，继承自交通工具类，并实现了飞行器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helicopter</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Helicopter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyable = <span class="keyword">new</span> FlyableImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyable.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车，继承自交通工具类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的飞机同时具有了交通工具及飞行器两种属性，而且我们不需要重写飞行器中的飞行方法，同时我们没有破坏单一继承的原则。飞机就是一种交通工具，可飞行的能力是飞机的属性，通过继承接口来获取。</p>
<p>回到主题，Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属”is-a”关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span>  <span class="comment"># 交通工具</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyableMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        飞行功能相应的代码        </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am flying&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CivilAircraft</span>(<span class="params">FlyableMixin, Vehicle</span>):</span>  <span class="comment"># 民航飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helicopter</span>(<span class="params">FlyableMixin, Vehicle</span>):</span>  <span class="comment"># 直升飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">Vehicle</span>):</span>  <span class="comment"># 汽车</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路</span></span><br></pre></td></tr></table></figure>

<p>可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，它的作用同Java中的接口。所以从含义上理解，CivilAircraft、Helicopter类都只是一个Vehicle，而不是一个飞行器。</p>
<p><strong>使用Mixin类实现多重继承要非常小心</strong></p>
<ul>
<li>首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀</li>
<li>其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类</li>
<li>然后，它不依赖于子类的实现</li>
<li>最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）</li>
</ul>
<p> Mixins是从多个类中重用代码的好方法，但是需要付出相应的代价，我们定义的Minx类越多，子类的代码可读性就会越差，并且更恶心的是，在继承的层级变多时，代码阅读者在定位某一个方法到底在何处调用时会晕头转向，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Displayer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggerMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">self, message, filename=<span class="string">&#x27;logfile.txt&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">            fh.write(message)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().display(message) <span class="comment"># super的用法请参考下一小节</span></span><br><span class="line">        self.log(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>(<span class="params">LoggerMixin, Displayer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().log(message, filename=<span class="string">&#x27;subclasslog.txt&#x27;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = MySubClass()</span><br><span class="line">obj.display(<span class="string">&quot;This string will be shown and logged in subclasslog.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性查找的发起者是obj,所以会参照类MySubClass的MRO来检索属性</span></span><br><span class="line"><span class="comment">#[&lt;class &#x27;__main__.MySubClass&#x27;&gt;, &lt;class &#x27;__main__.LoggerMixin&#x27;&gt;, &lt;class &#x27;__main__.Displayer&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、首先会去对象obj的类MySubClass找方法display，没有则去类LoggerMixin中找，找到开始执行代码</span></span><br><span class="line"><span class="comment"># 2、执行LoggerMixin的第一行代码：执行super().display(message)，参照MySubClass.mro(),super会去下一个类即类Displayer中找，找到display，开始执行代码，打印消息&quot;This string will be shown and logged in subclasslog.txt&quot;</span></span><br><span class="line"><span class="comment"># 3、执行LoggerMixin的第二行代码：self.log(message)，self是对象obj，即obj.log(message)，属性查找的发起者为obj，所以会按照其类MySubClass.mro(),即MySubClass-&gt;LoggerMixin-&gt;Displayer-&gt;object的顺序查找，在MySubClass中找到方法log，开始执行super().log(message, filename=&#x27;subclasslog.txt&#x27;)，super会按照MySubClass.mro()查找下一个类，在类LoggerMixin中找到log方法开始执行，最终将日志写入文件subclasslog.txt</span></span><br></pre></td></tr></table></figure>

<p>ps：课外了解小知识</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java只允许接口的多重继承。接口本质上是抽象基类，具有所有抽象方法，没有数据成员。</span><br><span class="line">与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化，继承的子类必须实现抽象基类规定的方法，这样便可保证始终只有一个特定方法或属性的实现，并且不会产生歧义，因而也可以起到避免菱形问题的作用</span><br><span class="line"></span><br><span class="line">java的interface：https://www.cnblogs.com/linhaifeng/articles/<span class="number">7340153.</span>html<span class="comment">#_label6</span></span><br><span class="line">python的抽象基类：https://www.cnblogs.com/linhaifeng/articles/<span class="number">7340153.</span>html<span class="comment">#_label7</span></span><br></pre></td></tr></table></figure>

<h2 id="三-派生"><a href="#三-派生" class="headerlink" title="三.派生"></a>三.派生</h2><h4 id="派生与方法重用"><a href="#派生与方法重用" class="headerlink" title="派生与方法重用"></a>派生与方法重用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是派生?</span><br><span class="line">	派生就是子类在继承父类的基础上衍生出新的属性。子类中独有的，父类中没有的；或子类定义与父类重名的东西。子类也叫派生类</span><br></pre></td></tr></table></figure>

<p>子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的__init__覆盖父类的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">     school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.sex=sex</span><br><span class="line">         self.age=age</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">People</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age,title</span>):</span> <span class="comment"># 派生</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.sex=sex</span><br><span class="line">         self.age=age</span><br><span class="line">         self.title=title</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br><span class="line"> </span><br><span class="line">obj=Teacher(<span class="string">&#x27;lili&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;高级讲师&#x27;</span>) <span class="comment">#只会找自己类中的__init__，并不会自动调用父类的</span></span><br><span class="line"><span class="built_in">print</span>(obj.name,obj.sex,obj.age,obj.title)</span><br><span class="line">==&gt; (<span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;高级讲师&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>很明显子类Teacher中__init__内的前三行又是在写重复代码，若想在子类派生出的方法内重用父类的功能，有两种实现方式</p>
<h5 id="一-子类中重用父类功能"><a href="#一-子类中重用父类功能" class="headerlink" title="一.子类中重用父类功能"></a>一.子类中重用父类功能</h5><p><strong>方法一：</strong></p>
<p>​        <strong>“指名道姓”地调用某一个类的函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">People</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age,title</span>):</span></span><br><span class="line">         People.__init__(self,name,age,sex) <span class="comment">#调用的是函数,因而需要传入self</span></span><br><span class="line">         self.title=title</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>​            <strong>super()</strong></p>
<p>调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">People</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age,title</span>):</span></span><br><span class="line">         <span class="built_in">super</span>().__init__(name,age,sex) <span class="comment">#调用的是绑定方法，自动传入self</span></span><br><span class="line">         self.title=title</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>提示：在Python2中super的使用需要完整地写成super(自己的类名,self) ,而在python3中可以简写为super()。</p>
<p>这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A没有继承B</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">super</span>().test()</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(C.mro()) <span class="comment"># 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”</span></span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">A</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">B</span>&#x27;&gt;,&lt;<span class="title">class</span> ‘<span class="title">object</span>&#x27;&gt;]</span></span><br><span class="line"><span class="class"><span class="title">obj</span>=<span class="title">C</span>()</span></span><br><span class="line"><span class="class"><span class="title">print</span>(<span class="params">obj.test(<span class="params"></span>)</span>) # 属性查找的发起者是类<span class="title">C</span>的对象<span class="title">obj</span>，所以中途发生的属性查找都是参照<span class="title">C</span>.<span class="title">mro</span>()</span></span><br><span class="line"><span class="class"><span class="title">from</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"># <span class="title">obj</span>.<span class="title">test</span>()首先找到<span class="title">A</span>下的<span class="title">test</span>方法，执行<span class="title">super</span>().<span class="title">test</span>()会基于<span class="title">MRO</span>列表(<span class="params">以C.mro(<span class="params"></span>)为准</span>)当前所处的位置继续往后查找()，然后在<span class="title">B</span>中找到了<span class="title">test</span>方法并执行。</span></span><br></pre></td></tr></table></figure>



<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合，如下示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,period,price</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.period=period</span><br><span class="line">        self.price=price</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s %s %s&gt;&#x27;</span> %(self.name,self.period,self.price))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,year,mon,day</span>):</span></span><br><span class="line">        self.year=year</span><br><span class="line">        self.mon=mon</span><br><span class="line">        self.day=day</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_birth</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s-%s-%s&gt;&#x27;</span> %(self.year,self.mon,self.day))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"><span class="comment">#Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">People</span>):</span> <span class="comment">#老师是人</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age,title,year,mon,day</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age,sex)</span><br><span class="line">        self.birth=Date(year,mon,day) <span class="comment">#老师有生日</span></span><br><span class="line">        self.courses=[] <span class="comment">#老师有课程，可以在实例化后，往该列表中添加Course类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python=Course(<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;3mons&#x27;</span>,<span class="number">3000.0</span>)</span><br><span class="line">linux=Course(<span class="string">&#x27;linux&#x27;</span>,<span class="string">&#x27;5mons&#x27;</span>,<span class="number">5000.0</span>)</span><br><span class="line">teacher1=Teacher(<span class="string">&#x27;lili&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;博士生导师&#x27;</span>,<span class="number">1990</span>,<span class="number">3</span>,<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># teacher1有两门课程</span></span><br><span class="line">teacher1.courses.append(python)</span><br><span class="line">teacher1.courses.append(linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重用Date类的功能</span></span><br><span class="line">teacher1.birth.tell_birth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重用Course类的功能</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> teacher1.courses: </span><br><span class="line">    obj.tell_info()</span><br></pre></td></tr></table></figure>

<p>此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总结:</span><br><span class="line">	继承表达是is-a关系</span><br><span class="line">	组合表达是has-a关系: 一个对象拥有一个属性，该属性值指向另外一个对象</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/18/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/18/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">基本数据类型及内置方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-18 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-18T17:27:55+08:00">2018-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本数据类型及内置方法"><a href="#基本数据类型及内置方法" class="headerlink" title="基本数据类型及内置方法"></a>基本数据类型及内置方法</h1><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>​         数据类型是用来记录事物状态的，而事物的状态是不断变化的(如:一个人年龄的增长（操作int类型） ，单个人名的修改（操作str类型），学生列表中增加学生（操作list类型）等)，这意味着我们在开发程序时需要频繁对数据进行操作，为了提升我们的开发效率， python针对这些常用的操作，为每一种数据类型内置了一系列方法</p>
<h3 id="一-数字类型int与float"><a href="#一-数字类型int与float" class="headerlink" title="一. 数字类型int与float"></a>一. 数字类型int与float</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、定义：</span><br><span class="line">    <span class="number">1.1</span> 整型<span class="built_in">int</span>的定义</span><br><span class="line">        age=<span class="number">10</span>  <span class="comment"># 本质age = int(10)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">1.2</span> 浮点型<span class="built_in">float</span>的定义</span><br><span class="line">        salary=<span class="number">3000.3</span>  <span class="comment"># 本质salary=float(3000.3)</span></span><br><span class="line"></span><br><span class="line">    注意：名字+括号的意思就是调用某个功能，比如:</span><br><span class="line">        <span class="built_in">print</span>(...)调用打印功能</span><br><span class="line">        <span class="built_in">int</span>(...)调用创建整型数据的功能</span><br><span class="line">        <span class="built_in">float</span>(...)调用创建浮点型数据的功能</span><br><span class="line"><span class="number">2.</span>类型转换:</span><br><span class="line">    <span class="number">1.</span><span class="built_in">int</span>可以将由纯整数构成的字符串直接转换成整型，若包含其他任意非整数符号，则会报错</span><br><span class="line">        s = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">        res = <span class="built_in">int</span>(s)</span><br><span class="line">        <span class="built_in">print</span>(res,<span class="built_in">type</span>(res))</span><br><span class="line">        ==&gt; (<span class="number">123</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;)</span></span><br><span class="line"><span class="class">    2.进制转换</span></span><br><span class="line"><span class="class">    	1.十进制转其他进制:</span></span><br><span class="line">            <span class="built_in">bin</span>(<span class="number">3</span>)  <span class="comment"># 转换成二进制</span></span><br><span class="line">            ==&gt; <span class="string">&#x27;0b11&#x27;</span></span><br><span class="line">            <span class="built_in">oct</span>(<span class="number">9</span>)  <span class="comment"># 转换成八进制</span></span><br><span class="line">            ==&gt; <span class="string">&#x27;0o11&#x27;</span></span><br><span class="line">            <span class="built_in">hex</span>(<span class="number">17</span>) <span class="comment"># 转换成十六进制</span></span><br><span class="line">            ==&gt; <span class="string">&#x27;0x11&#x27;</span></span><br><span class="line">        <span class="number">2.</span>其他进制转十进制</span><br><span class="line">            <span class="built_in">int</span>(<span class="string">&#x27;0b11&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">            ==&gt;  <span class="number">3</span></span><br><span class="line">            <span class="built_in">int</span>(<span class="string">&#x27;0o11&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">            ==&gt;  <span class="number">9</span></span><br><span class="line">            <span class="built_in">int</span>(<span class="string">&#x27;0x11&#x27;</span>,<span class="number">16</span>)</span><br><span class="line">            ==&gt;  <span class="number">17</span></span><br><span class="line">         <span class="number">3.1</span><span class="number">.3</span> <span class="built_in">float</span>同样可以用来做数据类型的转换</span><br><span class="line">            s = <span class="string">&#x27;12.3&#x27;</span></span><br><span class="line">            res=<span class="built_in">float</span>(s)</span><br><span class="line">            res,<span class="built_in">type</span>(res)</span><br><span class="line">            ==&gt;  (<span class="number">12.3</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">float</span>&#x27;&gt;)</span></span><br><span class="line"><span class="class">            </span></span><br><span class="line"><span class="class">3.使用</span></span><br><span class="line"><span class="class">	数字类型主要就是用来做数学运算与比较运算，因此数字类型除了与运算符结合使用之外，并无需要掌握的内置方法</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">总结：</span></span><br><span class="line"><span class="class">	存一个值，不可变类型</span></span><br></pre></td></tr></table></figure>

<h3 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二.字符串"></a>二.字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义:</span><br><span class="line">    在单引号<span class="keyword">or</span>双引号<span class="keyword">or</span>三引号内包含一串字符</span><br><span class="line">        name1 = <span class="string">&#x27;jason&#x27;</span>  <span class="comment"># 本质:name = str(&#x27;任意形式内容&#x27;)</span></span><br><span class="line">        name2 = <span class="string">&quot;lili&quot;</span>  <span class="comment"># 本质:name = str(&quot;任意形式内容&quot;)</span></span><br><span class="line">        name3 = <span class="string">&quot;&quot;&quot;ricky&quot;&quot;&quot;</span>  <span class="comment"># 本质:name = str(&quot;&quot;&quot;任意形式内容&quot;&quot;&quot;)    </span></span><br><span class="line"><span class="number">2.</span>类型转换:</span><br><span class="line">    <span class="built_in">str</span>()可以将任意数据类型转换成字符串类型，例如:</span><br><span class="line">        <span class="built_in">type</span>(<span class="built_in">str</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment"># list-&gt;str</span></span><br><span class="line">        ==&gt;  &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">        <span class="title">type</span>(<span class="params"><span class="built_in">str</span>(<span class="params">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span>)</span>) # <span class="title">dict</span>-&gt;<span class="built_in">str</span></span></span><br><span class="line"><span class="class">        ==&gt;  &lt;<span class="keyword">class</span> &#x27;<span class="built_in">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">        <span class="built_in">type</span>(<span class="built_in">str</span>((1,2,3)))  # <span class="built_in">tuple</span>-&gt;<span class="built_in">str</span></span></span><br><span class="line"><span class="class">        ==&gt; &lt;<span class="keyword">class</span> &#x27;<span class="built_in">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">        <span class="built_in">type</span>(<span class="built_in">str</span>(&#123;1,2,3,4&#125;)) # <span class="built_in">set</span>-&gt;<span class="built_in">str</span></span></span><br><span class="line"><span class="class">        ==&gt; &lt;<span class="keyword">class</span> &#x27;<span class="built_in">str</span>&#x27;&gt;   </span></span><br><span class="line"><span class="class">3.使用:</span></span><br><span class="line">    <span class="number">1.</span>优先掌握:</span><br><span class="line">        str1 = <span class="string">&#x27;hello python!&#x27;</span>      </span><br><span class="line">        <span class="number">1.</span>按索引取值(正向取，反向取)：</span><br><span class="line">			<span class="number">1.1</span> 正向取(从左往右)</span><br><span class="line">				str1[<span class="number">6</span>]</span><br><span class="line">				==&gt; p</span><br><span class="line">            <span class="number">1.2</span> 反向取(负号表示从右往左)：</span><br><span class="line">                str1[-<span class="number">4</span>]</span><br><span class="line">                ==&gt; h</span><br><span class="line">            <span class="number">1.3</span> 对于<span class="built_in">str</span>来说，只能按照索引取值，不能改</span><br><span class="line">            	str1[<span class="number">0</span>]=<span class="string">&#x27;H&#x27;</span> <span class="comment"># 报错TypeError</span></span><br><span class="line">        <span class="number">2.</span>切片：</span><br><span class="line">        	切片(顾头不顾尾，步长)</span><br><span class="line">            <span class="number">2.1</span> 顾头不顾尾：取出索引为<span class="number">0</span>到<span class="number">8</span>的所有字符</span><br><span class="line">                str1[<span class="number">0</span>:<span class="number">9</span>]  </span><br><span class="line">                ==&gt; hello pyt</span><br><span class="line">            <span class="number">2.2</span> 步长：<span class="number">0</span>:<span class="number">9</span>:<span class="number">2</span>,第三个参数<span class="number">2</span>代表步长，会从<span class="number">0</span>开始，每次累加一个<span class="number">2</span>即可，所以会取出索引<span class="number">0</span>、<span class="number">2</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">8</span>的字符</span><br><span class="line">                str1[<span class="number">0</span>:<span class="number">9</span>:<span class="number">2</span>]  </span><br><span class="line">                ==&gt; hlopt </span><br><span class="line">            <span class="number">2.3</span> 反向切片</span><br><span class="line">                str1[::-<span class="number">1</span>]  <span class="comment"># -1表示从右往左依次取值</span></span><br><span class="line">                ==&gt;!nohtyp olleh</span><br><span class="line">         <span class="number">3.</span>长度<span class="built_in">len</span></span><br><span class="line">            <span class="number">1.1</span> 获取字符串的长度，即字符的个数，但凡存在于引号内的都算作字符)</span><br><span class="line">            	<span class="built_in">len</span>(str1) <span class="comment"># 空格也算字符</span></span><br><span class="line">            	==&gt; <span class="number">13</span></span><br><span class="line">         <span class="number">4.</span>成员运算 <span class="keyword">in</span> 和 <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">        	<span class="number">4.1</span> <span class="built_in">int</span>:判断是否在</span><br><span class="line">            <span class="number">4.2</span> <span class="keyword">not</span> <span class="keyword">in</span>:判断是否不在</span><br><span class="line">		 <span class="number">5.5</span>strip移除字符串首尾指定的字符(默认移除空格)</span><br><span class="line">            <span class="number">5.1</span> 括号内不指定字符，默认移除首尾空白字符(空格、\n、\t)</span><br><span class="line">                str1 = <span class="string">&#x27;  life is short!  &#x27;</span></span><br><span class="line">                str1.strip()  </span><br><span class="line">                ==&gt; life <span class="keyword">is</span> short!</span><br><span class="line">            <span class="number">5.2</span> 括号内指定字符，移除首尾指定的字符</span><br><span class="line">            	str2 = <span class="string">&#x27;**tony**&#x27;</span>  </span><br><span class="line">            	str2.strip(<span class="string">&#x27;*&#x27;</span>)  </span><br><span class="line">            	==&gt; tony</span><br><span class="line">         <span class="number">6.</span>切分split</span><br><span class="line">            <span class="number">6.1</span>括号内不指定字符，默认以空格作为切分符号</span><br><span class="line">                str3=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">                str3.split()</span><br><span class="line">                ==&gt; [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line">            <span class="number">6.2</span>括号内指定分隔字符，则按照括号内指定的字符切割字符串</span><br><span class="line">                str4 = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">                str4.split(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">                ==&gt; [<span class="string">&#x27;127&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]  <span class="comment"># 注意:split切割得到的结果是列表数据类型</span></span><br><span class="line">                </span><br><span class="line">	<span class="number">2.</span>需要掌握：</span><br><span class="line">    	<span class="number">1.</span>strip, lstrip, rstrip</span><br><span class="line">         	str1 = <span class="string">&#x27;**tony***&#x27;</span></span><br><span class="line">        	str1.strip(<span class="string">&#x27;*&#x27;</span>)   <span class="comment"># 移除左右两边的指定字符</span></span><br><span class="line">            str1.lstrip(<span class="string">&#x27;*&#x27;</span>)  <span class="comment"># 只移除左边的指定字符</span></span><br><span class="line">            str1.lstrip(<span class="string">&#x27;*&#x27;</span>)  <span class="comment"># 只移除左边的指定字符</span></span><br><span class="line">        <span class="number">2.</span>lower(),upper()</span><br><span class="line">        	<span class="number">2.1</span> lower用来小写字符串中的所有字符</span><br><span class="line">			<span class="number">2.2</span> upper用来大写字符串中的所有字符</span><br><span class="line">        <span class="number">3.</span> startswith,endswith</span><br><span class="line">        	<span class="number">3.1</span> startswith用来判断字符串中首写字符</span><br><span class="line">			<span class="number">3.2</span> endswith用来判断字符串中末尾的字符</span><br><span class="line">        <span class="number">4.</span> 格式化输出之<span class="built_in">format</span></span><br><span class="line">        	<span class="built_in">format</span>是一种不依赖位置的传值方式</span><br><span class="line">            <span class="built_in">format</span>用来自定义字符串中的字符，用花括号占位</span><br><span class="line">            <span class="built_in">format</span>括号内在传参数时完全可以打乱顺序，但仍然能指名道姓地为指定的参数传值，name=‘tony’就			 是传给&#123;name&#125;,例：</span><br><span class="line">                str4 = <span class="string">&#x27;my name is &#123;name&#125;, my age is &#123;age&#125;!&#x27;</span>.<span class="built_in">format</span>(age=<span class="number">18</span>,name=<span class="string">&#x27;tony&#x27;</span>)</span><br><span class="line">                str4  </span><br><span class="line">                ==&gt;<span class="string">&#x27;my name is tony, my age is 18!&#x27;</span></span><br><span class="line"></span><br><span class="line">                str4 = <span class="string">&#x27;my name is &#123;name&#125;&#123;name&#125;, my age is &#123;name&#125;!&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;tony&#x27;</span>, 				age=<span class="number">18</span>)</span><br><span class="line">                str4  </span><br><span class="line">                <span class="string">&#x27;my name is tonytony, my age is tony!&#x27;</span></span><br><span class="line">          <span class="number">5.</span>split,rsplit  </span><br><span class="line">        		<span class="number">5.1</span>split将长字符串切割，切割位置取决于括号内字符，默认空格，从左往右，可指定切割次数</span><br><span class="line">				<span class="number">5.2</span>rsplit将长字符串切割，切割位置取决于括号内字符，默认空格，从右往左，可指定切割次数</span><br><span class="line">					split会按照从左到右的顺序对字符串进行切分，可以指定切割次数</span><br><span class="line">                        str5=<span class="string">&#x27;C:/a/b/c/d.txt&#x27;</span></span><br><span class="line">                        str5.split(<span class="string">&#x27;/&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">                        ==&gt; [<span class="string">&#x27;C:&#x27;</span>, <span class="string">&#x27;a/b/c/d.txt&#x27;</span>] </span><br><span class="line"></span><br><span class="line">          <span class="number">6.j</span>oin</span><br><span class="line">        	  从可迭代对象中取出多个字符串，然后按照指定的分隔符进行拼接,拼接的结果为字符串</span><br><span class="line">          <span class="number">7.</span>replace</span><br><span class="line">        	  用来替换字符串中的不想要内容，需重新赋值定义，可指定个数</span><br><span class="line">          <span class="number">8.</span>isdigit</span><br><span class="line">        	  判断字符串是否是纯数字组成</span><br><span class="line">          <span class="number">9.</span><span class="keyword">is</span>系列</span><br><span class="line">        	  <span class="number">9.1</span> isalnum()  <span class="comment"># 字符串中既可以包含数字也可以包含字母</span></span><br><span class="line">        	  <span class="number">9.2</span> isalpha()  <span class="comment"># 字符串中只包含字母</span></span><br><span class="line">              <span class="number">9.3</span> isspace()  <span class="comment"># 字符串是否全是空格</span></span><br><span class="line">           	  <span class="number">9.4</span> istitle()  <span class="comment"># 字符串中的单词首字母是否都是大写</span></span><br><span class="line">          <span class="number">10.</span>其他</span><br><span class="line">              captalize		<span class="comment"># 首字母大写</span></span><br><span class="line">              swapcase		<span class="comment"># 大小写翻转</span></span><br><span class="line">              title			<span class="comment"># 每个单词的首字母大写</span></span><br><span class="line">              isalpha() 	<span class="comment"># 字符串中只包含字母</span></span><br><span class="line">              isalnum() 	<span class="comment"># 字符串中既可以包含数字也可以包含字母</span></span><br><span class="line">              isspace()  	<span class="comment"># 字符串是否全是空格</span></span><br><span class="line">              <span class="built_in">isinstance</span>() 	<span class="comment"># 函数来判断一个对象是否是一个已知的类型</span></span><br><span class="line">              count()		<span class="comment"># 统计字符串在大字符串中出现的次数</span></span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">	存一个值，有序，不可变类型</span><br></pre></td></tr></table></figure>

<h3 id="三-列表"><a href="#三-列表" class="headerlink" title="三.列表"></a>三.列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义：</span><br><span class="line">	定义：在[]内,用逗号分隔开多个任意数据类型的值</span><br><span class="line"><span class="number">2.</span>类型转换：</span><br><span class="line">	但凡能被<span class="keyword">for</span>循环遍历的数据类型都可以传给<span class="built_in">list</span>()转换成列表类型，<span class="built_in">list</span>()会跟<span class="keyword">for</span>循环一样遍历出数据类型中	  包含的每一个元素然后放到列表中</span><br><span class="line">        <span class="built_in">list</span>(<span class="string">&#x27;wdad&#x27;</span>) <span class="comment"># 结果：[&#x27;w&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;] </span></span><br><span class="line">        <span class="built_in">list</span>(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;) <span class="comment">#结果：[&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line">        <span class="built_in">list</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 结果：[1, 2, 3] </span></span><br><span class="line">        <span class="built_in">list</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) <span class="comment"># 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="number">3.</span>使用：</span><br><span class="line">	<span class="number">1.</span>优先掌握：</span><br><span class="line">        <span class="number">1.</span> 按索引存取值(正向存取+反向存取)：即可存也可以取  </span><br><span class="line">    		<span class="number">1.1</span> 正向取(从左往右)</span><br><span class="line">            <span class="number">1.2</span> 反向取(负号表示从右往左)</span><br><span class="line">            <span class="number">1.3</span> <span class="built_in">list</span>既可以按照索引取值，又可以按照索引修改指定位置的值，但如果索引不存在则报错</span><br><span class="line">    	<span class="number">2.</span>切片(顾头不顾尾，步长)</span><br><span class="line">        	<span class="number">2.1</span> 顾头不顾尾</span><br><span class="line">            <span class="number">2.2</span> 步长</span><br><span class="line">        <span class="number">3.</span>长度</span><br><span class="line">        	<span class="built_in">len</span>(列表)</span><br><span class="line">        <span class="number">4.</span>成员运算<span class="keyword">in</span>和<span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">        <span class="number">5.</span>添加</span><br><span class="line">        	<span class="number">5.1</span> append()列表尾部追加元素</span><br><span class="line">            <span class="number">5.2</span> insert用来向列表内添加新的值，根据列表索引添加新值，新值会被加到指定索引位置</span><br><span class="line">        	<span class="number">5.3</span> extend用来将被添加到新列表中所有元素拆分开来一一加入新的列表</span><br><span class="line">        <span class="number">6.</span>删除</span><br><span class="line">        	<span class="number">6.1</span> <span class="keyword">del</span>用来删除列表里索引对应的值，是单纯的删除，没有返回值</span><br><span class="line">            <span class="number">6.2</span> pop()默认删除列表最后一个元素，并将删除的值返回，括号内可以通过加索引值来指定删除元素</span><br><span class="line">        	<span class="number">6.3</span> remove()括号内指名道姓表示要删除哪个元素，没有返回值</span><br><span class="line">            <span class="number">6.4</span> clear用来清空列表中所有元素</span><br><span class="line">        <span class="number">7.</span>排序 </span><br><span class="line">        	<span class="number">7.1</span> reverse用来将列表倒置，顺序颠倒过来</span><br><span class="line">            <span class="number">7.2</span> sort用来将列表中元素排序，默认从小到大排，括号里跟reverse=<span class="literal">True</span>实现从大到小排序</span><br><span class="line">        <span class="number">8.</span>查找</span><br><span class="line">        	<span class="number">8.1</span> index用来根据值查找值对应列表中的索引，值后面可指定索引范围来查找</span><br><span class="line">        	<span class="number">8.2</span> count用来查询列表中某个值出现的次数</span><br><span class="line">        <span class="number">9.</span>复制 	</span><br><span class="line">			copy用来将列表复制一份，可定义给其他列表(浅拷贝)</span><br><span class="line"> </span><br><span class="line">总结：</span><br><span class="line">	存多个值，有序，可变类型</span><br></pre></td></tr></table></figure>

<h3 id="四-元组"><a href="#四-元组" class="headerlink" title="四.元组"></a>四.元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>作用：</span><br><span class="line">	元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取</span><br><span class="line"><span class="number">2.</span>定义：</span><br><span class="line">	在()内用逗号分隔开多个任意类型的值</span><br><span class="line">    强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组</span><br><span class="line"><span class="number">3.</span>类型转换：</span><br><span class="line">	但凡能被<span class="keyword">for</span>循环的遍历的数据类型都可以传给<span class="built_in">tuple</span>()转换成元组类型</span><br><span class="line">    	 <span class="built_in">tuple</span>(<span class="string">&#x27;wdad&#x27;</span>) <span class="comment"># 结果：(&#x27;w&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;) </span></span><br><span class="line">         <span class="built_in">tuple</span>(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;) <span class="comment"># 结果：(&#x27;name&#x27;, &#x27;age&#x27;)</span></span><br><span class="line">         <span class="built_in">tuple</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) <span class="comment"># 结果：(1, 2, 3, 4)</span></span><br><span class="line"><span class="number">4.</span>使用：</span><br><span class="line">	<span class="number">4.1</span> 按索引取值(正向取+反向取)：只能取，不能改否则报错！  </span><br><span class="line">    <span class="number">4.2</span> 切片(顾头不顾尾，步长)</span><br><span class="line">    <span class="number">4.3</span> 长度：<span class="built_in">len</span>(元组)</span><br><span class="line">    <span class="number">4.4</span> 成员运算 <span class="keyword">in</span> 和 <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">    <span class="number">4.5</span> <span class="number">5</span>、循环</span><br><span class="line">    </span><br><span class="line">总结：</span><br><span class="line">	存多个值，有序，不可变</span><br></pre></td></tr></table></figure>

<h3 id="五-字典"><a href="#五-字典" class="headerlink" title="五.字典"></a>五.字典</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.定义：</span><br><span class="line">	在&#123;&#125;内用逗号分隔开多元素，每一个元素都是key:value的形式，其中value可以是任意类型，而key则必须是不可变类型，通常key应该是str类型，因为str类型会对value有描述性的功能</span><br><span class="line">2.类型转换：</span><br><span class="line">	转换一：</span><br><span class="line">        info=dict([[&#x27;name&#x27;,&#x27;tony&#x27;],(&#x27;age&#x27;,18)])</span><br><span class="line">        print(info)</span><br><span class="line">        ==&gt; &#123;&#x27;age&#x27;: 18, &#x27;name&#x27;: &#x27;tony&#x27;&#125;</span><br><span class="line">	转换二：</span><br><span class="line">		fromkeys会从元组中取出每个值当做key，然后与None组成key:value放到字典中</span><br><span class="line">            &#123;&#125;.fromkeys((&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;),None)  </span><br><span class="line">            ==&gt;&#123;&#x27;age&#x27;: None, &#x27;sex&#x27;: None, &#x27;name&#x27;: None&#125;</span><br><span class="line">3.使用：</span><br><span class="line">	3.1 keys():字典类型和keys连用，</span><br><span class="line">	3.2 values():字典类型和values连用，是只遍历value值的意思</span><br><span class="line">	3.3 items():字典类型和items连用，是遍历key和value值的意思，即遍历键值对，用元组盛放返回</span><br><span class="line">	3.4 get是用来根据key值获取其对应的value值，有返回值，key不存在返回None，字典取值推荐使用此方法</span><br><span class="line">	3.5 pop是用来删除字典指定key对应的键值，返回值是被删除的键值</span><br><span class="line">	3.6 popitem是用来随机删除字典内的一组键值对，并将删除的键值对放入元组内返回</span><br><span class="line">	3.7 update是用新字典更新旧字典，有则修改，无则添加</span><br><span class="line">	3.8 fromkeys是用来快速生成一个新的字典，可以自定义key对应的value值</span><br><span class="line">	3.9.setdefault是用来获取字典的信息，若key不存在，就加上括号内的键值对项目,存在则字典保持不变</span><br><span class="line">	</span><br><span class="line">总结:</span><br><span class="line">	存多个值,无序,可变</span><br></pre></td></tr></table></figure>

<h3 id="六-集合"><a href="#六-集合" class="headerlink" title="六.集合"></a>六.集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>作用：</span><br><span class="line">	集合、<span class="built_in">list</span>、<span class="built_in">tuple</span>、<span class="built_in">dict</span>一样都可以存放多个值，但是集合主要用于：去重、关系运算</span><br><span class="line"><span class="number">2.</span>定义</span><br><span class="line">	在&#123;&#125;内用逗号分隔开多个元素，集合具备以下三个特点：</span><br><span class="line">         <span class="number">1</span>：每个元素必须是不可变类型</span><br><span class="line">         <span class="number">2</span>：集合内没有重复的元素</span><br><span class="line">         <span class="number">3</span>：集合内元素无序</span><br><span class="line">     s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;  <span class="comment"># 本质 s = set(&#123;1,2,3,4&#125;)</span></span><br><span class="line">     d = &#123;&#125; <span class="comment"># 默认是空字典 </span></span><br><span class="line">	 s = <span class="built_in">set</span>() <span class="comment"># 这才是定义空集合</span></span><br><span class="line"><span class="number">3.</span>类型转：</span><br><span class="line">	但凡能被<span class="keyword">for</span>循环的遍历的数据类型（强调：遍历出的每一个值都必须为不可变类型）都可以传给<span class="built_in">set</span>()转换成集合类型</span><br><span class="line">        s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">        s1 = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">        s2 = <span class="built_in">set</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,&#125;)</span><br><span class="line">        s3 = <span class="built_in">set</span>(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(s,s1,s2,s3)</span><br><span class="line">        ==&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;<span class="string">&#x27;name&#x27;</span>&#125; &#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;		</span><br><span class="line"><span class="number">4.</span>使用:</span><br><span class="line">    <span class="number">4.1</span>关系运算：</span><br><span class="line">    	<span class="number">1.</span>合集/并集(|)：所有的</span><br><span class="line">        <span class="number">2.</span>交集(&amp;)：共有的</span><br><span class="line">        <span class="number">3.</span>差集(-)：各自独有的</span><br><span class="line">        <span class="number">4.</span>对称差集(^) ：两者独有的</span><br><span class="line">        <span class="number">5.</span>值是否相等(==)</span><br><span class="line">        <span class="number">6.</span>父集：一个集合是否包含另外一个集合</span><br><span class="line">        	<span class="number">6.1</span>包含则返回<span class="literal">True</span></span><br><span class="line">            <span class="number">6.2</span>不存在包含关系，则返回<span class="literal">False</span></span><br><span class="line">    	<span class="number">7.</span>子集</span><br><span class="line">     <span class="number">4.2</span>去重：</span><br><span class="line">    	集合去重复有局限性</span><br><span class="line">            <span class="number">1.</span> 只能针对不可变类型</span><br><span class="line">            <span class="number">2.</span> 集合本身是无序的，去重之后无法保留原来的顺序</span><br><span class="line">            </span><br><span class="line">总结:</span><br><span class="line">    存多个值,无序,<span class="built_in">set</span>集合可变,<span class="built_in">frozenset</span>不可变集合</span><br></pre></td></tr></table></figure>

<h3 id="七-可变类型与不可变类型"><a href="#七-可变类型与不可变类型" class="headerlink" title="七.可变类型与不可变类型"></a>七.可变类型与不可变类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.可变类型：</span><br><span class="line">	值发生改变时，内存地址不变，即id不变，证明在改变原值</span><br><span class="line">2.不可变类型：</span><br><span class="line">	值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值</span><br></pre></td></tr></table></figure>

<h3 id="八-数据类型总结"><a href="#八-数据类型总结" class="headerlink" title="八.数据类型总结"></a>八.数据类型总结</h3><p><img src="https://pic4.zhimg.com/80/v2-de70fc0b51f69ade62df5cc235acd493_720w.jpg" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/18/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/18/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">Python迭代器生成器函数递归</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-18 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-18T17:27:55+08:00">2018-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Python迭代器生成器函数递归"><a href="#Python迭代器生成器函数递归" class="headerlink" title="Python迭代器生成器函数递归"></a>Python迭代器生成器函数递归</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="一-迭代器介绍"><a href="#一-迭代器介绍" class="headerlink" title="一 .迭代器介绍"></a>一 .迭代器介绍</h3><h4 id="1-1什么是迭代器"><a href="#1-1什么是迭代器" class="headerlink" title="1.1什么是迭代器"></a>1.1什么是迭代器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是迭代器?</span><br><span class="line">	迭代器迭代取值的工具，什么是迭代？？？</span><br><span class="line">        迭代是一个重复的过程，但是每次重复都是基于上一次的结果而来</span><br><span class="line"><span class="number">2.</span>为何要用迭代器?</span><br><span class="line">	优点:</span><br><span class="line">        为了找到一种新的、统一的取值方式（可以不依赖于索引以及key的）</span><br><span class="line">        惰性计算，不耗费内存</span><br><span class="line">    缺点:</span><br><span class="line">        取值不够灵活</span><br><span class="line">        一次性的，只能往后取，无法预知数据的个数</span><br><span class="line"><span class="number">3</span>、如何用迭代器?</span><br><span class="line">    <span class="number">3.1</span> 可迭代的对象iterable</span><br><span class="line">        <span class="number">1</span>、内置有__iter__方法</span><br><span class="line">    <span class="number">3.2</span> 迭代器对象iterator</span><br><span class="line">        <span class="number">1</span>、内置有__iter__方法</span><br><span class="line">        <span class="number">2</span>、内置有__next__方法</span><br><span class="line"></span><br><span class="line">    调用: 可迭代对象.__iter__() --&gt; 返回迭代器对象</span><br><span class="line">    调用：迭代器对象.__next__() --&gt; 返回的是下一个值</span><br></pre></td></tr></table></figure>

<h4 id="1-2-可迭代对象"><a href="#1-2-可迭代对象" class="headerlink" title="1.2 可迭代对象"></a>1.2 可迭代对象</h4><p>通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。</p>
<p>要想了解迭代器为何物，必须事先搞清楚一个很重要的概念：可迭代对象(Iterable)。从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;.__iter__</span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;.__iter__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h4 id="1-2-迭代器对象"><a href="#1-2-迭代器对象" class="headerlink" title="1.2 迭代器对象"></a>1.2 迭代器对象</h4><p>调用obj.<strong>iter</strong>()方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有<strong>iter</strong>和<strong>next</strong>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<strong>iter</strong>()方法得到的仍然是迭代器本身，而执行迭代器.<strong>next</strong>()方法就会计算出迭代器中的下一个值。 迭代器是Python提供的一种统一的、不依赖于索引的迭代取值方式，只要存在多个“值”，无论序列类型还是非序列类型都可以按照迭代器的方式取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment"># 可迭代对象s</span></span><br><span class="line">i=<span class="built_in">iter</span>(s)  <span class="comment"># 本质就是在调用s.__iter__(),返回s的迭代器对象i，</span></span><br><span class="line"><span class="built_in">next</span>(i) <span class="comment"># 本质就是在调用i.__next__()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">next</span>(i)  <span class="comment">#抛出StopIteration的异常，代表无值可取，迭代结束</span></span><br></pre></td></tr></table></figure>

<h3 id="二-for循环原理"><a href="#二-for循环原理" class="headerlink" title="二. for循环原理"></a>二. for循环原理</h3><p>有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line">i=<span class="built_in">iter</span>(goods) <span class="comment">#每次都需要重新获取一个迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment">#捕捉异常终止循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> goods:   </span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<p>for 循环在工作时，首先会调用可迭代对象goods内置的<strong>iter</strong>方法拿到一个迭代器对象，然后再调用该迭代器对象的<strong>next</strong>方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="一-生成器与yield"><a href="#一-生成器与yield" class="headerlink" title="一. 生成器与yield"></a>一. 生成器与yield</h3><p>若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line">     <span class="keyword">while</span> start &lt; stop:</span><br><span class="line">         <span class="keyword">yield</span> start</span><br><span class="line">         start+=step</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">g=my_range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">&lt;generator <span class="built_in">object</span> my_range at <span class="number">0x104105678</span>&gt;</span><br></pre></td></tr></table></figure>

<p>生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(g.__iter__)</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__iter__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;<span class="built_in">print</span></span><br><span class="line"><span class="built_in">print</span>(g.__next__)</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__next__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>因而我们可以用next(生成器)触发生成器所对应函数的执行，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数</span></span><br><span class="line">start...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 周而复始...</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代</span></span><br><span class="line">end...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>既然生成器对象属于迭代器，那么必然可以使用for循环迭代，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> countdown(<span class="number">3</span>):</span><br><span class="line">     <span class="built_in">print</span>(i)</span><br><span class="line"> </span><br><span class="line">countdown start</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<p>有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值</p>
<h3 id="二-yield表达式应用"><a href="#二-yield表达式应用" class="headerlink" title="二 yield表达式应用"></a>二 yield表达式应用</h3><p>在函数内可以采用表达式形式的yield</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         food=<span class="keyword">yield</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure>

<p>可以拿到函数的生成器对象持续为函数体send值，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g=eater() <span class="comment"># 得到生成器对象</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">&lt;generator <span class="built_in">object</span> eater at <span class="number">0x101b6e2b0</span>&gt;</span><br><span class="line"><span class="built_in">next</span>(e) <span class="comment"># 需要事先”初始化”一次，让函数挂起在food=yield，等待调用g.send()方法为其传值</span></span><br><span class="line">Ready to eat</span><br><span class="line">g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line">==&gt; get the food: 包子, <span class="keyword">and</span> start to eat</span><br><span class="line">g.send(<span class="string">&#x27;鸡腿&#x27;</span>)</span><br><span class="line">==&gt; get the food: 鸡腿, <span class="keyword">and</span> start to eat</span><br></pre></td></tr></table></figure>

<p>针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food=yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)。</p>
<p>我们可以编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure>

<p>表达式形式的yield也可以用于返回多次值，即<code>变量名=yield 值</code>的形式，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">     food_list=[]</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         food=<span class="keyword">yield</span> food_list</span><br><span class="line">         food_list.append(food)</span><br><span class="line"> </span><br><span class="line">e=eater()</span><br><span class="line"><span class="built_in">next</span>(e)</span><br><span class="line">==&gt; Ready to eat</span><br><span class="line">[]</span><br><span class="line">e.send(<span class="string">&#x27;蒸羊羔&#x27;</span>)</span><br><span class="line">==&gt; [<span class="string">&#x27;蒸羊羔&#x27;</span>]</span><br><span class="line">e.send(<span class="string">&#x27;蒸熊掌&#x27;</span>)</span><br><span class="line">==&gt; [<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>]</span><br><span class="line">e.send(<span class="string">&#x27;蒸鹿尾儿&#x27;</span>)</span><br><span class="line">==&gt; [<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>, <span class="string">&#x27;蒸鹿尾儿&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="三-三元表达式、列表生成式、生成器表达式"><a href="#三-三元表达式、列表生成式、生成器表达式" class="headerlink" title="三. 三元表达式、列表生成式、生成器表达式"></a>三. 三元表达式、列表生成式、生成器表达式</h3><h4 id="3-1-三元表达式"><a href="#3-1-三元表达式" class="headerlink" title="3.1 三元表达式"></a>3.1 三元表达式</h4><p>三元表达式是python为我们提供的一种简化代码的解决方案，语法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = 条件成立时返回的值 <span class="keyword">if</span> 条件 <span class="keyword">else</span> 条件不成立时返回的值</span><br></pre></td></tr></table></figure>

<p>针对下述场景</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>用三元表达式可以一行解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line">y=<span class="number">2</span></span><br><span class="line">res = x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y <span class="comment"># 三元表达式</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-列表生成式"><a href="#3-2-列表生成式" class="headerlink" title="3.2 列表生成式"></a>3.2 列表生成式</h4><p>列表生成式是python为我们提供的一种简化代码的解决方案，用来快速生成列表，语法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#类似于</span></span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">            <span class="keyword">if</span> condition2</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN:</span><br><span class="line">                    <span class="keyword">if</span> conditionN:</span><br><span class="line">                        res.append(expression)</span><br></pre></td></tr></table></figure>

<p>针对下述场景</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">egg_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    egg_list.append(<span class="string">&#x27;鸡蛋%s&#x27;</span> %i)</span><br></pre></td></tr></table></figure>

<p>用列表生成式可以一行解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg_list=[<span class="string">&#x27;鸡蛋%s&#x27;</span> %i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="3-3-生成器表达式"><a href="#3-3-生成器表达式" class="headerlink" title="3.3 生成器表达式"></a>3.3 生成器表达式</h4><p>创建一个生成器对象有两种方式，一种是调用带yield关键字的函数，另一种就是生成器表达式，与列表生成式的语法格式相同，只需要将[]换成()，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition）</span><br></pre></td></tr></table></figure>

<p>对比列表生成式返回的是一个列表，生成器表达式返回的是一个生成器对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">==&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">g</span><br><span class="line">==&gt; &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101be0ba0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(g)</span><br><span class="line">==&gt; <span class="number">0</span></span><br><span class="line"><span class="built_in">next</span>(g)</span><br><span class="line">==&gt; <span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(g)</span><br><span class="line">==&gt; <span class="number">4</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment">#抛出异常StopIteration</span></span><br></pre></td></tr></table></figure>

<p>如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    nums=(<span class="built_in">len</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    total_size=<span class="built_in">sum</span>(nums) <span class="comment"># 依次执行next(nums)，然后累加到一起得到结果=</span></span><br></pre></td></tr></table></figure>

<h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><h3 id="一-函数递归调用介绍"><a href="#一-函数递归调用介绍" class="headerlink" title="一 .函数递归调用介绍"></a>一 .函数递归调用介绍</h3><p>函数不仅可以嵌套定义，还可以嵌套调用，即在调用一个函数的过程中，函数内部又调用另一个函数，而函数的递归调用指的是在调用一个函数的过程中又直接或间接地调用该函数本身</p>
<p>例如</p>
<p>在调用f1的过程中，又调用f1，这就是直接调用函数f1本身</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from f1&#x27;</span>)</span><br><span class="line">    f1()</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<p>在调用f1的过程中，又调用f2，而在调用f2的过程中又调用f1，这就是间接调用函数f1本身</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from f1&#x27;</span>)</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from f2&#x27;</span>)</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-3190338dfab02a5e59a1f6d099801667_720w.jpg" alt="img"></p>
<p>从上图可以看出，两种情况下的递归调用都是一个无限循环的过程，但在python对函数的递归调用的深度做了限制，因而并不会像大家所想的那样进入无限循环，会抛出异常，要避免出现这种情况，就必须让递归调用在满足某个特定条件下终止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">	<span class="number">1.</span>.可以使用sys.getrecursionlimit()去查看递归深度，默认值为<span class="number">1000</span>，虽然可以使用sys.setrecursionlimit()去设定该值，但仍受限于主机操作系统栈大小的限制</span><br><span class="line"></span><br><span class="line">	<span class="number">2.</span>python不是一门函数式编程语言，无法对递归进行尾递归优化。</span><br></pre></td></tr></table></figure>

<h3 id="二-回溯与递推"><a href="#二-回溯与递推" class="headerlink" title="二 .回溯与递推"></a>二 .回溯与递推</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个递归的过程应该分为两个阶段：</span><br><span class="line">	1、回溯：向下一层一层调用</span><br><span class="line">	2、递推：向上一层一层返回</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.函数的递归调用：</span><br><span class="line">	1.是函数嵌套调用的一种特殊形式</span><br><span class="line">	2.函数的递归调用其实就是用函数实现的循环具体指的是在调用一个函数的过程中又	    直接或者间接地调用自己，称之为函数的递归调用</span><br><span class="line">2.递归过程的两个阶段:</span><br><span class="line">    回溯:向下一层一层调用</span><br><span class="line">    递推:向上一层一层返回</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/16/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/16/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">Python常用模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-16 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-16T17:27:55+08:00">2018-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Python常用模块"><a href="#Python常用模块" class="headerlink" title="Python常用模块"></a>Python常用模块</h1><h3 id="使用模块注意"><a href="#使用模块注意" class="headerlink" title="使用模块注意:"></a>使用模块注意:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入带出模块时应该注意以下几点</span></span><br><span class="line">    <span class="number">1</span> 模块导入能不能找到，取决于路径是否在环境变量中</span><br><span class="line">    <span class="number">2</span> 如果包内部，推荐使用相对导入，也可以使用绝对导入</span><br><span class="line">    <span class="number">3</span> 如果py文件以脚本形式运行，必须使用绝对导入</span><br></pre></td></tr></table></figure>

<h3 id="一-time与datetime模块"><a href="#一-time与datetime模块" class="headerlink" title="一 .time与datetime模块"></a>一 .time与datetime模块</h3><p>在Python中，通常有这几种方式来表示时间：</p>
<ul>
<li>时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</li>
<li>格式化的时间字符串(Format String)</li>
<li>结构化的时间(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)</li>
</ul>
<p>其中计算机认识的时间只能是’时间戳’格式，而程序员可处理的或者说人类能看懂的时间有: ‘格式化的时间字符串’，’结构化的时间’ ，于是有了下图的转换关系</p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201702/1036857-20170215142700722-743334012.png" alt="img"></p>
<h4 id="1-time"><a href="#1-time" class="headerlink" title="1.time"></a>1.time</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">时间分为三种格式</span><br><span class="line">1、时间戳</span><br><span class="line">	print(time.time())</span><br><span class="line"></span><br><span class="line">2、格式化的字符</span><br><span class="line">	print(time.strftime(&#x27;%Y-%m-%d %H:%M:%S %p&#x27;))</span><br><span class="line"></span><br><span class="line">3、结构化的时间对象</span><br><span class="line">	obj = time.localtime()</span><br><span class="line">	print(obj.tm_year)</span><br><span class="line">	print(obj.tm_wday)</span><br></pre></td></tr></table></figure>

<h4 id="2-datetime"><a href="#2-datetime" class="headerlink" title="2.datetime"></a>2.datetime</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">时间加减</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># print(datetime.datetime.now()) #返回 2016-08-19 12:47:03.941925</span><br><span class="line">#print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2016-08-19</span><br><span class="line"># print(datetime.datetime.now() )</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># c_time  = datetime.datetime.now()</span><br><span class="line"># print(c_time.replace(minute=3,hour=2)) #时间替换</span><br></pre></td></tr></table></figure>

<h3 id="二-random模块"><a href="#二-random模块" class="headerlink" title="二 random模块"></a>二 random模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. import random </span><br><span class="line">2. print(random.random())#(0,1)----float    大于0且小于1之间的小数</span><br><span class="line">3. print(random.randint(1,3))  #[1,3]    大于等于1且小于等于3之间的整数</span><br><span class="line">4. print(random.randrange(1,3)) #[1,3)    大于等于1且小于3之间的整数 </span><br><span class="line">5. print(random.choice([1,&#x27;23&#x27;,[4,5]]))#1或者23或者[4,5]</span><br><span class="line">6. print(random.sample([1,&#x27;23&#x27;,[4,5]],2))#列表元素任意2个组合</span><br><span class="line">7. print(random.uniform(1,3))#大于1小于3的小数，如1.927109612082716  </span><br><span class="line">8. item=[1,3,5,7,9]</span><br><span class="line">9. random.shuffle(item) #打乱item的顺序,相当于&quot;洗牌&quot;</span><br><span class="line">10. print(item)</span><br><span class="line"></span><br><span class="line">chr(65)到chr(90)  对应  ASCII表中&#x27;A&#x27;到&#x27;Z&#x27;</span><br><span class="line">chr(97)到chr(122)  对应  ASCII表中&#x27;a&#x27;到&#x27;z&#x27;</span><br><span class="line"></span><br><span class="line">编写随机验证码:</span><br><span class="line">import random</span><br><span class="line">def make_code(size=6):</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    for i in range(size):</span><br><span class="line">        num = str(random.randint(0, 9))</span><br><span class="line">        alpha = chr(random.randint(65, 90))</span><br><span class="line">        res += random.choice([num, alpha])</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(make_code())</span><br></pre></td></tr></table></figure>

<h3 id="三-subprocess模块"><a href="#三-subprocess模块" class="headerlink" title="三.subprocess模块"></a>三.subprocess模块</h3><p><img src="C:\Users\左旗伟\Desktop\功能\其他\subprocess模块.jpg" alt="subprocess模块"></p>
<h3 id="四-hashlib模块"><a href="#四-hashlib模块" class="headerlink" title="四.hashlib模块"></a>四.hashlib模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">交给hash算法一串内容，hash算法会计算出一个值，该值称之为哈希值</span><br><span class="line">哈希值有三大特点:</span><br><span class="line">    特点1、只要采用hash算法一样，并且传入的内容一样，那么hash值一定一样</span><br><span class="line">    特点2、hash值的长度取决于算法，与传入内容的多少无关</span><br><span class="line">    特点3、hash值不可逆推</span><br><span class="line">哈希值两大用途:</span><br><span class="line">    1、文件内容完整性校验 = 特点1 + 特点2</span><br><span class="line">    2、加密 = 特点3</span><br><span class="line">加密:</span><br><span class="line">	import hashlib</span><br><span class="line"></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    m.update(&quot;天王盖地虎&quot;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    m.update(&quot;egon123&quot;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    m.update(&quot;小鸡炖蘑菇&quot;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">    print(m.hexdigest())</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\左旗伟\Desktop\功能\其他\md5密码加密.jpg" alt="md5密码加密"></p>
<p>python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">h1=hmac.new(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;),digestmod=&#x27;md5&#x27;)</span><br><span class="line">h1.update(&#x27;world&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">print(h1.hexdigest())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#要想保证hmac最终结果一致，必须保证：</span><br><span class="line">#1:hmac.new括号内指定的初始key一样</span><br><span class="line">#2:无论update多少次，校验的内容累加到一起是一样的内容</span><br><span class="line"></span><br><span class="line"># 操作一</span><br><span class="line">import hmac</span><br><span class="line">h1=hmac.new(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;),digestmod=&#x27;md5&#x27;)</span><br><span class="line">h1.update(&#x27;world&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b</span><br><span class="line"></span><br><span class="line"># 操作二</span><br><span class="line">import hmac</span><br><span class="line">h2=hmac.new(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;),digestmod=&#x27;md5&#x27;)</span><br><span class="line">h2.update(&#x27;w&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">h2.update(&#x27;orld&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b</span><br></pre></td></tr></table></figure>

<h3 id="五-logging模块"><a href="#五-logging模块" class="headerlink" title="五.logging模块"></a>五.logging模块</h3><p>定义:</p>
<p><img src="C:\Users\左旗伟\Desktop\功能\日志的使用\定义.png" alt="定义"></p>
<p>调用:</p>
<p><img src="C:\Users\左旗伟\Desktop\功能\日志的使用\1.png" alt="1"></p>
<p><img src="C:\Users\左旗伟\Desktop\功能\日志的使用\2.png" alt="2"></p>
<p>日志配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">logging配置</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 1、定义三种日志输出格式，日志中可能用到的格式化串如下</span><br><span class="line"># %(name)s Logger的名字</span><br><span class="line"># %(levelno)s 数字形式的日志级别</span><br><span class="line"># %(levelname)s 文本形式的日志级别</span><br><span class="line"># %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line"># %(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line"># %(module)s 调用日志输出函数的模块名</span><br><span class="line"># %(funcName)s 调用日志输出函数的函数名</span><br><span class="line"># %(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line"># %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line"># %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line"># %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</span><br><span class="line"># %(thread)d 线程ID。可能没有</span><br><span class="line"># %(threadName)s 线程名。可能没有</span><br><span class="line"># %(process)d 进程ID。可能没有</span><br><span class="line"># %(message)s用户输出的消息</span><br><span class="line"></span><br><span class="line"># 2、强调：其中的%(name)s为getlogger时指定的名字</span><br><span class="line">standard_format = &#x27;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&#x27; \</span><br><span class="line">                  &#x27;[%(levelname)s][%(message)s]&#x27;</span><br><span class="line"></span><br><span class="line">simple_format = &#x27;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#x27;</span><br><span class="line"></span><br><span class="line">test_format = &#x27;%(asctime)s] %(message)s&#x27;</span><br><span class="line"></span><br><span class="line"># 3、日志配置字典</span><br><span class="line">LOGGING_DIC = &#123;</span><br><span class="line">    &#x27;version&#x27;: 1,</span><br><span class="line">    &#x27;disable_existing_loggers&#x27;: False,</span><br><span class="line">    &#x27;formatters&#x27;: &#123;</span><br><span class="line">        &#x27;standard&#x27;: &#123;</span><br><span class="line">            &#x27;format&#x27;: standard_format</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;simple&#x27;: &#123;</span><br><span class="line">            &#x27;format&#x27;: simple_format</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;test&#x27;: &#123;</span><br><span class="line">            &#x27;format&#x27;: test_format</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;filters&#x27;: &#123;&#125;,</span><br><span class="line">    &#x27;handlers&#x27;: &#123;</span><br><span class="line">        # 打印到终端的日志</span><br><span class="line">        &#x27;console&#x27;: &#123;</span><br><span class="line">            &#x27;level&#x27;: &#x27;DEBUG&#x27;,</span><br><span class="line">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,  # 打印到屏幕</span><br><span class="line">            &#x27;formatter&#x27;: &#x27;simple&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 打印到文件的日志,收集info及以上的日志</span><br><span class="line">        &#x27;default&#x27;: &#123;</span><br><span class="line">            &#x27;level&#x27;: &#x27;DEBUG&#x27;,</span><br><span class="line">            &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;,  # 保存到文件,日志轮转</span><br><span class="line">            &#x27;formatter&#x27;: &#x27;standard&#x27;,</span><br><span class="line">            # 可以定制日志文件路径</span><br><span class="line">            # BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # log文件的目录</span><br><span class="line">            # LOG_PATH = os.path.join(BASE_DIR,&#x27;a1.log&#x27;)</span><br><span class="line">            &#x27;filename&#x27;: os.path.join(</span><br><span class="line">                BASE_PATH, &#x27;log&#x27;, &#x27;log1.log&#x27;),  # 日志文件</span><br><span class="line">            &#x27;maxBytes&#x27;: 1024 * 1024 * 5,  # 日志大小 5M</span><br><span class="line">            &#x27;backupCount&#x27;: 5,</span><br><span class="line">            &#x27;encoding&#x27;: &#x27;utf-8&#x27;,  # 日志文件的编码，再也不用担心中文log乱码了</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;other&#x27;: &#123;</span><br><span class="line">            &#x27;level&#x27;: &#x27;DEBUG&#x27;,</span><br><span class="line">            &#x27;class&#x27;: &#x27;logging.FileHandler&#x27;,  # 保存到文件</span><br><span class="line">            &#x27;formatter&#x27;: &#x27;test&#x27;,</span><br><span class="line">            &#x27;filename&#x27;: os.path.join(</span><br><span class="line">                BASE_PATH, &#x27;log&#x27;, &#x27;log2.log&#x27;),</span><br><span class="line">            &#x27;encoding&#x27;: &#x27;utf-8&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;loggers&#x27;: &#123;</span><br><span class="line">        # logging.getLogger(__name__)拿到的logger配置</span><br><span class="line">        &#x27;&#x27;: &#123;</span><br><span class="line">            &#x27;handlers&#x27;: [&#x27;default&#x27;, &#x27;console&#x27;],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕</span><br><span class="line">            &#x27;level&#x27;: &#x27;DEBUG&#x27;,  # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)</span><br><span class="line">            &#x27;propagate&#x27;: False,  # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;专门的采集&#x27;: &#123;</span><br><span class="line">            &#x27;handlers&#x27;: [&#x27;other&#x27;, ],</span><br><span class="line">            &#x27;level&#x27;: &#x27;DEBUG&#x27;,</span><br><span class="line">            &#x27;propagate&#x27;: False,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六-序列化模块"><a href="#六-序列化模块" class="headerlink" title="六.序列化模块"></a>六.序列化模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.什么是序列化?</span><br><span class="line">	我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</span><br><span class="line">2.为什么要序列化?</span><br><span class="line">	1：持久保存状态</span><br><span class="line">	2：跨平台数据交互</span><br></pre></td></tr></table></figure>

<h4 id="序列化两大用途"><a href="#序列化两大用途" class="headerlink" title="序列化两大用途:"></a>序列化两大用途:</h4><p>​                1.存档(pickle)</p>
<p>​                2.跨平台交互数据（需要使用一种通用的数据格式-&gt;json）</p>
<h4 id="6-1-json"><a href="#6-1-json" class="headerlink" title="6.1 json"></a>6.1 json</h4><p><img src="https://images2015.cnblogs.com/blog/877318/201609/877318-20160911105642628-530508765.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201702/1036857-20170215162939035-339680318.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">dic=&#123;&#x27;name&#x27;:&#x27;alvin&#x27;,&#x27;age&#x27;:23,&#x27;sex&#x27;:&#x27;male&#x27;&#125;</span><br><span class="line">print(type(dic))#&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line"></span><br><span class="line">j=json.dumps(dic)</span><br><span class="line">print(type(j))#&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f=open(&#x27;序列化对象&#x27;,&#x27;w&#x27;)</span><br><span class="line">f.write(j)  #-------------------等价于json.dump(dic,f)</span><br><span class="line">f.close()</span><br><span class="line">#-----------------------------反序列化&lt;br&gt;</span><br><span class="line">import json</span><br><span class="line">f=open(&#x27;序列化对象&#x27;)</span><br><span class="line">data=json.loads(f.read())#  等价于data=json.load(f)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意点:</span><br><span class="line">    import json</span><br><span class="line">    #dct=&quot;&#123;&#x27;1&#x27;:111&#125;&quot;#json 不认单引号</span><br><span class="line">    #dct=str(&#123;&quot;1&quot;:111&#125;)#报错,因为生成的数据还是单引号:&#123;&#x27;one&#x27;: 1&#125;</span><br><span class="line"></span><br><span class="line">    dct=&#x27;&#123;&quot;1&quot;:&quot;111&quot;&#125;&#x27;</span><br><span class="line">    print(json.loads(dct))</span><br><span class="line"></span><br><span class="line">    #conclusion:</span><br><span class="line">    #无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">1.json 格式的序列化与反序列化方式一</span><br><span class="line">    dic = &#123;&#x27;name&#x27;:&quot;egon&quot;,&quot;age&quot;:18.5,&quot;k1&quot;:True,&#x27;k2&#x27;:None,&#x27;k3&#x27;:(1,2,3)&#125;</span><br><span class="line">    json_str = json.dumps(dic)</span><br><span class="line">    print(json_str,type(json_str))</span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        f.write(json_str)</span><br><span class="line"></span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        json_str = f.read()</span><br><span class="line">        res = json.loads(json_str)</span><br><span class="line">        print(res,type(res))</span><br><span class="line"></span><br><span class="line">2.json 格式的序列化与反序列化方式二:</span><br><span class="line">    dic = &#123;&#x27;name&#x27;:&quot;egon&quot;,&quot;age&quot;:18.5,&quot;k1&quot;:True,&#x27;k2&#x27;:None,&#x27;k3&#x27;:(1,2,3)&#125;</span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        json.dump(dic,f)</span><br><span class="line"></span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        res = json.load(f)</span><br><span class="line">        print(res,type(res))</span><br></pre></td></tr></table></figure>

<h4 id="6-2-pickle"><a href="#6-2-pickle" class="headerlink" title="6.2 pickle"></a>6.2 pickle</h4><p><img src="https://images2015.cnblogs.com/blog/1036857/201702/1036857-20170215164644722-1590025858.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">dic=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alvin&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dic))<span class="comment">#&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">j=pickle.dumps(dic)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j))<span class="comment">#&lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;序列化对象_pickle&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)<span class="comment">#注意是w是写入str,wb是写入bytes,j是&#x27;bytes&#x27;</span></span><br><span class="line">f.write(j)  <span class="comment">#-------------------等价于pickle.dump(dic,f)</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#-------------------------反序列化</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;序列化对象_pickle&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data=pickle.loads(f.read())<span class="comment">#  等价于data=pickle.load(f)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">1.json 格式的序列化与反序列化方式一</span><br><span class="line">    dic = &#123;&#x27;name&#x27;:&quot;egon&quot;,&quot;age&quot;:18.5,&quot;k1&quot;:True,&#x27;k2&#x27;:None,&#x27;k3&#x27;:(1,2,3)&#125;</span><br><span class="line">    json_str = pickle.dumps(dic)</span><br><span class="line">    print(json_str,type(json_str))</span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        f.write(json_str)</span><br><span class="line"></span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        json_str = f.read()</span><br><span class="line">        res = pickle.loads(json_str)</span><br><span class="line">        print(res,type(res))</span><br><span class="line"></span><br><span class="line">2.json 格式的序列化与反序列化方式二:</span><br><span class="line">    dic = &#123;&#x27;name&#x27;:&quot;egon&quot;,&quot;age&quot;:18.5,&quot;k1&quot;:True,&#x27;k2&#x27;:None,&#x27;k3&#x27;:(1,2,3)&#125;</span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        pickle.dump(dic,f)</span><br><span class="line"></span><br><span class="line">    with open(&#x27;a.json&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        res = pickle.load(f)</span><br><span class="line">        print(res,type(res))</span><br></pre></td></tr></table></figure>

<h4 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 一.什么是猴子补丁?</span><br><span class="line">      属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。</span><br><span class="line">      猴子补丁的核心就是用自己的代码替换所用模块的源代码，详细地如下</span><br><span class="line">　　1，这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。</span><br><span class="line">　　2，还有一种解释是说由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二. 猴子补丁的功能(一切皆对象)</span><br><span class="line">　　1.拥有在模块运行时替换的功能, 例如: 一个函数对象赋值给另外一个函数对象(把函数原本的执行的功能给替换了)</span><br><span class="line">class Monkey:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&#x27;hello&#x27;)</span><br><span class="line"></span><br><span class="line">    def world(self):</span><br><span class="line">        print(&#x27;world&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def other_func():</span><br><span class="line">    print(&quot;from other_func&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">monkey = Monkey()</span><br><span class="line">monkey.hello = monkey.world</span><br><span class="line">monkey.hello()</span><br><span class="line">monkey.world = other_func</span><br><span class="line">monkey.world()</span><br><span class="line"></span><br><span class="line"># 三.monkey patch的应用场景</span><br><span class="line">如果我们的程序中已经基于json模块编写了大量代码了，发现有一个模块ujson比它性能更高，</span><br><span class="line">但用法一样，我们肯定不会想所有的代码都换成ujson.dumps或者ujson.loads,那我们可能</span><br><span class="line">会想到这么做</span><br><span class="line">import ujson as json，但是这么做的需要每个文件都重新导入一下，维护成本依然很高</span><br><span class="line">此时我们就可以用到猴子补丁了</span><br><span class="line">只需要在入口处加上</span><br><span class="line">, 只需要在入口加上:</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import ujson</span><br><span class="line"></span><br><span class="line">def monkey_patch_json():</span><br><span class="line">    json.__name__ = &#x27;ujson&#x27;</span><br><span class="line">    json.dumps = ujson.dumps</span><br><span class="line">    json.loads = ujson.loads</span><br><span class="line"></span><br><span class="line">monkey_patch_json() # 之所以在入口处加，是因为模块在导入一次后，后续的导入便直接引用第一次的成果</span><br><span class="line"></span><br><span class="line">#其实这种场景也比较多, 比如我们引用团队通用库里的一个模块, 又想丰富模块的功能, 除了继承之外也可以考虑用Monkey</span><br><span class="line">Patch.采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁。个人感觉Monkey</span><br><span class="line">Patch带了便利的同时也有搞乱源代码的风险!</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">猴子补丁与ujson</span><br></pre></td></tr></table></figure>



<h3 id="七-re模块"><a href="#七-re模块" class="headerlink" title="七.re模块"></a>七.re模块</h3><p>正则表达式</p>
<p>一：什么是正则？</p>
<p>　<strong>正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170529203214461-666088398.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.: 代表匹配一个字符，该字符可以是除了换行符之外的任意字符</span><br><span class="line">[]: 代表匹配一个字符，该字符可以是指定的字符</span><br><span class="line">*: 左边那一个符号出现0次到无穷次</span><br><span class="line">？:左边那一个符号出现0次到1次</span><br><span class="line">+:左边那一个符号出现1次到无穷次</span><br><span class="line">&#123;n,m&#125;:左边那一个符号出现n次到m次</span><br><span class="line">.*:默认为贪婪匹配,代表匹配尽可能多的字符</span><br><span class="line">.*?:为非贪婪匹配：推荐使用,匹配尽可能少的字符</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">	尽量精简,详细的如下</span><br><span class="line">        尽量使用泛匹配模式.*</span><br><span class="line">        尽量使用非贪婪模式:.*?</span><br><span class="line">        使用括号得到匹配目标:用group(n)去取得结果</span><br><span class="line">        换行符就用re.S:修改模式</span><br></pre></td></tr></table></figure>

<h3 id="八-shelve模块"><a href="#八-shelve模块" class="headerlink" title="八. shelve模块"></a>八. shelve模块</h3><p> shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line"></span><br><span class="line">f=shelve.open(r&#x27;sheve.txt&#x27;)</span><br><span class="line"># f[&#x27;stu1_info&#x27;]=&#123;&#x27;name&#x27;:&#x27;egon&#x27;,&#x27;age&#x27;:18,&#x27;hobby&#x27;:[&#x27;piao&#x27;,&#x27;smoking&#x27;,&#x27;drinking&#x27;]&#125;</span><br><span class="line"># f[&#x27;stu2_info&#x27;]=&#123;&#x27;name&#x27;:&#x27;gangdan&#x27;,&#x27;age&#x27;:53&#125;</span><br><span class="line"># f[&#x27;school_info&#x27;]=&#123;&#x27;website&#x27;:&#x27;http://www.pypy.org&#x27;,&#x27;city&#x27;:&#x27;beijing&#x27;&#125;</span><br><span class="line"></span><br><span class="line">print(f[&#x27;stu1_info&#x27;][&#x27;hobby&#x27;])</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h3 id="九-xml模块"><a href="#九-xml模块" class="headerlink" title="九. xml模块"></a>九. xml模块</h3><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line"></span><br><span class="line">xml数据</span><br></pre></td></tr></table></figure>

<p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># print(root.iter(&#x27;year&#x27;)) #全文搜索</span><br><span class="line"># print(root.find(&#x27;country&#x27;)) #在root的子节点找，只找一个</span><br><span class="line"># print(root.findall(&#x27;country&#x27;)) #在root的子节点找，找所有</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root.tag)</span><br><span class="line"> </span><br><span class="line">#遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(&#x27;========&gt;&#x27;,child.tag,child.attrib,child.attrib[&#x27;name&#x27;])</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag,i.attrib,i.text)</span><br><span class="line"> </span><br><span class="line">#只遍历year 节点</span><br><span class="line">for node in root.iter(&#x27;year&#x27;):</span><br><span class="line">    print(node.tag,node.text)</span><br><span class="line">#---------------------------------------</span><br><span class="line"></span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line">#修改</span><br><span class="line">for node in root.iter(&#x27;year&#x27;):</span><br><span class="line">    new_year=int(node.text)+1</span><br><span class="line">    node.text=str(new_year)</span><br><span class="line">    node.set(&#x27;updated&#x27;,&#x27;yes&#x27;)</span><br><span class="line">    node.set(&#x27;version&#x27;,&#x27;1.0&#x27;)</span><br><span class="line">tree.write(&#x27;test.xml&#x27;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#删除node</span><br><span class="line">for country in root.findall(&#x27;country&#x27;):</span><br><span class="line">   rank = int(country.find(&#x27;rank&#x27;).text)</span><br><span class="line">   if rank &gt; 50:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&#x27;output.xml&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#在country内添加（append）节点year2</span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line">tree = ET.parse(&quot;a.xml&quot;)</span><br><span class="line">root=tree.getroot()</span><br><span class="line">for country in root.findall(&#x27;country&#x27;):</span><br><span class="line">    for year in country.findall(&#x27;year&#x27;):</span><br><span class="line">        if int(year.text) &gt; 2000:</span><br><span class="line">            year2=ET.Element(&#x27;year2&#x27;)</span><br><span class="line">            year2.text=&#x27;新年&#x27;</span><br><span class="line">            year2.attrib=&#123;&#x27;update&#x27;:&#x27;yes&#x27;&#125;</span><br><span class="line">            country.append(year2) #往country节点下添加子节点</span><br><span class="line"></span><br><span class="line">tree.write(&#x27;a.xml.swap&#x27;)</span><br></pre></td></tr></table></figure>

<p>自己创建xml文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name,&quot;age&quot;,attrib=&#123;&quot;checked&quot;:&quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name,&quot;sex&quot;)</span><br><span class="line">sex.text = &#x27;33&#x27;</span><br><span class="line">name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2,&quot;age&quot;)</span><br><span class="line">age.text = &#x27;19&#x27;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) #生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) #打印生成的格式</span><br></pre></td></tr></table></figure>

<h3 id="十-configparser模块"><a href="#十-configparser模块" class="headerlink" title="十.configparser模块"></a>十.configparser模块</h3><p><strong>配置文件如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 注释1</span><br><span class="line">; 注释2</span><br><span class="line"></span><br><span class="line">[section1]</span><br><span class="line">k1 = v1</span><br><span class="line">k2:v2</span><br><span class="line">user=egon</span><br><span class="line">age=18</span><br><span class="line">is_admin=true</span><br><span class="line">salary=31</span><br><span class="line">[section2]</span><br><span class="line">k1 = v1</span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"></span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&#x27;a.cfg&#x27;)</span><br><span class="line"></span><br><span class="line">#查看所有的标题</span><br><span class="line">res=config.sections() #[&#x27;section1&#x27;, &#x27;section2&#x27;]</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">#查看标题section1下所有key=value的key</span><br><span class="line">options=config.options(&#x27;section1&#x27;)</span><br><span class="line">print(options) #[&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;user&#x27;, &#x27;age&#x27;, &#x27;is_admin&#x27;, &#x27;salary&#x27;]</span><br><span class="line"></span><br><span class="line">#查看标题section1下所有key=value的(key,value)格式</span><br><span class="line">item_list=config.items(&#x27;section1&#x27;)</span><br><span class="line">print(item_list) #[(&#x27;k1&#x27;, &#x27;v1&#x27;), (&#x27;k2&#x27;, &#x27;v2&#x27;), (&#x27;user&#x27;, &#x27;egon&#x27;), (&#x27;age&#x27;, &#x27;18&#x27;), (&#x27;is_admin&#x27;, &#x27;true&#x27;), (&#x27;salary&#x27;, &#x27;31&#x27;)]</span><br><span class="line"></span><br><span class="line">#查看标题section1下user的值=&gt;字符串格式</span><br><span class="line">val=config.get(&#x27;section1&#x27;,&#x27;user&#x27;)</span><br><span class="line">print(val) #egon</span><br><span class="line"></span><br><span class="line">#查看标题section1下age的值=&gt;整数格式</span><br><span class="line">val1=config.getint(&#x27;section1&#x27;,&#x27;age&#x27;)</span><br><span class="line">print(val1) #18</span><br><span class="line"></span><br><span class="line">#查看标题section1下is_admin的值=&gt;布尔值格式</span><br><span class="line">val2=config.getboolean(&#x27;section1&#x27;,&#x27;is_admin&#x27;)</span><br><span class="line">print(val2) #True</span><br><span class="line"></span><br><span class="line">#查看标题section1下salary的值=&gt;浮点型格式</span><br><span class="line">val3=config.getfloat(&#x27;section1&#x27;,&#x27;salary&#x27;)</span><br><span class="line">print(val3) #31.0</span><br></pre></td></tr></table></figure>

<p><strong>改写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"></span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&#x27;a.cfg&#x27;,encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">#删除整个标题section2</span><br><span class="line">config.remove_section(&#x27;section2&#x27;)</span><br><span class="line"></span><br><span class="line">#删除标题section1下的某个k1和k2</span><br><span class="line">config.remove_option(&#x27;section1&#x27;,&#x27;k1&#x27;)</span><br><span class="line">config.remove_option(&#x27;section1&#x27;,&#x27;k2&#x27;)</span><br><span class="line"></span><br><span class="line">#判断是否存在某个标题</span><br><span class="line">print(config.has_section(&#x27;section1&#x27;))</span><br><span class="line"></span><br><span class="line">#判断标题section1下是否有user</span><br><span class="line">print(config.has_option(&#x27;section1&#x27;,&#x27;&#x27;))</span><br><span class="line"></span><br><span class="line">#添加一个标题</span><br><span class="line">config.add_section(&#x27;egon&#x27;)</span><br><span class="line"></span><br><span class="line">#在标题egon下添加name=egon,age=18的配置</span><br><span class="line">config.set(&#x27;egon&#x27;,&#x27;name&#x27;,&#x27;egon&#x27;)</span><br><span class="line">config.set(&#x27;egon&#x27;,&#x27;age&#x27;,18) #报错,必须是字符串</span><br><span class="line"></span><br><span class="line">#最后将修改的内容写入文件,完成最终的修改</span><br><span class="line">config.write(open(&#x27;a.cfg&#x27;,&#x27;w&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="十一-os模块"><a href="#十一-os模块" class="headerlink" title="十一.os模块"></a>十一.os模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&#x27;.&#x27;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&#x27;..&#x27;)</span><br><span class="line">os.makedirs(&#x27;dirname1/dirname2&#x27;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&#x27;dirname1&#x27;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&#x27;dirname&#x27;)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(&#x27;dirname&#x27;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&#x27;dirname&#x27;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录</span><br><span class="line">os.stat(&#x27;path/filename&#x27;)  获取文件/目录信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&#x27;nt&#x27;; Linux-&gt;&#x27;posix&#x27;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br><span class="line">os.path.getsize(path) 返回path的大小</span><br></pre></td></tr></table></figure>

<h3 id="十二-sys模块"><a href="#十二-sys模块" class="headerlink" title="十二.sys模块"></a>十二.sys模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">2 sys.exit(n)        退出程序，正常退出时exit(0)</span><br><span class="line">3 sys.version        获取Python解释程序的版本信息</span><br><span class="line">4 sys.maxint         最大的Int值</span><br><span class="line">5 sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">6 sys.platform       返回操作系统平台名称</span><br></pre></td></tr></table></figure>

<h3 id="十三-shutil模块"><a href="#十三-shutil模块" class="headerlink" title="十三. shutil模块"></a>十三. shutil模块</h3><p>高级的 文件、文件夹、压缩包 处理模块</p>
<p><strong>shutil.copyfileobj(fsrc, fdst[, length])</strong><br>将文件内容拷贝到另一个文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.copyfileobj(open(&#x27;old.xml&#x27;,&#x27;r&#x27;), open(&#x27;new.xml&#x27;, &#x27;w&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>shutil.copyfile(src, dst)</strong><br>拷贝文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 shutil.copyfile(&#x27;f1.log&#x27;, &#x27;f2.log&#x27;) #目标文件无需存在</span><br></pre></td></tr></table></figure>

<p><strong>shutil.copymode(src, dst)</strong><br>仅拷贝权限。内容、组、用户均不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 shutil.copymode(&#x27;f1.log&#x27;, &#x27;f2.log&#x27;) #目标文件必须存在</span><br></pre></td></tr></table></figure>

<p><strong>shutil.copystat(src, dst)</strong><br>仅拷贝状态的信息，包括：mode bits, atime, mtime, flags</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 shutil.copystat(&#x27;f1.log&#x27;, &#x27;f2.log&#x27;) #目标文件必须存在</span><br></pre></td></tr></table></figure>

<p><strong>shutil.copy(src, dst)</strong><br>拷贝文件和权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.copy(&#x27;f1.log&#x27;, &#x27;f2.log&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>shutil.copy2(src, dst)</strong><br>拷贝文件和状态信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.copy2(&#x27;f1.log&#x27;, &#x27;f2.log&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>shutil.ignore_patterns(*patterns)</strong><br><strong>shutil.copytree(src, dst, symlinks=False, ignore=None)</strong><br>递归的去拷贝文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.copytree(&#x27;folder1&#x27;, &#x27;folder2&#x27;, ignore=shutil.ignore_patterns(&#x27;*.pyc&#x27;, &#x27;tmp*&#x27;)) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除 </span><br></pre></td></tr></table></figure>

<p><strong>shutil.rmtree(path[, ignore_errors[, onerror]])</strong><br>递归的去删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.rmtree(&#x27;folder1&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>shutil.move(src, dst)</strong><br>递归的去移动文件，它类似mv命令，其实就是重命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 import shutil</span><br><span class="line">2  </span><br><span class="line">3 shutil.move(&#x27;folder1&#x27;, &#x27;folder3&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>shutil.make_archive(base_name, format,…)</strong></p>
<p>创建压缩包并返回文件路径，例如：zip、tar</p>
<p>创建压缩包并返回文件路径，例如：zip、tar</p>
<ul>
<li>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，<br>如 data_bak            =&gt;保存至当前路径<br>如：/tmp/data_bak =&gt;保存至/tmp/</li>
<li>format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”</li>
<li>root_dir：    要压缩的文件夹路径（默认当前目录）</li>
<li>owner：    用户，默认当前用户</li>
<li>group：    组，默认当前组</li>
<li>logger：    用于记录日志，通常是logging.Logger对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 #将 /data 下的文件打包放置当前程序目录</span><br><span class="line">2 import shutil</span><br><span class="line">3 ret = shutil.make_archive(&quot;data_bak&quot;, &#x27;gztar&#x27;, root_dir=&#x27;/data&#x27;)</span><br><span class="line">4   </span><br><span class="line">5   </span><br><span class="line">6 #将 /data下的文件打包放置 /tmp/目录</span><br><span class="line">7 import shutil</span><br><span class="line">8 ret = shutil.make_archive(&quot;/tmp/data_bak&quot;, &#x27;gztar&#x27;, root_dir=&#x27;/data&#x27;) </span><br></pre></td></tr></table></figure>

<p>shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">&#x27;laxi.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">z.write(<span class="string">&#x27;a.log&#x27;</span>)</span><br><span class="line">z.write(<span class="string">&#x27;data.data&#x27;</span>)</span><br><span class="line">z.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">&#x27;laxi.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">z.extractall(path=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">z.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import tarfile</span><br><span class="line"></span><br><span class="line"># 压缩</span><br><span class="line">&gt;&gt;&gt; t=tarfile.open(&#x27;/tmp/egon.tar&#x27;,&#x27;w&#x27;)</span><br><span class="line">&gt;&gt;&gt; t.add(&#x27;/test1/a.py&#x27;,arcname=&#x27;a.bak&#x27;)</span><br><span class="line">&gt;&gt;&gt; t.add(&#x27;/test1/b.py&#x27;,arcname=&#x27;b.bak&#x27;)</span><br><span class="line">&gt;&gt;&gt; t.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">&gt;&gt;&gt; t=tarfile.open(&#x27;/tmp/egon.tar&#x27;,&#x27;r&#x27;)</span><br><span class="line">&gt;&gt;&gt; t.extractall(&#x27;/egon&#x27;)</span><br><span class="line">&gt;&gt;&gt; t.close()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">字符编码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-15 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-15T17:27:55+08:00">2018-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>​        字符串类型、文本文件的内容都是由字符组成的，但凡涉及到字符的存取，都需要考虑字符编码的问题。</p>
<h3 id="一-知识储备"><a href="#一-知识储备" class="headerlink" title="一.知识储备"></a>一.知识储备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>三大核心硬件:</span><br><span class="line">    所有软件都是运行硬件之上的，与运行软件相关的三大核心硬件为cpu、内存、硬盘，我们需要明确三点</span><br><span class="line">    	<span class="number">1.</span>软件运行前，软件的代码及其相关数据都是存放于硬盘中的</span><br><span class="line">        <span class="number">2.</span>任何软件的启动都是将数据从硬盘中读入内存，然后cpu从内存中取出指令并执行</span><br><span class="line">        <span class="number">3.</span>软件运行过程中产生的数据先都是存放于内存中，若想永久保存软件产生的数据，则要将数据由内存写入硬盘</span><br><span class="line"><span class="number">2.</span>文本编辑器读取文件内容的流程(三个阶段):</span><br><span class="line">    <span class="number">1.</span>启动一个文件编辑器（文本编辑器如nodepad++，pycharm，word）</span><br><span class="line">	<span class="number">2.</span>文件编辑器会将文件内容从硬盘读入内存</span><br><span class="line">	<span class="number">3.</span>文本编辑器会将刚刚读入内存中的内容显示到屏幕上</span><br><span class="line"><span class="number">3.</span>python解释器执行文件的流程(三个阶段):</span><br><span class="line">    <span class="number">1.</span>启动python解释器，此时就相当于启动了一个文本编辑器</span><br><span class="line">    <span class="number">2.</span>python解释器相当于文本编辑器，从硬盘上将py文件的内容读入到内存中</span><br><span class="line">    <span class="number">3.</span>python解释器解释执行刚刚读入的内存的内容，开始识别python语法</span><br><span class="line"><span class="number">4.</span>总结:</span><br><span class="line">    python解释器与文件本编辑的异同如下:</span><br><span class="line">        <span class="number">1.</span>相同点：前两个阶段二者完全一致，都是将硬盘中文件的内容读入内存</span><br><span class="line">		<span class="number">2.</span>不同点：在阶段<span class="number">3</span>时，针对内存中读入的内容处理方式不同</span><br></pre></td></tr></table></figure>

<h3 id="二-字符编码介绍"><a href="#二-字符编码介绍" class="headerlink" title="二.字符编码介绍"></a>二.字符编码介绍</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是字符编码?</span><br><span class="line">	字符编码中的编码指的是翻译或者转换的意思，即将人能理解的字符参照字符编码表翻译成计算机能识别的数字</span><br><span class="line"><span class="number">2.</span> 字符编码表的发展史</span><br><span class="line">	<span class="number">2.1</span> 阶段一:一家独大  ==&gt;  ASCII码表(英文)</span><br><span class="line">    <span class="number">2.2</span> 阶段二：诸侯割据、天下大乱  ==&gt;  GBK表(中文英文),Shift_JIS表(日文英文),Euc-kr表(韩文英文)</span><br><span class="line">    <span class="number">2.3</span> 阶段三：分久必合  ==&gt;  unicode</span><br><span class="line">    	unicode：支持万国字符</span><br><span class="line">        常用的字符:</span><br><span class="line">            <span class="number">1</span>一个字符对应<span class="number">2</span>个字节</span><br><span class="line">        历史使命：</span><br><span class="line">            <span class="number">1</span>、兼容万国字符</span><br><span class="line">            <span class="number">2</span>、兼容老的字符编码表</span><br><span class="line">            </span><br><span class="line">        英文字符可以被ASCII识别</span><br><span class="line">        	英文字符---&gt;unciode格式的数字---&gt;ASCII格式的数字</span><br><span class="line">        中文字符、英文字符可以被GBK识别</span><br><span class="line">        	中文字符、英文字符---&gt;unicode格式的数字---&gt;gbk格式的数字</span><br><span class="line">        日文字符、英文字符可以被shift-JIS识别</span><br><span class="line">        	日文字符、英文字符---&gt;unicode格式的数字---&gt;shift-JIS格式的数字</span><br><span class="line"><span class="number">3.</span>编码与解码:</span><br><span class="line">    <span class="number">3.1</span>由字符转换成内存中的unicode，以及由unicode转换成其他编码的过程，都称为编码encode</span><br><span class="line">    <span class="number">3.2</span>由内存中的unicode转换成字符，以及由其他编码转换成unicode的过程，都称为解码decode</span><br><span class="line"><span class="number">4.</span>utf-<span class="number">8</span>的由来:</span><br><span class="line">    多国字符—√—》内存（unicode格式的二进制）——X—》硬盘（GBK格式的二进制）</span><br><span class="line">    多国字符—√—》内存（unicode格式的二进制）——X—》硬盘（Shift_JIS格式的二进制）</span><br><span class="line">    多国字符—√—》内存（unicode格式的二进制）——√—》硬盘（utf-<span class="number">8</span>格式的二进制）</span><br><span class="line">    </span><br><span class="line">   注:</span><br><span class="line">      utf-<span class="number">8</span>是针对Unicode的可变长度字符编码:一个英文字符占1Bytes,一个中文字符占3Bytes,生僻字用更多的Bytes存储</span><br></pre></td></tr></table></figure>

<h3 id="三-字符编码应用"><a href="#三-字符编码应用" class="headerlink" title="三.字符编码应用"></a>三.字符编码应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>学习字符编码就是为了存取字符时不发生乱码问题：</span><br><span class="line">    <span class="number">1</span>、内存中固定使用unicode无论输入任何字符都不会发生乱码</span><br><span class="line">    <span class="number">2</span>、我们能够修改的是存/取硬盘的编码方式，编码设置不正确会出现乱码问题。乱码问题分为两种：存乱了，读乱了</span><br><span class="line">        <span class="number">2.1</span> 存乱了：如果用户输入的内容中包含中文和日文字符，如果单纯以shift_JIS存，日文可以正常写入硬		     盘，而由于中文字符在shift_jis中没有找到对应关系而导致存乱了</span><br><span class="line">        <span class="number">2.2</span> 读乱了：如果硬盘中的数据是shift_JIS格式存储的，采GBK格式读入内存就读乱了</span><br><span class="line">        </span><br><span class="line">    总结:</span><br><span class="line">        <span class="number">1.</span> 保证存的时候不乱：在由内存写入硬盘时，必须将编码格式设置为支持所输入字符的编码格式</span><br><span class="line">        <span class="number">2.</span> 保证存的时候不乱：在由硬盘读入内存时，必须采用与写入硬盘时相同的编码格式      </span><br><span class="line"><span class="number">2.</span>字符串encode编码与decode解码的使用:</span><br><span class="line">    <span class="number">1</span>、unicode格式------编码encode--------&gt;其它编码格式</span><br><span class="line">        x=<span class="string">&#x27;上&#x27;</span> <span class="comment"># 在python3在&#x27;上&#x27;被存成unicode</span></span><br><span class="line">        res=x.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        res,<span class="built_in">type</span>(res) <span class="comment"># unicode编码成了utf-8格式,而编码的结果为bytes类型,可以直接当作二进制去使用</span></span><br><span class="line">        ==&gt; (<span class="string">b&#x27;\xe4\xb8\x8a&#x27;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	2、其它编码格式------解码<span class="title">decode</span>--------&gt;unicode格式</span></span><br><span class="line"><span class="class">        res.decode(&#x27;utf-8&#x27;) </span></span><br><span class="line"><span class="class">        ==&gt; &#x27;上&#x27;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">ps:</span></span><br><span class="line">    python3解释器默认读文件的编码格式是utf-<span class="number">8</span></span><br><span class="line">    python2解释器默认读文件的编码格式是<span class="built_in">ascii</span></span><br></pre></td></tr></table></figure>

<h3 id="ASCII表的特点"><a href="#ASCII表的特点" class="headerlink" title="ASCII表的特点:"></a>ASCII表的特点:</h3><p>​            1、只有英文字符与数字的一一对应关系<br>​            2、一个英文字符对应1Bytes，1Bytes=8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符</p>
<p><img src="https://pic2.zhimg.com/80/v2-c4a210efb1a57b869288eb7e89bf6fc9_720w.jpg" alt="img"></p>
<h3 id="GBK表的特点："><a href="#GBK表的特点：" class="headerlink" title="GBK表的特点："></a>GBK表的特点：</h3><p>​        1、只有中文字符、英文字符与数字的一一对应关系<br>        2、一个英文字符对应1Bytes<br>​              一个中文字符对应2Bytes  </p>
<p>​         补充说明：<br>​               1Bytes=8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符<br>​               2Bytes=16bit，16bit最多包含65536个数字，可以对应65536个字符，足够表示所有中文字符</p>
<h3 id="unicode两大特点："><a href="#unicode两大特点：" class="headerlink" title="unicode两大特点："></a>unicode两大特点：</h3><p>​            1.存在所有语言中的所有字符与数字的一一对应关系,即兼容万国字符</p>
<p>​            2.与传统的字符编码的二进制数都有对应关系</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-15 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-15T17:27:55+08:00">2018-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="一-操作系统发展史"><a href="#一-操作系统发展史" class="headerlink" title="一.操作系统发展史"></a>一.操作系统发展史</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 手工操作——穿孔卡片</span><br><span class="line">	-用户独占全机</span><br><span class="line">    -CPU的利用不充分</span><br><span class="line"><span class="number">2</span> 批处理</span><br><span class="line">	-把一个操作整个写到磁带中，以后要进行这个操作，直接拿着磁带，读入即可</span><br><span class="line">    -脱机批处理</span><br><span class="line">    -联机批处理</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> 多道程序系统</span><br><span class="line">	-当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序</span><br><span class="line">    -各道程序轮流地用CPU，并交替运行</span><br><span class="line"><span class="number">4</span> 分时系统</span><br><span class="line">	-多个程序在运行，时间片的概念，cpu执行完固定的时间，就会转去另一个程序</span><br><span class="line"><span class="number">5</span> 通用操作系统</span><br><span class="line">	多道批处理系统，分时</span><br><span class="line">    </span><br><span class="line">io操作：（统统不占用cpu）</span><br><span class="line">	键盘输入，从硬盘拿数据，从网络加载数据---》都叫输入</span><br><span class="line">    显示在显示器，写到硬盘，从网络发送数据---&gt;都叫输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一 操作系统的作用：</span><br><span class="line">    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口</span><br><span class="line">    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序</span><br><span class="line"></span><br><span class="line">二 多道技术：</span><br><span class="line">    1.产生背景：针对单核，实现并发</span><br><span class="line">    ps：</span><br><span class="line">    现在的主机一般是多核，那么每个核都会利用多道技术</span><br><span class="line">    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个</span><br><span class="line">    cpu中的任意一个，具体由操作系统调度算法决定。</span><br><span class="line"></span><br><span class="line">    2.空间上的复用：如内存中同时有多道程序</span><br><span class="line">    3.时间上的复用：复用一个cpu的时间片</span><br><span class="line">       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样</span><br><span class="line">            才能保证下次切换回来时，能基于上次切走的位置继续运行</span><br></pre></td></tr></table></figure>

<h5 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a><strong>进程基础</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">狭义定义：进程是正在运行的程序的实例（an instance of a computer program that <span class="keyword">is</span> being executed）。</span><br><span class="line"></span><br><span class="line">广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程是资源分配的最小单位，线程是cpu执行的最小单位</span></span><br><span class="line"><span class="comment">#一个程序运行，最少有一个进程</span></span><br><span class="line"><span class="comment">#一个进程里最少有一条线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程和程序的区分</span></span><br><span class="line">程序可以作为一种软件资料长期存在，而进程是有一定生命期的。</span><br><span class="line">程序是永久的，进程是暂时的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程的状态（）</span></span><br><span class="line">	-就绪态：可以被cpu调度执行了，还没有执行，排着队</span><br><span class="line">    -运行态：在cpu中运行，正在运行（如果到了时间片，也会被调度出去，调度出去的程序是就绪态）</span><br><span class="line">    -阻塞态：io操作，把数据加载到内存中</span><br></pre></td></tr></table></figure>

<h5 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a><strong>并发和并行</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并发：你在跑步，鞋带开了，停下跑步，系鞋带，系完以后，继续跑步，在一个时间段内来看，你干了多个事</span><br><span class="line">	-单核下的并发</span><br><span class="line">并行：你在跑步，你用随身听在听着，同一时刻，在干多个事</span><br><span class="line">	-只有多核才涉及到并行</span><br></pre></td></tr></table></figure>

<h2 id="二-如何开启多进程"><a href="#二-如何开启多进程" class="headerlink" title="二.如何开启多进程"></a>二.如何开启多进程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在win下开多进程，必须写main，否则报错</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wirte_file</span>(<span class="params">s</span>):</span></span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(s)</span><br><span class="line">        f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># wirte_file()</span></span><br><span class="line">    <span class="comment"># 开启多进程的第一个方式</span></span><br><span class="line">    p=Process(target=wirte_file,args=[<span class="string">&#x27;lqz is nb&#x27;</span>])</span><br><span class="line">    <span class="comment"># 执行该进程</span></span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 又开了一个进程</span></span><br><span class="line">    p1 = Process(target=wirte_file,args=[<span class="string">&#x27;egon is dsb&#x27;</span>])</span><br><span class="line">    <span class="comment"># 执行该进程</span></span><br><span class="line">    p1.start()</span><br></pre></td></tr></table></figure>

<h5 id="进程调度算法-了解"><a href="#进程调度算法-了解" class="headerlink" title="进程调度算法(了解)"></a>进程调度算法(了解)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-先来先服务调度算法</span><br><span class="line">-短作业优先调度算法</span><br><span class="line">-时间片轮转法</span><br><span class="line">-多级反馈队列</span><br></pre></td></tr></table></figure>

<h5 id="同步异步，阻塞非阻塞（了解）"><a href="#同步异步，阻塞非阻塞（了解）" class="headerlink" title="同步异步，阻塞非阻塞（了解）"></a>同步异步，阻塞非阻塞（了解）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 同步调用：提交了以后，一直等待结果返回</span><br><span class="line"><span class="number">2</span> 异步调用：提交了以后，返回一个标志，等执行完成后，有消息通知</span><br><span class="line"><span class="number">3</span> 同步，异步：指的是消息通知机制</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 阻塞，非阻塞：程序在等待调用结果的状态</span><br><span class="line"><span class="number">5</span> 同步阻塞：打电话要买书，如果电话没挂，我也一直在等待，</span><br><span class="line"><span class="number">6</span> 同步非阻塞：打电话买书，电话没挂，我一边干别的事，一边听电话</span><br><span class="line"><span class="number">7</span> 异步阻塞：打电话买书，电话先挂掉，过一会老板会回回来（回调），老板给回电话的过程一直在等待</span><br><span class="line"><span class="number">8</span> 异步非阻塞：打电话买书，电话先挂掉，过一会老板会回回来（回调），老板给回电话的过程中，在干别的事</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><strong>总结:</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1 基于socket写TCP的客户端和服务端</span><br><span class="line">	-加入链接循环</span><br><span class="line">    -加入通信循环</span><br><span class="line">    -客户端主动断开---》服务端一直收空</span><br><span class="line">    -客户端强制断开---》服务端会报错</span><br><span class="line">    -同一时刻，只能有一个客户端与服务端交互</span><br><span class="line">2 基于UDP的客户端和服务端</span><br><span class="line">	-数据不可靠，应用场景比较少</span><br><span class="line">3 并发编程（进程，线程，协程）</span><br><span class="line">4 进程：</span><br><span class="line">	-资源分配的最小单位，线程是cpu调度的最小单位</span><br><span class="line">    -食谱：程序</span><br><span class="line">    -拿到食谱做法的过程，叫进程</span><br><span class="line">    -进程：程序运行的过程，一堆数据+做一件事的过程的集合</span><br><span class="line">    </span><br><span class="line">5 python中如何开启进程</span><br><span class="line">	-p=Process(target=task)</span><br><span class="line">    -p.start()</span><br><span class="line">6 进程调度算法</span><br><span class="line">	-先来先服务</span><br><span class="line">    -短作业有限</span><br><span class="line">    -时间片轮转</span><br><span class="line">    -多级反馈队列</span><br><span class="line">    </span><br><span class="line">7 同步，异步；阻塞，非阻塞</span><br><span class="line">	-同步和异步：指的是回调方式，如果有回调，就是异步，如果同步等待就是同步</span><br><span class="line">    -阻塞，非阻塞：指等待消息结果时的状态，如果在等的过程中，干了别的事，就是非阻塞，如果一直等就是阻塞</span><br></pre></td></tr></table></figure>



<h2 id="三-Process类（重点）"><a href="#三-Process类（重点）" class="headerlink" title="三.Process类（重点）"></a>三.Process类（重点）</h2><h3 id="3-1Process类的参数"><a href="#3-1Process类的参数" class="headerlink" title="3.1Process类的参数"></a>3.1Process类的参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># p=Process(target=task,args=[&#x27;lqz&#x27;,18])</span></span><br><span class="line">    <span class="comment"># p=Process(target=task,kwargs=&#123;&#x27;age&#x27;:19,&#x27;name&#x27;:&#x27;lqz&#x27;&#125;,name=&#x27;process01&#x27;)</span></span><br><span class="line">    p=Process(target=task,kwargs=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>&#125;)</span><br><span class="line">    p2=Process(target=task,kwargs=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>&#125;)</span><br><span class="line">    p.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.name)</span><br><span class="line">    <span class="built_in">print</span>(p2.name)</span><br><span class="line">    <span class="comment"># target=None, 你要执行的任务，函数</span></span><br><span class="line">    <span class="comment"># name=None,  进程名</span></span><br><span class="line">    <span class="comment"># args=(),    以位置参数给任务（函数）传递参数</span></span><br><span class="line">    <span class="comment"># kwargs=&#123;&#125;   以关键字的形式给任务（函数）传递参数</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2Process类的方法，属性（重点）"><a href="#3-2Process类的方法，属性（重点）" class="headerlink" title="3.2Process类的方法，属性（重点）"></a>3.2Process类的方法，属性（重点）</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task,kwargs=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    p.start()  <span class="comment">#启动进程,必须调用start</span></span><br><span class="line">    <span class="comment"># p.run()    # 实际进程在执行的时候，执行的是run方法,但是调用run不会开进程，后面我们另一种开启进程的方案使用到它</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># p.join()    # 等待子进程执行完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())   <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">    p.terminate() <span class="comment"># 杀死p这个进程，通知操作系统去杀死该进程</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment">#可能还是True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ssss&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment">#就是False</span></span><br><span class="line">    <span class="built_in">print</span>(p)  </span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p.start()  #启动进程,必须调用start</span></span><br><span class="line"><span class="string">p.run()  # 实际进程在执行的时候，执行的是run方法,但是调用run不会开进程，后面另一种开启进程的方案使用到它</span></span><br><span class="line"><span class="string">p.join()  # 等待子进程执行完成</span></span><br><span class="line"><span class="string">p.terminate() # 杀死p这个进程，通知操作系统去杀死该进程,并不是立即结束</span></span><br><span class="line"><span class="string">p.is_alive() # 进程是否还存活</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task,kwargs=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># print(p.name) # 进程名字</span></span><br><span class="line">    <span class="comment"># p.daemon=True  #主进程结束，子进程也结束，必须在start之前调用</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(p.pid)  <span class="comment"># 进程id号</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">print(p.name) # 进程名字</span></span><br><span class="line"><span class="string">print(p.pid)  # 进程id号</span></span><br><span class="line"><span class="string">p.daemon=True  #主进程结束，子进程也结束，必须在start之前调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>主进程和子进程的进程号</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    <span class="comment"># 如果在任务中取出进程id号，需要使用os模块</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前进程（子进程）id号是：&#x27;</span>,os.getpid()) <span class="comment">#当前进程id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前进程父进程的id号是：&#x27;</span>,os.getppid()) <span class="comment"># 当前进程父进程的id号</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task,kwargs=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>&#125;)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;p这个进程的id号是：&#x27;</span>,p.pid)  <span class="comment"># 进程id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前进程id（主进程）号是：&#x27;</span>, os.getpid())  <span class="comment"># 当前进程id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前进程父进程（pycharm）的id号是：&#x27;</span>, os.getppid())  <span class="comment"># 当前进程父进程的id号</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果有p对象，就是用p.pid获取进程id号</span></span><br><span class="line"><span class="string">如果没有p对象，就是用os模块的</span></span><br><span class="line"><span class="string">os.getpid() #当前进程id号</span></span><br><span class="line"><span class="string">os.getppid() #父进程id号</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="四-同时开启多个进程"><a href="#四-同时开启多个进程" class="headerlink" title="四.同时开启多个进程"></a>四.同时开启多个进程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># def task(name,age):</span></span><br><span class="line"><span class="comment">#     time.sleep(10)</span></span><br><span class="line"><span class="comment">#     print(name)</span></span><br><span class="line"><span class="comment">#     print(age)</span></span><br><span class="line"><span class="comment"># def task1():</span></span><br><span class="line"><span class="comment">#     time.sleep(2)</span></span><br><span class="line"><span class="comment">#     print(&quot;我是task1&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     p=Process(target=task,kwargs=&#123;&#x27;age&#x27;:19,&#x27;name&#x27;:&#x27;lqz&#x27;&#125;)</span></span><br><span class="line"><span class="comment">#     p.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p1=Process(target=task1)</span></span><br><span class="line"><span class="comment">#     p1.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     print(&#x27;主进程&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>(<span class="params">i</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是task1&quot;</span>,i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ctime=time.time()</span><br><span class="line">    ll=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p1=Process(target=task1,args=[i,])</span><br><span class="line">        p1.start()</span><br><span class="line">        p1.join()  <span class="comment">#等待子进程执行完成</span></span><br><span class="line">        <span class="comment"># ll.append(p1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for p in ll:</span></span><br><span class="line">    <span class="comment">#     p.join()</span></span><br><span class="line">    [p.join()<span class="keyword">for</span> p <span class="keyword">in</span> ll]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(time.time()-ctime)</span><br><span class="line">        </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">开启多个进程</span></span><br><span class="line"><span class="string">如果想等待多个进程同时执行完，先把进程开启完成，再统一join</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1开启进程的另一种方案"><a href="#4-1开启进程的另一种方案" class="headerlink" title="4.1开启进程的另一种方案"></a>4.1开启进程的另一种方案</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 通过继承Process类的方式来实现,重写run方法，run方法就是你要执行的任务,实例化得到对象，调用start方法开启进程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name1,age</span>):</span></span><br><span class="line">        self.name1=name1</span><br><span class="line">        self.age=age</span><br><span class="line">        <span class="comment"># 这个必须写</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) :</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">        <span class="built_in">print</span>(self.name1)</span><br><span class="line">        <span class="built_in">print</span>(self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=MyProcess(<span class="string">&#x27;lqz&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">    p.start() <span class="comment">#调用p.start(),不要调用run</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-2进程之间数据隔离"><a href="#4-2进程之间数据隔离" class="headerlink" title="4.2进程之间数据隔离"></a>4.2进程之间数据隔离</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是task&#x27;</span>)</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程的：&#x27;</span>,n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 在主进程中定义了一个n=10</span></span><br><span class="line">    n=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">###如果这样写，n会被改掉</span></span><br><span class="line">    <span class="comment"># task()</span></span><br><span class="line">    <span class="comment"># print(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">##如果这样写，n不会被改掉</span></span><br><span class="line">    p=Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程的：&#x27;</span>,n)</span><br></pre></td></tr></table></figure>

<h3 id="4-3高并发的tcp服务端"><a href="#4-3高并发的tcp服务端" class="headerlink" title="4.3高并发的tcp服务端"></a>4.3高并发的tcp服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">sock,addr</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端连接成功&#x27;</span>,addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;从客户端收到了：&#x27;</span>, data)</span><br><span class="line">            sock.send(data.upper())</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    sock.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">81</span>))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;等待客户端连接&#x27;</span>)</span><br><span class="line">        sock, addr = server.accept()</span><br><span class="line">        p=Process(target=talk,args=[sock,addr])</span><br><span class="line">        p.start()</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure>

<h3 id="4-4进程同步-进程锁-（次重点）"><a href="#4-4进程同步-进程锁-（次重点）" class="headerlink" title="4.4进程同步(进程锁)（次重点）"></a>4.4进程同步(进程锁)（次重点）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">## 不加锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查询票余额</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ticket&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        res = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:在查询票，票还剩%s张&#x27;</span> % (i, res[<span class="string">&#x27;count&#x27;</span>]))</span><br><span class="line">    <span class="keyword">if</span> res[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 抢票，票的余额减一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ticket&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        res = json.load(f)</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟查票延迟</span></span><br><span class="line">    <span class="keyword">if</span> res[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s现在要买了，票数还是大于0&#x27;</span>%i)</span><br><span class="line">        res[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟买票延迟</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ticket&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">            json.dump(res, f1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s这个人购票成功&#x27;</span> % i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s这个人购票失败，票不够了，买不了了&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">i,lock</span>):</span></span><br><span class="line">    res = check(i)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        buy(i)</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##模拟10个人买票</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=task, args=[i,lock ])</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1 进程类Process类，实例化的时候的参数：</span><br><span class="line">	-target：要执行的任务</span><br><span class="line">    -args：以位置形式给任务传值</span><br><span class="line">    -kwargs：以关键字给任务传值</span><br><span class="line">    -name：进程名字（如果不写，会有个默认名字）</span><br><span class="line">    </span><br><span class="line">2 进程对象的属性和方法</span><br><span class="line">	-属性</span><br><span class="line">    	-name</span><br><span class="line">        -pid：进程id号，如果没有这个对象，需要借助os.getpid(),os.getppid()</span><br><span class="line">        -daemon:守护进程，如果设置为True，主进程挂掉，这个进程也会挂掉，需要在p.start之前执行</span><br><span class="line">    -方法：</span><br><span class="line">    	-is_alive()   进程是否存活</span><br><span class="line">        -terminate()  停止该进程</span><br><span class="line">        -join()       等待子进程执行结束，主进程再继续执行</span><br><span class="line">        -start()      子进程要执行，必须调用它</span><br><span class="line">        -run()        真正的任务</span><br><span class="line">        </span><br><span class="line">3 开启进程的另一种方式（类的继承）</span><br><span class="line">	写一个类，继承Process类</span><br><span class="line">    重写run方法，就是你的任务</span><br><span class="line">    实例化得到我们写的类，调用这个类对象的.start()</span><br><span class="line">    </span><br><span class="line">4 进程间数据是隔离的    </span><br><span class="line">5 进程锁</span><br><span class="line">	-多个进程操作同一个数据（文件中的数据，而不是内存中的数据：）</span><br><span class="line">    -lock=Lock()</span><br><span class="line">    -加锁：lock.acquire()</span><br><span class="line">    -解锁：lock.release()</span><br></pre></td></tr></table></figure>

<h2 id="五-进程Queue介绍"><a href="#五-进程Queue介绍" class="headerlink" title="五.进程Queue介绍"></a>五.进程Queue介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 进程间数据隔离，两个进程进行通信，借助于Queue</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 进程间通信：IPC</span><br><span class="line">	-借助于Queue实现进程间通信</span><br><span class="line">    -借助于文件</span><br><span class="line">    </span><br><span class="line">    -借助于数据库</span><br><span class="line">    -借助于消息队列：rabbitmq，kafka....</span><br></pre></td></tr></table></figure>

<h3 id="5-1基本使用"><a href="#5-1基本使用" class="headerlink" title="5.1基本使用"></a>5.1基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># maxsize表示Queue的大小是多少，能放多少东西</span></span><br><span class="line">    queue=Queue(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">## 放数据</span></span><br><span class="line">    queue.put(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">    queue.put(<span class="string">&#x27;liss&#x27;</span>)</span><br><span class="line">    queue.put(<span class="string">&#x27;wwwww&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    queue.put(<span class="string">&#x27;wwwww&#x27;</span>,timeout=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># queue.put_nowait(&#x27;sdafsd&#x27;)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># res=queue.get()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="comment"># res=queue.get()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    res=queue.get()</span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="comment"># # 卡住</span></span><br><span class="line">    <span class="comment"># # res=queue.get()</span></span><br><span class="line">    <span class="comment"># res=queue.get_nowait()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  # 实例化得到一个对象，数字表示queue的大小</span></span><br><span class="line"><span class="string">  queue=Queue(3)</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 放值</span></span><br><span class="line"><span class="string">  # block:是否阻塞</span></span><br><span class="line"><span class="string">  #timeout：等待的时间</span></span><br><span class="line"><span class="string">  queue.put()</span></span><br><span class="line"><span class="string">  #取值</span></span><br><span class="line"><span class="string">  # block:是否阻塞</span></span><br><span class="line"><span class="string">  #timeout：等待的时间</span></span><br><span class="line"><span class="string">  queue.get()</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 不等待，如果满了，就报错</span></span><br><span class="line"><span class="string">  queue.put_nowait()</span></span><br><span class="line"><span class="string">  # 去取值，如果没有值，直接报错</span></span><br><span class="line"><span class="string">  res=queue.get_nowait()</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  #查看这个queue是否满</span></span><br><span class="line"><span class="string">  queue.full()</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  #查看queue是否是空的</span></span><br><span class="line"><span class="string">  queue.empty()</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 查看queue中有几个值</span></span><br><span class="line"><span class="string">  queue.qsize()</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2通过Queue实现进程间通信"><a href="#5-2通过Queue实现进程间通信" class="headerlink" title="5.2通过Queue实现进程间通信"></a>5.2通过Queue实现进程间通信</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">queue</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我这个进程%s开始放数据了&#x27;</span>%os.getpid())</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    queue.put(<span class="string">&#x27;lqz is handsome&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s我放完了&#x27;</span> % os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#不写数字，表示可以任意长度</span></span><br><span class="line">    queue=Queue()</span><br><span class="line">    p=Process(target=task,args=[queue,])</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    res=queue.get()  <span class="comment">#会卡在这</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h3 id="5-3批量生产数据放入Queue再批量取出"><a href="#5-3批量生产数据放入Queue再批量取出" class="headerlink" title="5.3批量生产数据放入Queue再批量取出"></a>5.3批量生产数据放入Queue再批量取出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span>(<span class="params">queue</span>):</span></span><br><span class="line">    res=queue.get()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s这个进程取了数据：%s&#x27;</span>%(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_task</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&#x27;%s:放了数据&#x27;</span>%os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue=Queue(<span class="number">1</span>)</span><br><span class="line">    p1=Process(target=put_task,args=[queue])</span><br><span class="line">    p2=Process(target=put_task,args=[queue])</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p3=Process(target=get_task,args=[queue])</span><br><span class="line">    p4=Process(target=get_task,args=[queue])</span><br><span class="line">    p3.start()</span><br><span class="line">    p4.start()</span><br></pre></td></tr></table></figure>

<h2 id="六-生产者消费者模型-重点"><a href="#六-生产者消费者模型-重点" class="headerlink" title="六.生产者消费者模型(重点)"></a>六.生产者消费者模型(重点)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from multiprocessing import Process, Queue</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment"># def producer(queue):</span></span><br><span class="line"><span class="comment">#     # 生产的东西，放到Queue中</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         data = &#x27;%s这个厨师，整了第%s个包子&#x27; % (os.getpid(), i)</span></span><br><span class="line"><span class="comment">#         print(data)</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1,3))</span></span><br><span class="line"><span class="comment">#         queue.put(&#x27;第%s个包子&#x27;%i)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def consumer(queue):</span></span><br><span class="line"><span class="comment">#     # 消费者从queue中取数据，消费（吃包子）</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         res=queue.get()</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1, 3))</span></span><br><span class="line"><span class="comment">#         print(&#x27;%s这个消费者，吃了%s&#x27;%(os.getpid(),res))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     queue=Queue(3)</span></span><br><span class="line"><span class="comment">#     p=Process(target=producer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p1=Process(target=consumer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p1.start()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 改良（生产者不生产东西了，但是消费者还在等着拿）</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment"># def producer(queue):</span></span><br><span class="line"><span class="comment">#     # 生产的东西，放到Queue中</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         data = &#x27;%s这个厨师，整了第%s个包子&#x27; % (os.getpid(), i)</span></span><br><span class="line"><span class="comment">#         print(data)</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1,3))</span></span><br><span class="line"><span class="comment">#         queue.put(&#x27;第%s个包子&#x27;%i)</span></span><br><span class="line"><span class="comment">#     # 生产完了，在queue中放一个None</span></span><br><span class="line"><span class="comment">#     queue.put(None)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def consumer(queue):</span></span><br><span class="line"><span class="comment">#     # 消费者从queue中取数据，消费（吃包子）</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         res=queue.get()</span></span><br><span class="line"><span class="comment">#         if not res:break # 如果去到空，说明打烊了（生产者不生产了），退出</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1, 3))</span></span><br><span class="line"><span class="comment">#         print(&#x27;%s这个消费者，吃了%s&#x27;%(os.getpid(),res))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     queue=Queue(3)</span></span><br><span class="line"><span class="comment">#     p=Process(target=producer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p1=Process(target=consumer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p1.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 把put none 放在主进程中执行</span></span><br><span class="line"><span class="comment">#import os</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment"># def producer(queue):</span></span><br><span class="line"><span class="comment">#     # 生产的东西，放到Queue中</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         data = &#x27;%s这个厨师，整了第%s个包子&#x27; % (os.getpid(), i)</span></span><br><span class="line"><span class="comment">#         print(data)</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1,3))</span></span><br><span class="line"><span class="comment">#         queue.put(&#x27;第%s个包子&#x27;%i)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def consumer(queue):</span></span><br><span class="line"><span class="comment">#     # 消费者从queue中取数据，消费（吃包子）</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         res=queue.get()</span></span><br><span class="line"><span class="comment">#         if not res:break # 如果去到空，说明打烊了（生产者不生产了），退出</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1, 3))</span></span><br><span class="line"><span class="comment">#         print(&#x27;%s这个消费者，吃了%s&#x27;%(os.getpid(),res))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     queue=Queue(3)</span></span><br><span class="line"><span class="comment">#     p=Process(target=producer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p1=Process(target=consumer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     p1.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 如果把put None放在这，会有问题</span></span><br><span class="line"><span class="comment">#     # 主进程会先执行这句话，消费进程读到None，直接结束，生产者进程没有结束，于是生产一直在生产，消费已经不消费了</span></span><br><span class="line"><span class="comment">#     # 直到Queue满了，就一直卡在这了</span></span><br><span class="line"><span class="comment">#     # queue.put(None)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     ### 现在就要放在这，把问题解决</span></span><br><span class="line"><span class="comment">#     p.join()</span></span><br><span class="line"><span class="comment">#     queue.put(None)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-1多个生产者多个消费者的生产者消费者模型"><a href="#6-1多个生产者多个消费者的生产者消费者模型" class="headerlink" title="6.1多个生产者多个消费者的生产者消费者模型"></a>6.1多个生产者多个消费者的生产者消费者模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个生产者在生产，多个消费者在消费</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment"># def producer(queue,food):</span></span><br><span class="line"><span class="comment">#     # 生产的东西，放到Queue中</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         data = &#x27;%s这个厨师，做了第%s个%s&#x27; % (os.getpid(), i,food)</span></span><br><span class="line"><span class="comment">#         print(data)</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1,3))</span></span><br><span class="line"><span class="comment">#         queue.put(&#x27;第%s个%s&#x27;%(i,food))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def consumer(queue):</span></span><br><span class="line"><span class="comment">#     # 消费者从queue中取数据，消费（吃包子）</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         res=queue.get()</span></span><br><span class="line"><span class="comment">#         if not res:break # 如果去到空，说明打烊了（生产者不生产了），退出</span></span><br><span class="line"><span class="comment">#         # 模拟一下延迟</span></span><br><span class="line"><span class="comment">#         time.sleep(random.randint(1, 3))</span></span><br><span class="line"><span class="comment">#         print(&#x27;%s这个消费者，吃了%s&#x27;%(os.getpid(),res))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     queue=Queue(3)</span></span><br><span class="line"><span class="comment">#     ##起了三个生产者</span></span><br><span class="line"><span class="comment">#     p1=Process(target=producer,args=[queue,&#x27;包子&#x27;])</span></span><br><span class="line"><span class="comment">#     p2=Process(target=producer,args=[queue,&#x27;骨头&#x27;])</span></span><br><span class="line"><span class="comment">#     p3=Process(target=producer,args=[queue,&#x27;泔水&#x27;])</span></span><br><span class="line"><span class="comment">#     p1.start()</span></span><br><span class="line"><span class="comment">#     p2.start()</span></span><br><span class="line"><span class="comment">#     p3.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 起了两个消费者</span></span><br><span class="line"><span class="comment">#     c1=Process(target=consumer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     c2=Process(target=consumer,args=[queue,])</span></span><br><span class="line"><span class="comment">#     c1.start()</span></span><br><span class="line"><span class="comment">#     c2.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     ##等三个生产者都生产完，放三个None</span></span><br><span class="line"><span class="comment">#     p1.join()</span></span><br><span class="line"><span class="comment">#     p2.join()</span></span><br><span class="line"><span class="comment">#     p3.join()</span></span><br><span class="line"><span class="comment">#     queue.put(None)</span></span><br><span class="line"><span class="comment">#     queue.put(None)</span></span><br><span class="line"><span class="comment">#     queue.put(None)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##如果消费者多，比生产者多出来的消费者不会停</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue, food,name</span>):</span></span><br><span class="line">    <span class="comment"># 生产的东西，放到Queue中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        data = <span class="string">&#x27;%s:这个厨师，做了第%s个%s&#x27;</span> % (name, i, food)</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="comment"># 模拟一下延迟</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        queue.put(<span class="string">&#x27;第%s个%s&#x27;</span> % (i, food))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue,name</span>):</span></span><br><span class="line">    <span class="comment"># 消费者从queue中取数据，消费（吃包子）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = queue.get(timeout=<span class="number">20</span>)</span><br><span class="line">            <span class="comment"># 模拟一下延迟</span></span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s这个消费者，吃了%s&#x27;</span> % (name, res))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">##起了三个生产者</span></span><br><span class="line">    p1 = Process(target=producer, args=[queue, <span class="string">&#x27;包子&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>])</span><br><span class="line">    p2 = Process(target=producer, args=[queue, <span class="string">&#x27;骨头&#x27;</span>,<span class="string">&#x27;lqz&#x27;</span>])</span><br><span class="line">    p3 = Process(target=producer, args=[queue, <span class="string">&#x27;泔水&#x27;</span>,<span class="string">&#x27;json&#x27;</span>])</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起了两个消费者</span></span><br><span class="line">    c1 = Process(target=consumer, args=[queue, <span class="string">&#x27;孟良&#x27;</span>])</span><br><span class="line">    c2 = Process(target=consumer, args=[queue, <span class="string">&#x27;劲涛&#x27;</span>])</span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2进程间数据共享（了解）"><a href="#6-2进程间数据共享（了解）" class="headerlink" title="6.2进程间数据共享（了解）"></a>6.2进程间数据共享（了解）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Manager,Lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔法方法：类内以__开头__结尾的方法，都叫魔法方法,某种情况下会触发它的执行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">__init__ ：类()触发</span></span><br><span class="line"><span class="string">__new__：</span></span><br><span class="line"><span class="string">__getattr__</span></span><br><span class="line"><span class="string">__setattr__</span></span><br><span class="line"><span class="string">__getitem__</span></span><br><span class="line"><span class="string">__setitem__</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def task(dic,lock):</span></span><br><span class="line"><span class="comment">#     # lock.acquire()</span></span><br><span class="line"><span class="comment">#     # dic[&#x27;count&#x27;]-=1</span></span><br><span class="line"><span class="comment">#     # lock.release()</span></span><br><span class="line"><span class="comment">#     with lock:</span></span><br><span class="line"><span class="comment">#         dic[&#x27;count&#x27;] -= 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     lock = Lock()</span></span><br><span class="line"><span class="comment">#     with Manager() as m:</span></span><br><span class="line"><span class="comment">#         # 如果直接定义dict，这个dict在多个进程中其实是多份，进程如果改，只改了自己的</span></span><br><span class="line"><span class="comment">#         #如果定义的是m.dict(&#123;&#x27;count&#x27;: 100&#125;)，多个进程之间就可以共享这个数据</span></span><br><span class="line"><span class="comment">#         dic = m.dict(&#123;&#x27;count&#x27;: 100&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         p_l = []</span></span><br><span class="line"><span class="comment">#         for i in range(100):</span></span><br><span class="line"><span class="comment">#             p = Process(target=task, args=(dic, lock))</span></span><br><span class="line"><span class="comment">#             p_l.append(p)</span></span><br><span class="line"><span class="comment">#             p.start()</span></span><br><span class="line"><span class="comment">#         for p in p_l:</span></span><br><span class="line"><span class="comment">#             p.join()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">dic,lock</span>):</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    dic=&#123;<span class="string">&#x27;count&#x27;</span>:<span class="number">100</span>&#125;</span><br><span class="line">    p_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        p = Process(target=task, args=(dic, lock))</span><br><span class="line">        p_l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure>

<h2 id="七-线程概念"><a href="#七-线程概念" class="headerlink" title="七.线程概念"></a>七.线程概念</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二</span><br><span class="line"></span><br><span class="line">ps:进程是资源分配的最小单位，线程是CPU调度的最小单位。每一个进程中至少有一个线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是子线程执行的&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line"></span><br><span class="line">    ctime = time.time()</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># task()</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(os.getpid())</span><br><span class="line">    <span class="built_in">print</span>(time.time() - ctime)</span><br></pre></td></tr></table></figure>

<h3 id="全局解释器锁（GIL）"><a href="#全局解释器锁（GIL）" class="headerlink" title="全局解释器锁（GIL）"></a>全局解释器锁（GIL）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> pypy（没有全局解释器锁） cpython（<span class="number">99.999999</span>%）</span><br><span class="line">    -pypy python好多模块用不了，</span><br><span class="line"><span class="number">1</span> 全局解释器锁，GIL锁（cpython解释器的问题）</span><br><span class="line">	-当年python设计的时候，还是单核，没有多核的概念</span><br><span class="line">    -python需要做垃圾回收（gc）</span><br><span class="line">    -垃圾回收线程，进行垃圾回收</span><br><span class="line">    -设计了一个大锁（GIL锁），只有拿到这把锁的线程，才能执行</span><br><span class="line">    -同一时刻，在一个进程中，可以开多个线程，但是只能有一条线程在执行</span><br><span class="line">    -不能利用多核优势</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 只针对与cpython解释器（其他解释器，包括其他语言不这样）</span></span><br><span class="line"><span class="number">2</span> 如果是计算密集型：要开进程</span><br><span class="line"><span class="number">3</span> 如果是io密集型：要开线程</span><br></pre></td></tr></table></figure>

<h3 id="7-1开启线程的两种方式"><a href="#7-1开启线程的两种方式" class="headerlink" title="7.1开启线程的两种方式"></a>7.1开启线程的两种方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def task():</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print(&#x27;我是子线程&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     t=Thread(target=task)</span></span><br><span class="line"><span class="comment">#     t.start()</span></span><br><span class="line"><span class="comment">#     print(&#x27;我是主线程&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###第二种方式</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,a</span>):</span></span><br><span class="line">        self.a=a</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是子线程&#x27;</span>,self.a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=MyThread(<span class="string">&#x27;aaaaa&#x27;</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是主线程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-3多线程与多进程比较"><a href="#7-3多线程与多进程比较" class="headerlink" title="7.3多线程与多进程比较"></a>7.3多线程与多进程比较</h3><h4 id="7-3-1开启速度比较"><a href="#7-3-1开启速度比较" class="headerlink" title="7.3.1开启速度比较"></a>7.3.1开启速度比较</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开线程消耗的资源，耗费的时间远远小于开进程</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是子线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">####线程</span></span><br><span class="line">    <span class="comment"># ctime=time.time()</span></span><br><span class="line">    <span class="comment"># t=Thread(target=task)</span></span><br><span class="line">    <span class="comment"># t.start()</span></span><br><span class="line">    <span class="comment"># t.join() # 等待子线程执行完成主线程再执行</span></span><br><span class="line">    <span class="comment"># print(&#x27;我是主线程&#x27;)</span></span><br><span class="line">    <span class="comment"># print(time.time()-ctime)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">##进程</span></span><br><span class="line">    ctime=time.time()</span><br><span class="line">    t=Process(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join() <span class="comment"># 等待子线程执行完成主线程再执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是主线程&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(time.time()-ctime)</span><br></pre></td></tr></table></figure>

<h4 id="7-3-2-内存数据的共享问题"><a href="#7-3-2-内存数据的共享问题" class="headerlink" title="7.3.2 内存数据的共享问题"></a>7.3.2 内存数据的共享问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##线程间数据共享</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">####线程</span></span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    t=Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join() <span class="comment"># 等待子线程执行完成主线程再执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是主线程&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<h3 id="7-4Thread类的其他方法"><a href="#7-4Thread类的其他方法" class="headerlink" title="7.4Thread类的其他方法"></a>7.4Thread类的其他方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="comment"># time.sleep(0.01)</span></span><br><span class="line">    <span class="comment">#在子线程中执行</span></span><br><span class="line">    <span class="comment"># res = threading.currentThread()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line">    res=threading.get_ident()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子线程：&#x27;</span>,res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是子线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=task)</span><br><span class="line">    t1=Thread(target=task)</span><br><span class="line"></span><br><span class="line">    t.start()</span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># print(t.is_alive())  #看线程是否存活</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print(t.getName() )  # 获取线程的名字</span></span><br><span class="line">    <span class="comment"># t.setName(&#x27;lqz&#x27;)   # 设置线程民资</span></span><br><span class="line">    <span class="comment"># print(t.getName() )</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print(&#x27;主线程&#x27;)</span></span><br><span class="line">    <span class="comment"># time.sleep(0.02)</span></span><br><span class="line">    <span class="comment"># print(t.is_alive())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主线程中执行，返回当前线程对象</span></span><br><span class="line">    <span class="comment"># res=threading.currentThread()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回当前进程中正在运行的子线程对象列表</span></span><br><span class="line">    <span class="comment"># res=threading.enumerate()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回当前正在运行的线程个数</span></span><br><span class="line">    <span class="comment"># res=threading.activeCount()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程id号</span></span><br><span class="line">    res=threading.get_ident()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程：&#x27;</span>,res)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   t.is_alive()</span></span><br><span class="line"><span class="string">   t.getName()</span></span><br><span class="line"><span class="string">   t.setName(&#x27;lqz&#x27;) </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   threading:模块下的一些方法</span></span><br><span class="line"><span class="string">   res=threading.currentThread()</span></span><br><span class="line"><span class="string">   res=threading.enumerate()</span></span><br><span class="line"><span class="string">   res=threading.activeCount()</span></span><br><span class="line"><span class="string">   res=threading.get_ident()</span></span><br><span class="line"><span class="string">   &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-1-join方法"><a href="#7-4-1-join方法" class="headerlink" title="7.4.1 join方法"></a>7.4.1 join方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待子线程执行结束</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是子线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ll=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line"></span><br><span class="line">        t.start()</span><br><span class="line">        ll.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ll:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主线程等待子线程执行完再执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是主线程，子线程全都执行完了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="7-4-2守护线程"><a href="#7-4-2守护线程" class="headerlink" title="7.4.2守护线程"></a>7.4.2守护线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是子线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=task)</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)  <span class="comment"># 如果主线程执行结束，子线程也结束（不执行了）</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#只要主线程执行结束，子线程也结束</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程执行结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3同步锁（互斥锁）"><a href="#7-4-3同步锁（互斥锁）" class="headerlink" title="7.4.3同步锁（互斥锁）"></a>7.4.3同步锁（互斥锁）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 多个线程操作同一个数据（变量），会出现并发安全的问题</span></span><br><span class="line"><span class="comment"># from threading import Thread,Lock</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment"># def task():</span></span><br><span class="line"><span class="comment">#     global n</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     ### 临界区(加锁)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     temp=n</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     temp=temp-1</span></span><br><span class="line"><span class="comment">#     n=temp</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     ##模拟不出来，因为太快了，没有cup的切换（io，时间片到了），模拟io，让cpu切换</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # n-=1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     n=10</span></span><br><span class="line"><span class="comment">#     ll=[]</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         t=Thread(target=task)</span></span><br><span class="line"><span class="comment">#         t.start()</span></span><br><span class="line"><span class="comment">#         ll.append(t)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     for i in ll:</span></span><br><span class="line"><span class="comment">#         i.join()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     print(n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###出现了并发安全的问题，加锁解决</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_lock</span>(<span class="params">lock</span>):</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">### 临界区(加锁)</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">        temp=n</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">        temp=temp-<span class="number">1</span></span><br><span class="line">        n=temp</span><br><span class="line"></span><br><span class="line">    <span class="comment">##模拟不出来，因为太快了，没有cup的切换（io，时间片到了），模拟io，让cpu切换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># n-=1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_no_lock</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    temp=temp-<span class="number">1</span></span><br><span class="line">    n=temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="number">10</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    ll=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># t=Thread(target=task_lock,args=[lock,])</span></span><br><span class="line">        t=Thread(target=task_no_lock,args=[lock,])</span><br><span class="line">        t.start()</span><br><span class="line">        ll.append(t)</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in ll:</span></span><br><span class="line">    <span class="comment">#     i.join()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">互斥锁和join的区别</span></span><br><span class="line"><span class="string">如果使用互斥锁：只锁临界区，只有临界区是串行，其他地方还是并发的</span></span><br><span class="line"><span class="string">如果使用join，整个过程全变成串行执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 信号量可以理解为多把锁，同时允许多个线程来更改数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread,Semaphore</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">sm,i</span>):</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:这个人在上厕所&#x27;</span>%i)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:这个人拉完了&#x27;</span>%i)</span><br><span class="line">    sm.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sm=Semaphore(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    t=Thread(target=task,args=[sm,i])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Event事件:</span><br><span class="line">一些线程需要等到其他线程执行完成之后才能执行，类似于发射信号</span><br><span class="line">比如一个线程等待另一个线程执行结束再继续执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些线程需要等到其他线程执行完成之后才能执行，类似于发射信号</span></span><br><span class="line"><span class="comment"># 比如一个线程等待另一个线程执行结束再继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">girl</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;赵丽颖现在在结婚状态&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 离婚了，发送信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;赵丽颖离婚了&#x27;</span>)</span><br><span class="line">    event.<span class="built_in">set</span>()  <span class="comment"># 发送一个信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boy</span>(<span class="params">i, event</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;屌丝%s：在等赵丽颖的离婚信号&#x27;</span>%i)</span><br><span class="line">    event.wait()  <span class="comment"># 收不到信号之前，一直卡在这</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;屌丝%s号，收到了离婚信号，开始追&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line">t = Thread(target=girl, args=[event, ])</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t1 = Thread(target=boy, args=[i, event])</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##  写两条线程，一条线程读一个文件的头2分之一，另一个线程读这个文件的后2分之一，但是必须第一个线程读完，发送信号后，第二个线程才能读</span></span><br></pre></td></tr></table></figure>





<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结:"></a>总结:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> GIL锁：全局解释器锁，在解释器之上的一把大锁，线程必须获得这把锁，才能执行，只针对与cpython解释器</span><br><span class="line"><span class="number">2</span> GIL和线程锁有什么区别？有了GIL锁，为什么还要线程锁？</span><br><span class="line">	-本身GIL和线程锁，都是线程级别的锁，GIL是内置的，解释器里的</span><br><span class="line">    -线程锁：开发者定义的</span><br><span class="line"><span class="number">3</span> 多核cpu： </span><br><span class="line">	如果是计算密集型：开进程</span><br><span class="line">    io密集型：开线程</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span> 开启线程的两种方式（对比进程）</span><br><span class="line"><span class="number">5</span> 进程和线程的比较</span><br><span class="line">	-进程<span class="built_in">id</span>比较</span><br><span class="line">    -开启效率的比较</span><br><span class="line">    -共享变量</span><br><span class="line">    </span><br><span class="line"><span class="number">6</span> Thread类的其他方法，threading模块下的其他方法</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> 线程join（等待子线程执行完成）</span><br><span class="line"><span class="number">8</span> 守护线程（如果主线程执行完成，子线程也结束）</span><br><span class="line"><span class="number">9</span> 互斥锁，同步锁：为了保证并发情况下数据安全，把对数据的操作过程变成串行，牺牲了效率，保证了数据安全</span><br><span class="line"><span class="number">10</span> 信号量，Event</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="死锁问题（递归锁，可重入锁）"><a href="#死锁问题（递归锁，可重入锁）" class="headerlink" title="死锁问题（递归锁，可重入锁）"></a>死锁问题（递归锁，可重入锁）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 所谓死锁：是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 可重入锁，递归锁</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from threading import Thread, Lock</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def eat1(lock_1, lock_2, name):</span></span><br><span class="line"><span class="comment">#     lock_1.acquire()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s:拿到了筷子&#x27; % name)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     lock_2.acquire()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s:拿到了面条&#x27; % name)</span></span><br><span class="line"><span class="comment">#     print(&#x27;开始吃面&#x27;)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     lock_2.release()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s放下了面条&#x27; % name)</span></span><br><span class="line"><span class="comment">#     lock_1.release()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s放下了筷子&#x27; % name)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def eat2(lock_1, lock_2, name):</span></span><br><span class="line"><span class="comment">#     lock_2.acquire()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s:拿到了面条&#x27; % name)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     lock_1.acquire()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s:拿到了筷子&#x27; % name)</span></span><br><span class="line"><span class="comment">#     print(&#x27;开始吃面&#x27;)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     lock_1.release()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s放下了筷子&#x27; % name)</span></span><br><span class="line"><span class="comment">#     lock_2.release()</span></span><br><span class="line"><span class="comment">#     print(&#x27;%s放下了面条&#x27; % name)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     lock_1 = Lock()</span></span><br><span class="line"><span class="comment">#     lock_2 = Lock()</span></span><br><span class="line"><span class="comment">#     for i in [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]:</span></span><br><span class="line"><span class="comment">#         t = Thread(target=eat1, args=[lock_1, lock_2, i])</span></span><br><span class="line"><span class="comment">#         t.start()</span></span><br><span class="line"><span class="comment">#     for i in [&#x27;赵6&#x27;, &#x27;往7&#x27;, &#x27;傻逼&#x27;]:</span></span><br><span class="line"><span class="comment">#         t = Thread(target=eat2, args=[lock_1, lock_2, i])</span></span><br><span class="line"><span class="comment">#         t.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 解决死锁问题  RLock:可重入，可以重复acquire，获得几次，就要释放几次</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock,RLock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span>(<span class="params">lock_1, lock_2, name</span>):</span></span><br><span class="line">    lock_1.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:拿到了筷子&#x27;</span> % name)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    lock_2.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:拿到了面条&#x27;</span> % name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始吃面&#x27;</span>)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    lock_2.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s放下了面条&#x27;</span> % name)</span><br><span class="line">    lock_1.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s放下了筷子&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span>(<span class="params">lock_1, lock_2, name</span>):</span></span><br><span class="line">    lock_2.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:拿到了面条&#x27;</span> % name)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    lock_1.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s:拿到了筷子&#x27;</span> % name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始吃面&#x27;</span>)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    lock_1.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s放下了筷子&#x27;</span> % name)</span><br><span class="line">    lock_2.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s放下了面条&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock_1 = RLock()</span><br><span class="line">    lock_2 = lock_1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lock_1 = Lock()</span></span><br><span class="line">    <span class="comment"># lock_2 = lock_1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]:</span><br><span class="line">        t = Thread(target=eat1, args=[lock_1, lock_2, i])</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;赵6&#x27;</span>, <span class="string">&#x27;往7&#x27;</span>, <span class="string">&#x27;傻逼&#x27;</span>]:</span><br><span class="line">        t = Thread(target=eat2, args=[lock_1, lock_2, i])</span><br><span class="line">        t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程队列"><a href="#线程队列" class="headerlink" title="线程队列"></a>线程队列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 线程Queue，解决线程间数据共享的问题</span><br><span class="line"><span class="number">2</span> 线程间数据共享可以使用共享变量（可能会存在并发安全的问题）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue,LifoQueue,PriorityQueue <span class="comment"># 线程queue</span></span><br><span class="line"><span class="comment"># Queue:先进先出</span></span><br><span class="line"><span class="comment">#LifoQueue：后进先出</span></span><br><span class="line"><span class="comment">#PriorityQueue：优先级队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># def task(queue):</span></span><br><span class="line"><span class="comment">#     time.sleep(3)</span></span><br><span class="line"><span class="comment">#     queue.put(&#x27;lqz&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     queue=Queue()</span></span><br><span class="line"><span class="comment">#     t=Thread(target=task,args=[queue,])</span></span><br><span class="line"><span class="comment">#     t.start()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     res=queue.get()</span></span><br><span class="line"><span class="comment">#     print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queue:先进先出</span></span><br><span class="line"><span class="comment"># LifoQueue：后进先出</span></span><br><span class="line"><span class="comment"># PriorityQueue：优先级队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># quque1=Queue()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># quque1.put(1)</span></span><br><span class="line">    <span class="comment"># quque1.put(2)</span></span><br><span class="line">    <span class="comment"># print(quque1.get())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># quque2=LifoQueue()</span></span><br><span class="line">    <span class="comment"># quque2.put(1)</span></span><br><span class="line">    <span class="comment"># quque2.put(2)</span></span><br><span class="line">    <span class="comment"># print(quque2.get())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    quque3=PriorityQueue()</span><br><span class="line">    quque3.put((<span class="number">1</span>,<span class="string">&#x27;lqz&#x27;</span>))</span><br><span class="line">    quque3.put((<span class="number">100</span>,<span class="string">&#x27;egon&#x27;</span>))</span><br><span class="line">    <span class="comment"># 数字越小，优先级越高</span></span><br><span class="line">    <span class="built_in">print</span>(quque3.get())</span><br></pre></td></tr></table></figure>

<h2 id="八-进程池，线程池"><a href="#八-进程池，线程池" class="headerlink" title="八.进程池，线程池"></a>八.进程池，线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池，进程池都在这个模块下concurrent.futures</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor,ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># def task(n):</span></span><br><span class="line"><span class="comment">#     print(os.getpid(), &#x27;开始执行了&#x27;)</span></span><br><span class="line"><span class="comment">#     time.sleep(random.random())</span></span><br><span class="line"><span class="comment">#     return n * n</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def callback(result):</span></span><br><span class="line"><span class="comment">#     print(result)</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     # 开进程池去执行</span></span><br><span class="line"><span class="comment">#     # ProcessPoolExecutor实例化得到一个对象</span></span><br><span class="line"><span class="comment">#     pool_p=ProcessPoolExecutor(3)</span></span><br><span class="line"><span class="comment">#     # ll=[]</span></span><br><span class="line"><span class="comment">#     # for i in range(10):</span></span><br><span class="line"><span class="comment">#     #     # 把任务提交到进程池执行</span></span><br><span class="line"><span class="comment">#     #     f=pool_p.submit(task,n=i)</span></span><br><span class="line"><span class="comment">#     #     ll.append(f)</span></span><br><span class="line"><span class="comment">#     #</span></span><br><span class="line"><span class="comment">#     # # 等待所有子进程执行完成，主进程在执行</span></span><br><span class="line"><span class="comment">#     # pool_p.shutdown()</span></span><br><span class="line"><span class="comment">#     #</span></span><br><span class="line"><span class="comment">#     # for l in ll:</span></span><br><span class="line"><span class="comment">#     #     res=l.result()  # 取到当前进程执行任务的返回值</span></span><br><span class="line"><span class="comment">#     #     print(res)</span></span><br><span class="line"><span class="comment">#     #</span></span><br><span class="line"><span class="comment">#     # print(&#x27;我是主进程&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # map取代for循环的，第一个参数是要执行的任务，第二个参数，是一个可迭代对象，迭代一次的结果，会传给任务</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     #   for i in range(10):</span></span><br><span class="line"><span class="comment">#     #     f=pool_p.submit(task,n=i)</span></span><br><span class="line"><span class="comment">#     # 等同于上面</span></span><br><span class="line"><span class="comment">#     # pool_p.map(task,range(10))</span></span><br><span class="line"><span class="comment">#     # pool_p.shutdown()</span></span><br><span class="line"><span class="comment">#     # print(&#x27;主进程&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     ## 回调</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         pool_p.submit(task,n=i).add_done_callback()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(os.getpid(), <span class="string">&#x27;开始执行了&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">result</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(result.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     pool_p = ProcessPoolExecutor(3)</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         pool_p.submit(task, n=i).add_done_callback(callback)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">submit</span></span><br><span class="line"><span class="string">shutdown</span></span><br><span class="line"><span class="string">result</span></span><br><span class="line"><span class="string">map(了解)</span></span><br><span class="line"><span class="string">add_done_callback：回调</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool_p = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool_p.submit(task, n=i).add_done_callback(callback)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 协程是：程序级别的切换，单线程下实现并发</span><br><span class="line">python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</span><br><span class="line">单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</span><br></pre></td></tr></table></figure>

<h3 id="greenlet模块（保存状态加切换）"><a href="#greenlet模块（保存状态加切换）" class="headerlink" title="greenlet模块（保存状态加切换）"></a>greenlet模块（保存状态加切换）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装第三方模块：在命令行下</span></span><br><span class="line"><span class="comment"># pip3 install greenlet</span></span><br><span class="line"><span class="comment"># pip3 uninstall greenlet  卸载第三方模块</span></span><br><span class="line"><span class="comment"># pip3 list   # 列出当前解释器环境下安装的第三方模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&#x27;在吃了一口&#x27;</span>)</span><br><span class="line">    g2.switch(name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&#x27;在吃了第二口&#x27;</span>)</span><br><span class="line">    g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;玩了一下&#x27;</span>)</span><br><span class="line">    g1.switch()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;玩了第二下&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1=greenlet(eat)</span><br><span class="line">g2=greenlet(play)</span><br><span class="line"></span><br><span class="line">g1.switch(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 写两个task，一个计算从1+1w，另一个计算从1乘以到1w，统计一下，切换执行时间快还是不切换快</span></span><br></pre></td></tr></table></figure>

<h3 id="event模块"><a href="#event模块" class="headerlink" title="event模块"></a>event模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## gevent模块，协程模块，遇到io可以自动切换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pip3 install gevent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># def eat(name):</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;在吃了一口&#x27;)</span></span><br><span class="line"><span class="comment">#     # 遇到了io</span></span><br><span class="line"><span class="comment">#     gevent.sleep(2)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;在吃了第二口&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def play(name):</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;玩了一下&#x27;)</span></span><br><span class="line"><span class="comment">#     # 遇到了io，是gevent的io</span></span><br><span class="line"><span class="comment">#     gevent.sleep(3)</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;玩了第二下&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># res1 = gevent.spawn(eat, &#x27;egon&#x27;)</span></span><br><span class="line"><span class="comment"># res2 = gevent.spawn(play, &#x27;egon&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ctime=time.time()</span></span><br><span class="line"><span class="comment"># # res1.join()</span></span><br><span class="line"><span class="comment"># # res2.join()  # 等地任务执行完成再执行下面那句</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># gevent.joinall([res1,res2])   # 相当于上面那两句</span></span><br><span class="line"><span class="comment"># print(&#x27;主线程&#x27;)</span></span><br><span class="line"><span class="comment"># print(time.time()-ctime)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###使用原来的time的io，不会切，并且变成了串行</span></span><br><span class="line"><span class="comment"># def eat(name):</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;在吃了一口&#x27;)</span></span><br><span class="line"><span class="comment">#     time.sleep(2)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;在吃了第二口&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def play(name):</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;玩了一下&#x27;)</span></span><br><span class="line"><span class="comment">#     time.sleep(3)</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;玩了第二下&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># res1 = gevent.spawn(eat, &#x27;egon&#x27;)</span></span><br><span class="line"><span class="comment"># res2 = gevent.spawn(play, &#x27;egon&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ctime=time.time()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># gevent.joinall([res1,res2])   # 相当于上面那两句</span></span><br><span class="line"><span class="comment"># print(&#x27;主线程&#x27;)</span></span><br><span class="line"><span class="comment"># print(time.time()-ctime)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### time的io也要切换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猴子补丁：把原来的io全都替换成gevent的io</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;在吃了一口&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;在吃了第二口&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;玩了一下&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;玩了第二下&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res1 = gevent.spawn(eat, <span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">res2 = gevent.spawn(play, <span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctime=time.time()</span><br><span class="line"></span><br><span class="line">gevent.joinall([res1,res2])   <span class="comment"># 相当于上面那两句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(time.time()-ctime)</span><br></pre></td></tr></table></figure>

<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 内置模块   python 3.4 推出这个模块，python作者主导的</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 这个函数是协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    res=threading.current_thread().getName()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;协程执行完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    res=threading.current_thread().getName()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2222&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;222协程执行完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctime=time.time()</span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks=[task(),task2()]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line"><span class="built_in">print</span>(time.time()-ctime)</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">左大大</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
