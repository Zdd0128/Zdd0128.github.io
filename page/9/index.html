<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="左大大的博客">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="左大大的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="左大大">
<meta property="article:tag" content="Python Linux Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>左大大的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">左大大的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="左大大"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">左大大</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-20 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-20T17:27:55+08:00">2018-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h3 id="一-客户端-服务器架构"><a href="#一-客户端-服务器架构" class="headerlink" title="一 客户端/服务器架构"></a>一 客户端/服务器架构</h3><p>1.硬件C/S架构(打印机)</p>
<p>2.软件C/S架构</p>
<p><em>互联网中处处是C/S架构</em></p>
<p><em>如黄色网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种）</em></p>
<p><em>腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）</em></p>
<p>C/S架构与socket的关系：</p>
<p><em>我们学习socket就是为了完成C/S架构的开发</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学习网络编程的目的是为了开发一个CS架构或者BS架构的软件</span><br><span class="line">    Client------------网络------------------Server</span><br><span class="line">    Browser-----------网络------------------Server</span><br></pre></td></tr></table></figure>

<h3 id="二-osi七层"><a href="#二-osi七层" class="headerlink" title="二 osi七层"></a>二 osi七层</h3><p><strong>引子：</strong></p>
<p><em>须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</em></p>
<p><em>如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</em></p>
<p><em>互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语</em></p>
<p><em>如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</em></p>
<p><em>人们按照分工不同把互联网协议从逻辑上划分了层级，</em></p>
<p><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p>
<p><strong>为何学习socket一定要先学习互联网协议：</strong></p>
<p><em>1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件</em></p>
<p><em>2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的</em></p>
<p><em>3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。</em></p>
<p><em>4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅</em></p>
<p><img src="https://pic4.zhimg.com/80/v2-3f2ab5646d1bbca993e920c8ae27f40f_720w.jpg" alt="img"></p>
<h4 id="2-1osi七层，tcp-ip-5层"><a href="#2-1osi七层，tcp-ip-5层" class="headerlink" title="2.1osi七层，tcp/ip 5层"></a>2.1osi七层，tcp/ip 5层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 cs架构和bs架构</span><br><span class="line">2 互联网</span><br><span class="line">3 osi七层、5层（5层名字记住：重点）</span><br><span class="line">	-物理层</span><br><span class="line">    	-网线，光纤</span><br><span class="line">    -数据链路层</span><br><span class="line">    	-网卡</span><br><span class="line">    -网络层</span><br><span class="line">    	-路由器</span><br><span class="line">    -传输层（运输层）</span><br><span class="line">    	-四层路由器</span><br><span class="line">    -应用层(会话层，表示层，应用层)</span><br><span class="line">    	-http协议，ftp协议，websocket协议。。。</span><br></pre></td></tr></table></figure>

<h4 id="2-2每一层功能"><a href="#2-2每一层功能" class="headerlink" title="2.2每一层功能"></a>2.2每一层功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1 物理层</span><br><span class="line">	-网线----》01010101电信号---》从网线中传输电信号</span><br><span class="line">    -8个比特位是一个字节</span><br><span class="line">2 数据链路层</span><br><span class="line">	-数据帧：一组电信号是一个数据帧，有头和数据部分</span><br><span class="line">	-网卡---》mac地址---》全球唯一---》网卡出厂--》烧在了网卡上</span><br><span class="line">    -48位二进制---》看到的都是16进制表示</span><br><span class="line">    -广播：</span><br><span class="line">   		-局域网内通信，所有人都会接受到，通过mac地址确定给谁的数据报，如果不是自己的就不处理</span><br><span class="line">    -广播风暴</span><br><span class="line"> 3 网络层</span><br><span class="line">	-跨局域网通信，需要经过网络层</span><br><span class="line">    -IP地址：0.0.0.0-255.255.255.255</span><br><span class="line">    -子网掩码：</span><br><span class="line">    -192.168.1.1  255.255.255.0</span><br><span class="line">    -192.168.2.1  255.255.255.0</span><br><span class="line">    -ARP：ip和mac的对照表</span><br><span class="line">    </span><br><span class="line"> 4 传输层：</span><br><span class="line">	-端口：0--65535，一个应用程序可以监听多个端口，但是一个端口只能属于一个应用程序</span><br><span class="line">    -TCP协议：可靠传输（可靠传输如何保证？三次握手，四次挥手）</span><br><span class="line">    -UDP协议：不可靠传输</span><br><span class="line">5 应用层</span><br><span class="line">	-htpp，ftp，websocket....</span><br></pre></td></tr></table></figure>

<h4 id="2-3常用端口号"><a href="#2-3常用端口号" class="headerlink" title="2.3常用端口号"></a>2.3常用端口号</h4><table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td><strong>TCP</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>DNS:把网址转换成ip地址</p>
<p>从浏览器发送出去的数据，都是http协议，默认是80端口</p>
</blockquote>
<h4 id="2-4Tcp三次握手四次挥手（面试题）"><a href="#2-4Tcp三次握手四次挥手（面试题）" class="headerlink" title="2.4Tcp三次握手四次挥手（面试题）"></a>2.4Tcp三次握手四次挥手（面试题）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> tcp可靠传输：三次握手，四次挥手保证数据可靠</span><br><span class="line"><span class="number">2</span> 三次握手</span><br><span class="line">	-客户端向服务端发送链接请求  </span><br><span class="line">    -服务端回复可以建立，并且带着跟客户端建立链接的数据报  </span><br><span class="line">    -客户端收到后，链接建好了    </span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> 这个过程后就可以可靠传输数据</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 断开链接（<span class="number">4</span>四挥手）</span><br><span class="line">	-客户端告诉服务端，要断开   </span><br><span class="line">    -服务端收到，回复ok        </span><br><span class="line">    -服务端可能还有数据在传递，暂时还没断开---等数据传完</span><br><span class="line">    -服务端告诉客户端，我要断了  </span><br><span class="line">    -客户端收到，回复ok        </span><br></pre></td></tr></table></figure>

<h3 id="三-socket层"><a href="#三-socket层" class="headerlink" title="三 socket层"></a>三 socket层</h3><p>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a4a1fd105e5e7af5d7db820b303ad7e2_720w.jpg" alt="img"></p>
<h3 id="四-socket是什么"><a href="#四-socket是什么" class="headerlink" title="四 socket是什么"></a>四 socket是什么</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Socket抽象层,从osi七层抽象出来的，抽象了网络层和传输层，跟语言无关，任何语言都会有socket的封装</span><br><span class="line">2 专门给开发人员用的</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序</span><br><span class="line"></span><br><span class="line">而程序的pid是同一台机器上不同进程或者线程的标识</span><br></pre></td></tr></table></figure>

<h3 id="五-套接字发展史及分类"><a href="#五-套接字发展史及分类" class="headerlink" title="五 套接字发展史及分类"></a>五 套接字发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p>
<p>*<strong>基于文件类型的套接字家族*</strong></p>
<p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p>*<strong>基于网络类型的套接字家族*</strong></p>
<p>套接字家族的名字：AF_INET</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="六-套接字工作流程"><a href="#六-套接字工作流程" class="headerlink" title="六 套接字工作流程"></a>六 套接字工作流程</h3><p> 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。</p>
<p><img src="https://pic1.zhimg.com/80/v2-7d4ff6c59a5201bac25926b792826a40_720w.jpg" alt="img"></p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>
<p>socket()模块函数用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(socket_family,socket_type,protocal=<span class="number">0</span>)</span><br><span class="line">socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">获取tcp/ip套接字</span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"> </span><br><span class="line">获取udp/ip套接字</span><br><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"> </span><br><span class="line">由于 socket 模块中有太多的属性。我们在这里破例使用了<span class="string">&#x27;from module import *&#x27;</span>语句。使用 <span class="string">&#x27;from socket import *&#x27;</span>,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。</span><br><span class="line"></span><br><span class="line">例如tcpSock = socket(AF_INET, SOCK_STREAM</span><br></pre></td></tr></table></figure>

<p><em><strong>服务端套接字函数</strong></em><br>        s.bind() 绑定(主机,端口号)到套接字<br>        s.listen() 开始TCP监听<br>        s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来</p>
<p><em><strong>客户端套接字函数</strong></em><br>        s.connect() 主动初始化TCP服务器连接<br>        s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</p>
<p><em><strong>公共用途的套接字函数</strong></em><br>        s.recv() 接收TCP数据<br>        s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)<br>        s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)<br>        s.recvfrom() 接收UDP数据<br>        s.sendto() 发送UDP数据<br>        s.getpeername() 连接到当前套接字的远端的地址<br>        s.getsockname() 当前套接字的地址<br>        s.getsockopt() 返回指定套接字的参数<br>        s.setsockopt() 设置指定套接字的参数<br>        s.close() 关闭套接字</p>
<p><em><strong>面向锁的套接字方法</strong></em><br>        s.setblocking() 设置套接字的阻塞与非阻塞模式<br>        s.settimeout() 设置阻塞套接字操作的超时时间<br>        s.gettimeout() 得到阻塞套接字操作的超时时间</p>
<p><em><strong>面向文件的套接字的函数</strong></em><br>        s.fileno() 套接字的文件描述符<br>        s.makefile() 创建一个与该套接字相关的文件</p>
<h3 id="七-基于TCP的套接字"><a href="#七-基于TCP的套接字" class="headerlink" title="七 基于TCP的套接字"></a>七 基于TCP的套接字</h3><p><strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</strong></p>
<p><strong>tcp服务端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ss = socket() <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()      <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">ss.listen()      <span class="comment">#监听链接</span></span><br><span class="line">inf_loop:      <span class="comment">#服务器无限循环</span></span><br><span class="line">     cs = ss.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">     comm_loop:         <span class="comment">#通讯循环</span></span><br><span class="line">         cs.recv()/cs.send() <span class="comment">#对话(接收与发送)</span></span><br><span class="line">     cs.close()    <span class="comment">#关闭客户端套接字</span></span><br><span class="line">ss.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>tcp客户端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()    <span class="comment"># 创建客户套接字</span></span><br><span class="line">cs.connect()    <span class="comment"># 尝试连接服务器</span></span><br><span class="line">comm_loop:        <span class="comment"># 通讯循环</span></span><br><span class="line">     cs.send()/cs.recv()    <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()            <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p>socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信</p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)  <span class="comment">#电话卡</span></span><br><span class="line">BUFSIZE=<span class="number">1024</span>                <span class="comment">#收发消息的尺寸</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="comment">#买手机</span></span><br><span class="line">s.bind(ip_port) <span class="comment">#手机插卡</span></span><br><span class="line">s.listen(<span class="number">5</span>)     <span class="comment">#手机待机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=s.accept()            <span class="comment">#手机接电话</span></span><br><span class="line"><span class="comment"># print(conn)</span></span><br><span class="line"><span class="comment"># print(addr)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;接到来自%s的电话&#x27;</span> %addr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">msg=conn.recv(BUFSIZE)             <span class="comment">#听消息,听话</span></span><br><span class="line"><span class="built_in">print</span>(msg,<span class="built_in">type</span>(msg))</span><br><span class="line"></span><br><span class="line">conn.send(msg.upper())          <span class="comment">#发消息,说话</span></span><br><span class="line"></span><br><span class="line">conn.close()                    <span class="comment">#挂电话</span></span><br><span class="line"></span><br><span class="line">s.close()                       <span class="comment">#手机关机</span></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)   <span class="comment">#拨电话</span></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;linhaifeng nb&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))     <span class="comment">#发消息,说话(只能发送字节类型)</span></span><br><span class="line"></span><br><span class="line">feedback=s.recv(BUFSIZE)      <span class="comment">#收消息,听话</span></span><br><span class="line"><span class="built_in">print</span>(feedback.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">s.close()        <span class="comment">#挂电话</span></span><br></pre></td></tr></table></figure>

<p>加上链接循环与通信循环</p>
<p>服务端改进版:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)<span class="comment">#电话卡</span></span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="comment">#买手机</span></span><br><span class="line">s.bind(ip_port) <span class="comment">#手机插卡</span></span><br><span class="line">s.listen(<span class="number">5</span>)     <span class="comment">#手机待机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:         <span class="comment">#新增接收链接循环,可以不停的接电话</span></span><br><span class="line">    conn,addr=s.accept()            <span class="comment">#手机接电话</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;接到来自%s的电话&#x27;</span> %addr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:                         <span class="comment">#新增通信循环,可以不断的通信,收发消息</span></span><br><span class="line">        msg=conn.recv(BUFSIZE)             <span class="comment">#听消息,听话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if len(msg) == 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(msg,<span class="built_in">type</span>(msg))</span><br><span class="line"></span><br><span class="line">        conn.send(msg.upper())          <span class="comment">#发消息,说话</span></span><br><span class="line"></span><br><span class="line">    conn.close()                    <span class="comment">#挂电话</span></span><br><span class="line"></span><br><span class="line">s.close()                       <span class="comment">#手机关机</span></span><br></pre></td></tr></table></figure>

<p>客户端改进版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)     <span class="comment">#拨电话</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:     <span class="comment">#新增通信循环,客户端可以不断发收消息</span></span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))   <span class="comment">#发消息,说话(只能发送字节类型)</span></span><br><span class="line"></span><br><span class="line">    feedback=s.recv(BUFSIZE)           <span class="comment">#收消息,听话</span></span><br><span class="line">    <span class="built_in">print</span>(feedback.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">s.close()          <span class="comment">#挂电话</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>重启服务端时可能会遇到</p>
<p><img src="https://pic2.zhimg.com/80/v2-aeeffa09a60bc1037ae69a2856cf8941_720w.png" alt="img"></p>
<p>这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）</p>
<p>解决方法：</p>
<p>方法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入一条socket配置，重用ip和端口</span></span><br><span class="line"></span><br><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，</span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">编辑文件，加入以下内容：</span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">然后执行 /sbin/sysctl -p 让参数生效。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="number">0</span>，表示关闭。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

<h3 id="八-基于UDP的套接字"><a href="#八-基于UDP的套接字" class="headerlink" title="八 基于UDP的套接字"></a>八 基于UDP的套接字</h3><p><strong>udp是无链接的，先启动哪一端都不会报错</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ss = socket()   <span class="comment">#创建一个服务器的套接字</span></span><br><span class="line"><span class="number">2</span> ss.bind()       <span class="comment">#绑定服务器套接字</span></span><br><span class="line"><span class="number">3</span> inf_loop:       <span class="comment">#服务器无限循环</span></span><br><span class="line"><span class="number">4</span>     cs = ss.recvfrom()/ss.sendto() <span class="comment"># 对话(接收与发送)</span></span><br><span class="line"><span class="number">5</span> ss.close()                         <span class="comment"># 关闭服务器套接字</span></span><br></pre></td></tr></table></figure>

<p>udp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()   <span class="comment"># 创建客户套接字</span></span><br><span class="line">comm_loop:      <span class="comment"># 通讯循环</span></span><br><span class="line">    cs.sendto()/cs.recvfrom()   <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()                      <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>udp套接字简单示例</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    <span class="built_in">print</span>(msg,addr)</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br></pre></td></tr></table></figure>

<p>udp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    <span class="built_in">print</span>(back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br></pre></td></tr></table></figure>

<p><strong>qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)</span><br><span class="line">udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) <span class="comment">#买手机</span></span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_msg,addr=udp_server_sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],qq_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    back_msg=<span class="built_in">input</span>(<span class="string">&#x27;回复消息: &#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br></pre></td></tr></table></figure>

<p>udp客户端1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">&#x27;狗哥alex&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;瞎驴&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;一棵树&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;武大郎&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=<span class="built_in">input</span>(<span class="string">&#x27;请选择聊天对象: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入消息,回车发送: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<p>udp客户端2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">&#x27;狗哥alex&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;瞎驴&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;一棵树&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;武大郎&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=<span class="built_in">input</span>(<span class="string">&#x27;请选择聊天对象: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入消息,回车发送: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<p>服务端运行结果</p>
<p><img src="https://pic3.zhimg.com/80/v2-b8475dd2de46da061d4f507bc2414206_720w.jpg" alt="img"></p>
<p>客户端1运行结果</p>
<p><img src="https://pic1.zhimg.com/80/v2-7fa4072d1b9ed772c81fe72b20497eec_720w.jpg" alt="img"></p>
<p>客户端2运行结果</p>
<p><img src="https://pic2.zhimg.com/80/v2-c70ea48a4774814cbc6d58657b811539_720w.jpg" alt="img"></p>
<p><strong>时间服务器</strong></p>
<p>ntp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg,addr=tcp_server.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===&gt;&#x27;</span>,msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        time_fmt=<span class="string">&#x27;%Y-%m-%d %X&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_fmt=msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    back_msg=strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>

<p>ntp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入时间格式(例%Y %m %d)&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line">    data=tcp_client.recv(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">tcp_client.close()</span><br></pre></td></tr></table></figure>

<h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）</p>
<p><strong>注意注意注意：</strong></p>
<p>res=subprocess.Popen(cmd.decode(‘utf-8’), shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)</p>
<p>的结果的编码是以当前所在的系统为准的，如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p>
<p><strong>且只能从管道里读一次结果</strong></p>
<p>注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=tcp_socket_server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端&#x27;</span>,addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,</span><br><span class="line">                         stdout=subprocess.PIPE,</span><br><span class="line">                         stdin=subprocess.PIPE,</span><br><span class="line">                         stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr=act_res.stderr.read()</span><br><span class="line">        stdout=act_res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    act_res=s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(act_res.decode(<span class="string">&#x27;utf-8&#x27;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于tcp的socket，在运行时会发生粘包</p>
<p>让我们再基于udp制作一个远程执行命令的程序</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9003</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#收消息</span></span><br><span class="line">    cmd,addr=udp_server.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;用户命令-----&gt;&#x27;</span>,cmd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#逻辑处理</span></span><br><span class="line">    res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)</span><br><span class="line">    stderr=res.stderr.read()</span><br><span class="line">    stdout=res.stdout.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#发消息</span></span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9003</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    data,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于udp的socket，在运行时永远不会发生粘包</p>
<h3 id="十-什么是粘包"><a href="#十-什么是粘包" class="headerlink" title="十 什么是粘包"></a>十 什么是粘包</h3><p>须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来</p>
<p>首先需要掌握一个socket收发消息的原理</p>
<p><img src="https://pic4.zhimg.com/80/v2-5e9568f888a55cd273aca6f561cea2d7_720w.jpg" alt="img"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。</p>
<p>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p>
<p>此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">算法</a>把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li>
<li><strong>tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略</strong></li>
</ol>
<p>udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠</p>
<p>tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</p>
<p>*<strong>两种情况下会发生粘包。*</strong></p>
<p>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">10</span>)</span><br><span class="line">data2=conn.recv(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.send(<span class="string">&#x27;feng&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">2</span>) <span class="comment">#一次没有收完整</span></span><br><span class="line">data2=conn.recv(<span class="number">10</span>)<span class="comment">#下次收的时候,会先取旧的数据,然后取新的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;hello feng&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>*<strong>拆包的发生情况*</strong></p>
<p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。</p>
<p>*<strong>补充问题一：为何tcp是可靠传输，udp是不可靠传输*</strong></p>
<p>基于tcp的数据传输请参考我的另一篇文章<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">http://www.cnblogs.com/linhaifeng/articles/5937962.html</a>，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的</p>
<p>而udp发送数据，对端是不会返回确认信息的，因此不可靠</p>
<p>*<strong>补充问题二：send(字节流)和recv(1024)及sendall*</strong></p>
<p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据</p>
<p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失</p>
<h3 id="十一-解决粘包的low比处理方法"><a href="#十一-解决粘包的low比处理方法" class="headerlink" title="十一 解决粘包的low比处理方法"></a>十一 解决粘包的low比处理方法</h3><p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据</p>
<p>low版本的解决方法</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,subprocess</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s.bind(ip_port)</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=s.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端&#x27;</span>,addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">break</span></span><br><span class="line">        res=subprocess.Popen(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,\</span><br><span class="line">                            stdin=subprocess.PIPE,\</span><br><span class="line">                         stderr=subprocess.PIPE,\</span><br><span class="line">                         stdout=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            ret=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret=res.stdout.read()</span><br><span class="line">        data_length=<span class="built_in">len</span>(ret)</span><br><span class="line">        conn.send(<span class="built_in">str</span>(data_length).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;recv_ready&#x27;</span>:</span><br><span class="line">            conn.sendall(ret)</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,time</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    length=<span class="built_in">int</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    s.send(<span class="string">&#x27;recv_ready&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    send_size=<span class="number">0</span></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; length:</span><br><span class="line">        data+=s.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=<span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>为何low：</p>
<p>程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</p>
<h3 id="十二-峰哥解决粘包的方法"><a href="#十二-峰哥解决粘包的方法" class="headerlink" title="十二 峰哥解决粘包的方法"></a>十二 峰哥解决粘包的方法</h3><p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p>
<p><strong>struct模块</strong></p>
<p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<p>&gt;&gt;&gt; struct.pack(‘i’,1111111111111)</p>
<p>。。。。。。。。。</p>
<p>struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</p>
<p><img src="https://pic2.zhimg.com/80/v2-d7c66c9a0abe12041ae948a553b908c9_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json,struct</span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line">header=&#123;<span class="string">&#x27;file_size&#x27;</span>:<span class="number">1073741824000</span>,<span class="string">&#x27;file_name&#x27;</span>:<span class="string">&#x27;/a/b/c/d/e/a.txt&#x27;</span>,<span class="string">&#x27;md5&#x27;</span>:<span class="string">&#x27;8f6fbf8347faa4924a76856701edb0f3&#x27;</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=<span class="built_in">bytes</span>(json.dumps(header),encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#序列化并转成bytes,用于传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">&#x27;i&#x27;</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">&#x27;file_size&#x27;</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>

<p>关于struct的详细用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">values1 = (<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="number">2.7</span>)</span><br><span class="line">values2 = (<span class="string">&#x27;defg&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">101</span>)</span><br><span class="line">s1 = struct.Struct(<span class="string">&#x27;I3sf&#x27;</span>)</span><br><span class="line">s2 = struct.Struct(<span class="string">&#x27;4sI&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before : &#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="comment"># t=binascii.hexlify(&#x27;asdfaf&#x27;.encode(&#x27;utf-8&#x27;))</span></span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,<span class="number">0</span>,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After pack&#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="built_in">print</span>(s1.unpack_from(prebuffer,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(<span class="string">&#x27;ii&#x27;</span>)</span><br><span class="line">s3.pack_into(prebuffer,<span class="number">0</span>,<span class="number">123</span>,<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After pack&#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="built_in">print</span>(s3.unpack_from(prebuffer,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>服务端（自定制报头）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cmd: %s&#x27;</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(back_msg))) <span class="comment">#先发back_msg的长度</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端（自定制报头）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,time,struct</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l=s.recv(<span class="number">4</span>)</span><br><span class="line">    x=struct.unpack(<span class="string">&#x27;i&#x27;</span>,l)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(x),x)</span><br><span class="line">    <span class="comment"># print(struct.unpack(&#x27;I&#x27;,l))</span></span><br><span class="line">    r_s=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> r_s &lt; x:</span><br><span class="line">        r_d=s.recv(<span class="number">1024</span>)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=<span class="built_in">len</span>(r_d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.decode(&#x27;utf-8&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;gbk&#x27;</span>)) <span class="comment">#windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<p>发送时：</p>
<p>先发报头长度</p>
<p>再编码报头内容然后发送</p>
<p>最后发真实内容</p>
<p>接收时：</p>
<p>先手报头长度，用struct取出来</p>
<p>根据取出的长度收取报头内容，然后解码，反序列化</p>
<p>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p>
<p>服务端：定制稍微复杂一点的报头</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cmd: %s&#x27;</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">&#x27;data_size&#x27;</span>:<span class="built_in">len</span>(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))) <span class="comment">#先发报头的长度</span></span><br><span class="line">        conn.send(head_json_bytes) <span class="comment">#再发报头</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,json</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(<span class="built_in">bytes</span>(cmd,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">&#x27;i&#x27;</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data_len=head_json[<span class="string">&#x27;data_size&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=<span class="built_in">len</span>(recv_data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(recv_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">#print(recv_data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<p>FTP作业：上传下载文件</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPServer</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    server_dir=<span class="string">&#x27;file_upload&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, bind_and_activate=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.server_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_bind</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called by constructor to bind the socket.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.allow_reuse_address:</span><br><span class="line">            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        self.socket.bind(self.server_address)</span><br><span class="line">        self.server_address = self.socket.getsockname()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_activate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called by constructor to activate the server.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called to clean-up the server.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get the request and client address from the socket.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.socket.accept()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span></span><br><span class="line">        request.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.conn,self.client_addr=self.get_request()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;from client &#x27;</span>,self.client_addr)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    head_struct = self.conn.recv(<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> head_struct:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    head_len = struct.unpack(<span class="string">&#x27;i&#x27;</span>, head_struct)[<span class="number">0</span>]</span><br><span class="line">                    head_json = self.conn.recv(head_len).decode(self.coding)</span><br><span class="line">                    head_dic = json.loads(head_json)</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">print</span>(head_dic)</span><br><span class="line">                    <span class="comment">#head_dic=&#123;&#x27;cmd&#x27;:&#x27;put&#x27;,&#x27;filename&#x27;:&#x27;a.txt&#x27;,&#x27;filesize&#x27;:123123&#125;</span></span><br><span class="line">                    cmd=head_dic[<span class="string">&#x27;cmd&#x27;</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                        func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                        func(head_dic)</span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        file_path=os.path.normpath(os.path.join(</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize=args[<span class="string">&#x27;filesize&#x27;</span>]</span><br><span class="line">        recv_size=<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,file_path)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> recv_size &lt; filesize:</span><br><span class="line">                recv_data=self.conn.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size+=<span class="built_in">len</span>(recv_data)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;recvsize:%s filesize:%s&#x27;</span> %(recv_size,filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpserver1=MYTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">tcpserver1.run()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPClient</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, connect=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> connect:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.client_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            inp=<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inp:<span class="keyword">continue</span></span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        cmd=args[<span class="number">0</span>]</span><br><span class="line">        filename=args[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;file:%s is not exists&#x27;</span> %filename)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;<span class="string">&#x27;cmd&#x27;</span>:cmd,<span class="string">&#x27;filename&#x27;</span>:os.path.basename(filename),<span class="string">&#x27;filesize&#x27;</span>:filesize&#125;</span><br><span class="line">        <span class="built_in">print</span>(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=<span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=<span class="built_in">len</span>(line)</span><br><span class="line">                <span class="built_in">print</span>(send_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;upload successful&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>

<h3 id="十三-认证客户端的链接合法性"><a href="#十三-认证客户端的链接合法性" class="headerlink" title="十三 认证客户端的链接合法性"></a>十三 认证客户端的链接合法性</h3><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    认证客户端链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始验证新链接的合法性&#x27;</span>)</span><br><span class="line">    msg=os.urandom(<span class="number">32</span>)</span><br><span class="line">    conn.sendall(msg)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    respone=conn.recv(<span class="built_in">len</span>(digest))</span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(respone,digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_handler</span>(<span class="params">conn,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> conn_auth(conn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;该链接不合法,关闭&#x27;</span>)</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;链接合法,开始通信&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=conn.recv(bufsize)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">break</span></span><br><span class="line">        conn.sendall(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_handler</span>(<span class="params">ip_port,bufsize,backlog=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    只处理链接</span></span><br><span class="line"><span class="string">    :param ip_port:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_server.bind(ip_port)</span><br><span class="line">    tcp_socket_server.listen(backlog)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=tcp_socket_server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;新连接[%s:%s]&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">        data_handler(conn,bufsize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    server_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(合法)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(非法:不知道加密方式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(非法:不知道secret_key)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang1111&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<h3 id="十四-socketserver实现并发"><a href="#十四-socketserver实现并发" class="headerlink" title="十四 socketserver实现并发"></a>十四 socketserver实现并发</h3><p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p>
<p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p>
<p>server类：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8888d725cb767594afe03b558814ba28_720w.jpg" alt="img"></p>
<p>request类：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d39565c190e7edc28f8cf8be1bf981f9_720w.jpg" alt="img"></p>
<p>继承关系:</p>
<p><img src="https://pic1.zhimg.com/80/v2-16fcc2d93beebe3f1739951dc5d80114_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-154c5cb9cc464fac3e81703938479446_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-43cec3a3b133fd33c4d4db33af86807a_720w.jpg" alt="img"></p>
<p>以下述代码为例，分析socketserver源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftpserver=socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p>
<ol>
<li>实例化得到ftpserver，先找类ThreadingTCPServer的<strong>init</strong>,在TCPServer中找到，进而执行server_bind,server_active</li>
<li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li>
<li>执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li>
<li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li>
<li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找<strong>init</strong>方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li>
</ol>
<p>源码分析总结：</p>
<p>基于tcp的socketserver我们自己定义的类中的</p>
<ol>
<li>self.server即套接字对象</li>
<li>self.request即一个链接</li>
<li>self.client_address即客户端地址</li>
</ol>
<p>基于udp的socketserver我们自己定义的类中的</p>
<ol>
<li>self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, )</li>
<li>self.client_address即客户端地址</li>
</ol>
<p>FtpServer</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FtpServer</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    server_dir=<span class="string">&#x27;file_upload&#x27;</span></span><br><span class="line">    max_packet_size=<span class="number">1024</span></span><br><span class="line">    BASE_DIR=os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.request)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=self.request.recv(<span class="number">4</span>)</span><br><span class="line">            data_len=struct.unpack(<span class="string">&#x27;i&#x27;</span>,data)[<span class="number">0</span>]</span><br><span class="line">            head_json=self.request.recv(data_len).decode(self.coding)</span><br><span class="line">            head_dic=json.loads(head_json)</span><br><span class="line">            <span class="comment"># print(head_dic)</span></span><br><span class="line">            cmd=head_dic[<span class="string">&#x27;cmd&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(head_dic)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        file_path = os.path.normpath(os.path.join(</span><br><span class="line">            self.BASE_DIR,</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize = args[<span class="string">&#x27;filesize&#x27;</span>]</span><br><span class="line">        recv_size = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>, file_path)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> recv_size &lt; filesize:</span><br><span class="line">                recv_data = self.request.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size += <span class="built_in">len</span>(recv_data)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;recvsize:%s filesize:%s&#x27;</span> % (recv_size, filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftpserver=socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<p>FtpClient</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPClient</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, connect=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> connect:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.client_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            inp=<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inp:<span class="keyword">continue</span></span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        cmd=args[<span class="number">0</span>]</span><br><span class="line">        filename=args[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;file:%s is not exists&#x27;</span> %filename)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;<span class="string">&#x27;cmd&#x27;</span>:cmd,<span class="string">&#x27;filename&#x27;</span>:os.path.basename(filename),<span class="string">&#x27;filesize&#x27;</span>:filesize&#125;</span><br><span class="line">        <span class="built_in">print</span>(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=<span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=<span class="built_in">len</span>(line)</span><br><span class="line">                <span class="built_in">print</span>(send_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;upload successful&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/07/%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/07/%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-07 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-07T17:27:55+08:00">2018-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="一-模块介绍"><a href="#一-模块介绍" class="headerlink" title="一. 模块介绍"></a>一. 模块介绍</h2><p>在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。如果把开发程序比喻成制造一台电脑，编写模块就像是在制造电脑的零部件，准备好零部件后，剩下的工作就是按照逻辑把它们组装到一起。</p>
<p>将程序模块化会使得程序的组织结构清晰，维护起来更加方便。比起直接开发一个完整的程序，单独开发一个小的模块也会更加简单，并且程序中的模块与电脑中的零部件稍微不同的是：程序中的模块可以被重复使用。所以总结下来，使用模块既保证了代码的重用性，又增强了程序的结构性和可维护性。另外除了自定义模块外，我们还可以导入使用内置或第三方模块提供的现成功能，这种“拿来主义”极大地提高了程序员的开发效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1、什么是模块?</span><br><span class="line">    模块就是一系列功能的集合体</span><br><span class="line"></span><br><span class="line">    模块分为四种类别：</span><br><span class="line">        1、一个py文件就可以是一个模块</span><br><span class="line">        2、包：就是一个存放有__init__.py文件的文件夹</span><br><span class="line"></span><br><span class="line">        3、使用C编写并链接到python解释器的内置模块</span><br><span class="line">        4、已被编译为共享库或DLL的C或C++扩展</span><br><span class="line"></span><br><span class="line">    模块有三种来源</span><br><span class="line">        1、python解释器自带的</span><br><span class="line">            内置的</span><br><span class="line">            标准库</span><br><span class="line"></span><br><span class="line">            import time  # 内置库</span><br><span class="line">            print(time)</span><br><span class="line">            import os  # 标准库</span><br><span class="line">            print(os)</span><br><span class="line"></span><br><span class="line">        2、第三方的库</span><br><span class="line"></span><br><span class="line">        3、自定义的库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、为何要用模块?</span><br><span class="line">    1、拿来主义，极大地提升开发效率</span><br><span class="line">    2、解决代码冗余问题</span><br></pre></td></tr></table></figure>

<h2 id="二-模块的使用"><a href="#二-模块的使用" class="headerlink" title="二 模块的使用"></a>二 模块的使用</h2><h4 id="2-1-import语句"><a href="#2-1-import语句" class="headerlink" title="2.1 import语句"></a>2.1 import语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要想在另外一个py文件中引用foo.py中的功能，需要使用import foo，首次导入模块会做三件事：</span><br><span class="line">	1、执行源文件代码</span><br><span class="line">	2、产生一个新的名称空间用于存放源文件执行过程中产生的名字</span><br><span class="line">	3、在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀</span><br></pre></td></tr></table></figure>

<p>如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="comment">#导入模块foo</span></span><br><span class="line">a=foo.x <span class="comment">#引用模块foo中变量x的值赋值给当前名称空间中的名字a</span></span><br><span class="line">foo.get() <span class="comment">#调用模块foo的get函数</span></span><br><span class="line">foo.change() <span class="comment">#调用模块foo中的change函数</span></span><br><span class="line">obj=foo.Foo() <span class="comment">#使用模块foo的类Foo来实例化，进一步可以执行obj.func()</span></span><br></pre></td></tr></table></figure>

<p>加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">强调:</span><br><span class="line">	第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名</span><br><span class="line">	</span><br><span class="line">注意:</span><br><span class="line">	1.在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。</span><br><span class="line">	2.模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。</span><br></pre></td></tr></table></figure>

<p>用import语句导入多个模块，可以写多行import语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">import</span> module2</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">import</span> moduleN</span><br></pre></td></tr></table></figure>

<p>还可以在一行导入，用逗号分隔开不同的模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1,module2,...,moduleN</span><br></pre></td></tr></table></figure>

<p>但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开，不同类别的导入顺序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. python内置模块</span></span><br><span class="line"><span class="comment">#2. 第三方模块</span></span><br><span class="line"><span class="comment">#3. 程序员自定义模块</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-from-import-语句"><a href="#2-2-from-import-语句" class="headerlink" title="2.2 from-import 语句"></a>2.2 from-import 语句</h4><p>from…import…与import语句基本一致，唯一不同的是：使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo import x,get,change,Foo则可以在当前执行文件中直接引用模块foo中的名字，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> x,get,change <span class="comment">#将模块foo中的x和get导入到当前名称空间</span></span><br><span class="line">a=x <span class="comment">#直接使用模块foo中的x赋值给a</span></span><br><span class="line">get() <span class="comment">#直接执行foo中的get函数</span></span><br><span class="line">change() <span class="comment">#即便是当前有重名的x，修改的仍然是源文件中的x</span></span><br></pre></td></tr></table></figure>

<p>无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</p>
<p>另外from语句支持from foo import <em>语法，</em>代表将foo中所有的名字都导入到当前位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字</span></span><br><span class="line"></span><br><span class="line">a=x</span><br><span class="line">get()</span><br><span class="line">change()</span><br><span class="line">obj=Foo()</span><br></pre></td></tr></table></figure>

<p>如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用<em>的方式导入，在函数内则非法，并且</em>的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">__all__=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;get&#x27;</span>] <span class="comment">#该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;from the func&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#此时的*只代表x和get</span></span><br><span class="line"></span><br><span class="line">x <span class="comment">#可用</span></span><br><span class="line">get() <span class="comment">#可用</span></span><br><span class="line">change() <span class="comment">#不可用</span></span><br><span class="line">Foo() <span class="comment">#不可用</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-其他导入语法-as"><a href="#2-3-其他导入语法-as" class="headerlink" title="2.3 其他导入语法(as)"></a>2.3 其他导入语法(as)</h4><p>我们还可以在当前位置为导入的模块起一个别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">as</span> f <span class="comment">#为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名f</span></span><br><span class="line">f.x</span><br><span class="line">f.get()</span><br></pre></td></tr></table></figure>

<p>还可以为导入的一个名字起别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> get <span class="keyword">as</span> get_x</span><br><span class="line">get_x()</span><br></pre></td></tr></table></figure>

<p>通常在被导入的名字过长时采用起别名的方式来精简代码，另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data_format == <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> json <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是json，那么导入json模块并命名为serialize</span></span><br><span class="line"><span class="keyword">elif</span> data_format == <span class="string">&#x27;pickle&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> pickle <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是pickle，那么导入pickle模块并命名为serialize</span></span><br><span class="line"></span><br><span class="line">data=serialize.load(fn) <span class="comment">#最终调用的方式是一致的</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-循环导入问题"><a href="#2-4-循环导入问题" class="headerlink" title="2.4 循环导入问题"></a>2.4 循环导入问题</h4><p>循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码</p>
<p><strong>注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入</strong></p>
<h4 id="2-5-搜索模块的路径与优先级"><a href="#2-5-搜索模块的路径与优先级" class="headerlink" title="2.5 搜索模块的路径与优先级"></a>2.5 搜索模块的路径与优先级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模块其实分为四个通用类别，分别是：</span><br><span class="line">    1、使用纯Python代码编写的py文件</span><br><span class="line">    2、包含一系列模块的包</span><br><span class="line">    3、使用C编写并链接到Python解释器中的内置模块</span><br><span class="line">    4、使用C或C++编译的扩展模块</span><br></pre></td></tr></table></figure>

<p>在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5&#x27;</span>,</span><br><span class="line">...,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages&#x27;</span></span><br></pre></td></tr></table></figure>

<p>列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。</p>
<p>sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为/pythoner/projects/</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;/pythoner/projects/&#x27;</span>) <span class="comment">#也可以使用sys.path.insert(……)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="comment">#无论foo.py在何处,我们都可以导入它了</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-区分py文件的两种用途"><a href="#2-6-区分py文件的两种用途" class="headerlink" title="2.6 区分py文件的两种用途"></a>2.6 区分py文件的两种用途</h4><p>一个Python文件有两种用途，一种被当主程序/脚本执行，另一种被当模块导入，为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名</p>
<p>作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo.py被当做脚本执行时运行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    foo.py被当做模块导入时运行的代码</span><br></pre></td></tr></table></figure>

<p>通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。</p>
<h4 id="2-7-编写一个规范的模块"><a href="#2-7-编写一个规范的模块" class="headerlink" title="2.7 编写一个规范的模块"></a>2.7 编写一个规范的模块</h4><p>我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;The module is used to...&quot;</span> <span class="comment">#模块的文档描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span> <span class="comment">#定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="comment">#定义类,并写好类的注释</span></span><br><span class="line">    <span class="string">&#x27;Class Foo is used to...&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span> <span class="comment">#定义函数,并写好函数的注释</span></span><br><span class="line">    <span class="string">&#x27;Function test is used to…&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment">#主程序</span></span><br><span class="line">    test() <span class="comment">#在被当做脚本执行时,执行此处的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.首次导入模块发生三件事：（import方法)</span><br><span class="line">	1、会触发spam.py运行，所以会产生一个模块的名称空间</span><br><span class="line">	2、运行spam.py的代码，将运行过程中产生的名字都丢到模块的名称空间中</span><br><span class="line">	3、在当前执行文件的名称空间中拿到一个名字spam，该名字就是指向模块的名称空间的</span><br><span class="line">       （from import第3步是在当前执行文件的名称空间中拿到一个名字money，该名字就是指向模块的名称空间对应的名字）（后续的导入直接引用首次导入的成果）</span><br><span class="line"></span><br><span class="line">2.import和from import调用的区别：</span><br><span class="line">	import 导入模块，每次使用模块中的函数都要是定是哪个模块。</span><br><span class="line">	from…import * 导入模块，每次使用模块中的函数，直接使用函数就可以了</span><br><span class="line">	</span><br><span class="line">3.循环导入问题：</span><br><span class="line">	3.1循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常。</span><br><span class="line">	3.2解决方法：</span><br><span class="line">        方法一：导入语句放到最后，保证在导入时，所有名字都已经加载过</span><br><span class="line">        方法二：导入语句放到函数中，只有在调用函数时才会执行其内部代码</span><br><span class="line">        方法三：重新设计代码结构，将代码和并或者分离</span><br><span class="line">        </span><br><span class="line">4.搜索模块的路径与优先级：</span><br><span class="line">	在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。</span><br><span class="line">优先级：内存 &gt; 内置 &gt; sys.path</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/06/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/06/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="post-title-link" itemprop="url">名称空间与作用域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-06 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-06T17:27:55+08:00">2018-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="名称空间与作用域"><a href="#名称空间与作用域" class="headerlink" title="名称空间与作用域"></a>名称空间与作用域</h1><h3 id="一-名称空间"><a href="#一-名称空间" class="headerlink" title="一 .名称空间"></a>一 .名称空间</h3><p>名称空间Namespaces：存放名字与其对应的内存地址的地方</p>
<p>名称空间分为三大类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、内置名称空间：存放的是python解释器自带的名字</span><br><span class="line">		生命周期：解释器启动则产生，解释器关闭则销毁</span><br><span class="line">2.全局名称空间：存放的是顶级的名字</span><br><span class="line">		生命周期：py程序刚开始运行则立即产生，py程序结束则销毁</span><br><span class="line">3.局部名称空间：存放的是函数内的名字</span><br><span class="line">		生命周期：函数调用则产生，函数调用结束则销毁</span><br></pre></td></tr></table></figure>

<h3 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h3><h4 id="2-1-全局作用域与局部作用域"><a href="#2-1-全局作用域与局部作用域" class="headerlink" title="2.1 全局作用域与局部作用域"></a>2.1 全局作用域与局部作用域</h4><p>按照名字作用范围的不同可以将三个名称空间划分为两个区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）</span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span>局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-作用域与名字查找的优先级"><a href="#2-2-作用域与名字查找的优先级" class="headerlink" title="2.2 作用域与名字查找的优先级"></a>2.2 作用域与名字查找的优先级</h4><p>在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，没有找到，再去全局作用域查找：先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">100</span> <span class="comment">#全局作用域的名字x</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    x=<span class="number">300</span> <span class="comment">#局部作用域的名字x</span></span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">#在局部找x</span></span><br><span class="line">foo()<span class="comment">#结果为300</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    x=<span class="number">300</span> <span class="comment">#在函数调用时产生局部作用域的名字x</span></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#在全局找x,结果为100</span></span><br></pre></td></tr></table></figure>

<h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><h5 id="可以调用内建函数locals-和globals-来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals-的结果等于globals"><a href="#可以调用内建函数locals-和globals-来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals-的结果等于globals" class="headerlink" title="可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()"></a>可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()</h5><p>在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到global关键字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x <span class="comment">#声明x为全局名称空间的名字</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#结果为2</span></span><br></pre></td></tr></table></figure>

<p>当实参的值为可变类型时，函数体内对该值的修改将直接反应到原值，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">nums</span>):</span></span><br><span class="line">    nums.append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">foo(num_list)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">f1</span>():</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x=<span class="number">3</span></span><br><span class="line">    f2() <span class="comment">#调用f2(),修改f1作用域中名字x的值</span></span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">#在f1作用域查看x</span></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">    <span class="keyword">nonlocal</span> x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、名字的访问优先级：</span><br><span class="line">     基于自己当前所在的位置向外一层一层查找，L-》E-》G-》B</span><br><span class="line"></span><br><span class="line">2、名称空间的&quot;嵌套&quot;关系是函数定义阶段、扫描语法时生成的，与调用位置无关</span><br><span class="line"></span><br><span class="line">全局作用域：内置名称空间、全局名称空间</span><br><span class="line">    特点: 全局存活，全局有效</span><br><span class="line">局部作用域：局部名称空间</span><br><span class="line">    特点：临时存活，局部有效</span><br><span class="line">  </span><br><span class="line">global:用来在局部修改全局的不可变类型的值</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/03/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/03/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">函数对象和闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-03 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-03T17:27:55+08:00">2018-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数对象和闭包"><a href="#函数对象和闭包" class="headerlink" title="函数对象和闭包"></a>函数对象和闭包</h1><h3 id="一-函数对象"><a href="#一-函数对象" class="headerlink" title="一 函数对象"></a>一 函数对象</h3><p>函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用</p>
<h4 id="1-1-函数可以被引用"><a href="#1-1-函数可以被引用" class="headerlink" title="1.1 函数可以被引用"></a>1.1 函数可以被引用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">     <span class="keyword">return</span> x+y</span><br><span class="line"> </span><br><span class="line">func=add</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-函数可以作为容器类型的元素"><a href="#1-2-函数可以作为容器类型的元素" class="headerlink" title="1.2 函数可以作为容器类型的元素"></a>1.2 函数可以作为容器类型的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;<span class="string">&#x27;add&#x27;</span>:add,<span class="string">&#x27;max&#x27;</span>:<span class="built_in">max</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line">&#123;<span class="string">&#x27;add&#x27;</span>: &lt;function add at <span class="number">0x100661e18</span>&gt;, <span class="string">&#x27;max&#x27;</span>: &lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;&#125;</span><br><span class="line">dic[<span class="string">&#x27;add&#x27;</span>](<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-函数可以作为参数传入另外一个函数"><a href="#1-3-函数可以作为参数传入另外一个函数" class="headerlink" title="1.3 函数可以作为参数传入另外一个函数"></a>1.3 函数可以作为参数传入另外一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,func</span>):</span></span><br><span class="line">    <span class="keyword">return</span> func(x,y)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,add)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-函数的返回值可以是一个函数"><a href="#1-4-函数的返回值可以是一个函数" class="headerlink" title="1.4 函数的返回值可以是一个函数"></a>1.4 函数的返回值可以是一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span> </span><br><span class="line">     <span class="keyword">return</span> add </span><br><span class="line">func=bar() </span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span> </span><br></pre></td></tr></table></figure>

<h3 id="二-闭包函数"><a href="#二-闭包函数" class="headerlink" title="二 闭包函数"></a>二 闭包函数</h3><h4 id="2-1-闭与包"><a href="#2-1-闭与包" class="headerlink" title="2.1 闭与包"></a>2.1 闭与包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.闭函数：被封闭起来的函数=&gt;定义函数内部的函数，闭函数的特点是只能在函数内用</span><br><span class="line">    def outer():</span><br><span class="line">         x = 100</span><br><span class="line">         def wrapper():</span><br><span class="line">             print(x)</span><br><span class="line">2.包函数：该函数引用了一个名字，该名字是来自与e这一层的</span><br><span class="line"></span><br><span class="line">“闭”代表函数是内部的，“包”代表函数外’包裹’着对外层作用域的引用。因而无论在何处调用闭包函数，使用的仍然是包裹在其外层的变量。</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">	闭包函数指的是定义在函数内部的函数引用了一个来自于外层函数作用域中的名字</span><br></pre></td></tr></table></figure>

<p>基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">    x=<span class="number">3</span></span><br><span class="line">    f2=f1() <span class="comment">#调用f1()返回函数f2</span></span><br><span class="line">    f2() <span class="comment">#需要按照函数定义时的作用关系去执行，与调用位置无关</span></span><br><span class="line"></span><br><span class="line">f3() <span class="comment">#结果为1</span></span><br></pre></td></tr></table></figure>

<p>也就是说函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包(Closures)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func=outer()</span><br><span class="line">func() <span class="comment"># 结果为2</span></span><br></pre></td></tr></table></figure>

<p>可以通过函数的<strong>closure</strong>属性，查看到闭包函数所包裹的外部变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x10212af78</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x10028cca0</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-闭包的用途"><a href="#2-2-闭包的用途" class="headerlink" title="2.2 闭包的用途"></a>2.2 闭包的用途</h4><p>目前为止，我们得到了两种为函数体传值的方式，一种是直接将值以参数的形式传入，另外一种就是将值包给函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">方式一：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">        <span class="keyword">return</span> requests.get(url).text</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">page</span>(<span class="params">url</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">            <span class="keyword">return</span> requests.get(url).text</span><br><span class="line">        <span class="keyword">return</span> get</span><br><span class="line">    </span><br><span class="line">提示：</span><br><span class="line">	requests模块是用来模拟浏览器向网站发送请求并将页面内容下载到本地，需要事先安装：pip3 install requests</span><br></pre></td></tr></table></figure>

<p>闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><h5 id="为函数体传参有两种解决方案："><a href="#为函数体传参有两种解决方案：" class="headerlink" title="为函数体传参有两种解决方案："></a>为函数体传参有两种解决方案：</h5><p>​        方案一:直接以参数的形式传入<br>​        方案二：以闭包函数的形式传参</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/02/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/02/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">函数的基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-02 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-02T17:27:55+08:00">2018-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h1><h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一.引子"></a>一.引子</h3><p>​            基于前一部分的学习，我们已经能开发一些功能简单的小程序了，但随着程序功能的增多，代码量随之增大，此时仍不加区分地把所有功能的实现代码放到一起，将会使得程序的组织结构不清晰，可读性变差，且程序中需要频繁使用同一功能时，只能重复编写该功能的实现代码，日积月累，程序将变得冗长，并且当某一功能需要修改时，又不得不找出所有定义及使用这段功能的地方修改之，管理维护的难度极大</p>
<p>​            在程序中，具备某一功能的‘工具’指的就是函数，‘事先准备工具’的过程即函数的定义，‘拿来就用’即函数的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、什么是函数</span><br><span class="line">    函数就是盛放代码的容器，把实现某一功能的一组代码丢到一个函数中</span><br><span class="line">    就做成了一个小工具</span><br><span class="line"></span><br><span class="line">    具备某一功能的工具-》函数</span><br><span class="line">    事先准备工具的过程-》函数的定义</span><br><span class="line">    遇到应用场景拿来就用-》函数的调用</span><br><span class="line"></span><br><span class="line">2、为何要用函数</span><br><span class="line">    在没有用函数之前面临的问题：</span><br><span class="line">        1、代码冗余，程序组织结构不清晰、可读性差</span><br><span class="line">        2、扩展性差</span><br><span class="line"></span><br><span class="line">3、如何用函数</span><br><span class="line">    原则：先定义、后调用</span><br></pre></td></tr></table></figure>



<h3 id="二-定义函数"><a href="#二-定义函数" class="headerlink" title="二.定义函数"></a>二.定义函数</h3><p>​            函数的使用必须遵循’先定义，后调用’的原则。函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这和变量的定义是相似的。没有事先定义函数而直接调用，就相当于在引用一个不存在的’’变量名’’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义函数的语法:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span></span><br><span class="line">        函数体</span><br><span class="line">        <span class="keyword">return</span> 值</span><br><span class="line">   </span><br><span class="line"><span class="number">1.</span><span class="keyword">def</span>: 定义函数的关键字；</span><br><span class="line"><span class="number">2.</span>函数名：函数名指向函数内存地址，是对函数体代码的引用。函数的命名应该反映出函数的功能；</span><br><span class="line"><span class="number">3.</span>括号：括号内定义参数，参数是可有可无的，且无需指定参数的类型；</span><br><span class="line"><span class="number">4.</span>冒号：括号后要加冒号，然后在下一行开始缩进编写函数体的代码；</span><br><span class="line"><span class="number">5.</span><span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span>: 描述函数功能，参数介绍等信息的文档，非必要，但是建议加上，从而增强函数的可读性；</span><br><span class="line"><span class="number">6.</span>函数体：由语句和表达式组成；</span><br><span class="line"><span class="number">7.</span><span class="keyword">return</span> 值：定义函数的返回值，<span class="keyword">return</span>是可有可无的。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">    <span class="number">1.</span>函数在定义阶段发生的什么事情?</span><br><span class="line">		定义函数不执行函数体代码，但是会检测函数体语法</span><br><span class="line">    <span class="number">2.</span>函数在调用阶段发生的什么事情?</span><br><span class="line">		先通过函数名找到函数的内存地址，然后函数的内存地址()会触发函数体代码的运行</span><br></pre></td></tr></table></figure>

<p>参数是函数的调用者向函数体传值的媒介，若函数体代码逻辑依赖外部传来的参数时则需要定义为参函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_min</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    res=x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>否则定义为无参函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interactive</span>():</span></span><br><span class="line">    user=<span class="built_in">input</span>(<span class="string">&#x27;user&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    pwd=<span class="built_in">input</span>(<span class="string">&#x27;password&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> (user,pwd)</span><br></pre></td></tr></table></figure>

<h3 id="三-调用函数与函数返回值"><a href="#三-调用函数与函数返回值" class="headerlink" title="三 调用函数与函数返回值"></a>三 调用函数与函数返回值</h3><p>​            函数的使用分为定义阶段与调用阶段，定义函数时只检测语法，不执行函数体代码，函数名加括号即函数调用，只有调用函数时才会执行函数体代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义阶段</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in the foo&#x27;</span>)</span><br><span class="line">        bar()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in the bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">调用阶段</span><br><span class="line">	foo()</span><br><span class="line">    </span><br><span class="line">执行结果</span><br><span class="line">    <span class="keyword">in</span> the foo</span><br><span class="line">    <span class="keyword">in</span> the bar</span><br></pre></td></tr></table></figure>

<p>按照在程序出现的形式和位置，可将函数的调用形式分为三种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、语句形式：</span><br><span class="line">	foo()</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、表达式形式：</span><br><span class="line">    m=my_min(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#将调用函数的返回值赋值给x</span></span><br><span class="line">    n=<span class="number">10</span>*my_min(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#将调用函数的返回值乘以10的结果赋值给n</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、函数调用作为参数的形式：</span><br><span class="line">    my_min（<span class="number">2</span>，<span class="number">3</span>）作为函数my_min的第二个参数，实现了取<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>中的较小者赋值给m</span><br><span class="line">    m=my_min(<span class="number">1</span>，my_min（<span class="number">2</span>，<span class="number">3</span>）)</span><br><span class="line">    </span><br><span class="line">	若需要将函数体代码执行的结果返回给调用者，则需要用到<span class="keyword">return</span>。<span class="keyword">return</span>后无值或直接省略<span class="keyword">return</span>，则默认返回<span class="literal">None</span>，<span class="keyword">return</span>的返回值无类型限制，且可以将多个返回值放到一个元组内。</span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">    <span class="keyword">return</span>是一个函数结束的标志,函数内可以有多个<span class="keyword">return</span>，但只执行一次函数就结束了，并把<span class="keyword">return</span>后定义的值作为本次调用的结果返回。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/01/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/01/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">函数的参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-01 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-01T17:27:55+08:00">2018-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><h3 id="一-形参与实参介绍"><a href="#一-形参与实参介绍" class="headerlink" title="一. 形参与实参介绍"></a>一. 形参与实参介绍</h3><p>​            函数的参数分为形式参数和实际参数，简称形参和实参</p>
<p>​            形参即在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。</p>
<p>​            实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：实参是常量</span><br><span class="line">	res=my_min(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：实参是变量</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    b=<span class="number">2</span></span><br><span class="line">    res=my_min(a,b)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：实参是表达式</span><br><span class="line">	res=my_min(<span class="number">10</span>*<span class="number">2</span>,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：实参可以是常量、变量、表达式的任意组合</span><br><span class="line">    a=<span class="number">2</span></span><br><span class="line">    my_min(<span class="number">1</span>,a,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h3 id="二-形参与实参的具体使用"><a href="#二-形参与实参的具体使用" class="headerlink" title="二 .形参与实参的具体使用"></a>二 .形参与实参的具体使用</h3><h4 id="2-1-位置参数"><a href="#2-1-位置参数" class="headerlink" title="2.1 位置参数"></a>2.1 位置参数</h4><p>位置即顺序，位置参数指的是按顺序定义的参数，需要从两个角度去看：        </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在定义函数时，按照从左到右的顺序依次定义形参,称为位置形参，凡是按照这种形式定义的形参都必须被传值</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,sex</span>):</span> <span class="comment">#定义位置形参：name，age，sex，三者都必须被传值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Name:%s Age:%s Sex:%s&#x27;</span> %(name,age,sex))</span><br><span class="line">    register() <span class="comment">#TypeError：缺少3个位置参数 </span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,sex</span>):</span> <span class="comment">#定义位置形参：name，age，sex，三者都必须被传值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Name:%s Age:%s Sex:%s&#x27;</span> %(name,age,sex))</span><br><span class="line">    register() <span class="comment">#TypeError：缺少3个位置参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-关键字参数"><a href="#2-2-关键字参数" class="headerlink" title="2.2 关键字参数"></a>2.2 关键字参数</h4><p>​        在调用函数时，实参可以是key=value的形式，称为关键字参数，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值        </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register(sex=<span class="string">&#x27;male&#x27;</span>,name=<span class="string">&#x27;lili&#x27;</span>,age=<span class="number">18</span>)</span><br><span class="line">==&gt; Name:lili Age:<span class="number">18</span> Sex:male</span><br></pre></td></tr></table></figure>

<p>需要注意在调用函数时，实参也可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,sex=<span class="string">&#x27;male&#x27;</span>,age=<span class="number">18</span>) <span class="comment">#正确使用</span></span><br><span class="line">register(name=<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,sex=<span class="string">&#x27;male&#x27;</span>) <span class="comment">#SyntaxError：关键字参数name=‘lili’在位置参数18之前</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,sex=<span class="string">&#x27;male&#x27;</span>,age=<span class="number">18</span>,name=<span class="string">&#x27;jack&#x27;</span>) <span class="comment">#TypeError：形参name被重复赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-默认参数"><a href="#2-3-默认参数" class="headerlink" title="2.3 默认参数"></a>2.3 默认参数</h4><p>在定义函数时，就已经为形参赋值，这类形参称之为默认参数，当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。</p>
<p>定义时就已经为参数sex赋值，意味着调用时可以不对sex赋值，这降低了函数调用的复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">register(<span class="string">&#x27;tom&#x27;</span>,<span class="number">17</span>) <span class="comment">#大多数情况,无需为sex传值,默认为male</span></span><br><span class="line">==&gt;  Name:tom Age:<span class="number">17</span> Sex:male</span><br><span class="line">register(<span class="string">&#x27;Lili&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;female&#x27;</span>) <span class="comment">#少数情况,可以为sex传值female</span></span><br><span class="line">==&gt;  Name:Lili Age:<span class="number">18</span> Sex:female</span><br><span class="line">            </span><br><span class="line">需要注意：</span><br><span class="line">    <span class="number">1.</span>默认参数必须在位置参数之后</span><br><span class="line">    <span class="number">2.</span>默认参数的值仅在函数定义阶段被赋值一次</span><br><span class="line">    <span class="number">3.</span>默认参数的值通常应设为不可变类型</span><br></pre></td></tr></table></figure>

<h4 id="2-4-可变长度的参数（-与-的用法）"><a href="#2-4-可变长度的参数（-与-的用法）" class="headerlink" title="2.4 可变长度的参数（*与**的用法）"></a>2.4 可变长度的参数（*与**的用法）</h4><h5 id="2-4-1-可变长度的位置参数"><a href="#2-4-1-可变长度的位置参数" class="headerlink" title="2.4.1 可变长度的位置参数"></a>2.4.1 可变长度的位置参数</h5><p>如果在最后一个形参名前加<em>号,那么在调用函数时，溢出的位置实参，都会被</em>接收，以元组的形式保存下来赋值给该形参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,z=<span class="number">1</span>,*args</span>):</span> <span class="comment">#在最后一个形参名args前加*号</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(z)</span><br><span class="line">     <span class="built_in">print</span>(args)</span><br><span class="line"> </span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)  <span class="comment">#实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，以元组的形式保存下来，赋值给args，即args=(4, 5, 6,7)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们事先生成了一个列表,仍然是可以传值给*args的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,*args</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(args)</span><br><span class="line"> </span><br><span class="line">L=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,*L) <span class="comment"># *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	如果在传入L时没有加*,那L就只是一个普通的位置参数了</span><br></pre></td></tr></table></figure>

<p>如果我们想要求多个值的和，*args就派上用场了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">*args</span>):</span></span><br><span class="line">     res=<span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">         res+=i</span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-可变长度的关键字参数"><a href="#2-4-2-可变长度的关键字参数" class="headerlink" title="2.4.2 可变长度的关键字参数"></a>2.4.2 可变长度的关键字参数</h5><p>如果在最后一个形参名前加<strong>号,那么在调用函数时，溢出的关键字参数，都会被</strong>接收，以字典的形式保存下来赋值给该形参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,**kwargs</span>):</span> <span class="comment">#在最后一个参数kwargs前加**</span></span><br><span class="line">     <span class="built_in">print</span>(x)        </span><br><span class="line">     <span class="built_in">print</span>(kwargs)   </span><br><span class="line"> </span><br><span class="line">foo(y=<span class="number">2</span>,x=<span class="number">1</span>,z=<span class="number">3</span>) <span class="comment">#溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们事先生成了一个字典,仍然是可以传值给**kwargs的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,**kwargs</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(kwargs)</span><br><span class="line"> </span><br><span class="line">dic=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; </span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,**dic) <span class="comment">#**dic就相当于关键字参数a=1，b=2，foo(1,2,**dic)等同foo(1,2,a=1,b=2)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	如果在传入dic时没有加**,那dic就只是一个普通的位置参数了</span><br></pre></td></tr></table></figure>

<h4 id="2-5-命名关键字参数"><a href="#2-5-命名关键字参数" class="headerlink" title="2.5 命名关键字参数"></a>2.5 命名关键字参数</h4><p>想要限定函数的调用者必须以key=value的形式传值，Python3提供了专门的语法：需要在定义形参时，用作为一个分隔符号，符号之后的形参称为命名关键字参数。对于这类参数，在函数调用时，必须按照key=value的形式为其传值，且必须被传值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,*,sex,height</span>):</span> <span class="comment">#sex,height为命名关键字参数</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,sex=<span class="string">&#x27;male&#x27;</span>,height=<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment">#正确使用</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment"># TypeError:未使用关键字的形式为sex和height传值</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,height=<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment"># TypeError没有为命名关键字参数height传值。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-组合使用"><a href="#2-6-组合使用" class="headerlink" title="2.6 组合使用"></a>2.6 组合使用</h4><p>综上所述所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、*args、命名关键字参数、**kwargs</p>
<p>可变参数*args与关键字参数<strong>kwargs通常是组合在一起使用的，如果一个函数的形参为*args与</strong>kwargs，那么代表该函数可以接收任何形式、任意长度的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: *args、**kwargs中的args和kwargs被替换成其他名字并无语法错误，但使用args、kwargs是约定俗成的。</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><h4 id="一-函数参数分为两大类："><a href="#一-函数参数分为两大类：" class="headerlink" title="一 .函数参数分为两大类："></a>一 .函数参数分为两大类：</h4><p>​    1、形参：在函数定义阶段括号内定义的变量名，称之为形式参数，简称形参<br>​    2、实参：在函数调用阶段括号内传入的值，称之为实际参数，简称实参</p>
<h4 id="二-形参与实参的关系是："><a href="#二-形参与实参的关系是：" class="headerlink" title="二.形参与实参的关系是："></a>二.形参与实参的关系是：</h4><p>​    在调用函数时，实参的值会绑定给形参名，然后可以在函数内使用，函数调用完毕后，解除绑定</p>
<h4 id="三：参数详解："><a href="#三：参数详解：" class="headerlink" title="三：参数详解："></a>三：参数详解：</h4><h5 id="形参："><a href="#形参：" class="headerlink" title="形参："></a>形参：</h5><p>​    1.位置形参：：在函数定义阶段按照从左到右的顺序依次定义的形参，称之为位置形参<br>​            特点：必须被传值，多一个不行少一个也不行<br>​    2.默认形参：在函数定义阶段就已经为某个形参赋值了，称之为默认形参<br>​            特点：在函数定义阶段就已经赋值了，意味着在调用阶段可以不用为其赋值</p>
<h5 id="ps-可以混用位置形参与默认形参，但是位置形参必须在前"><a href="#ps-可以混用位置形参与默认形参，但是位置形参必须在前" class="headerlink" title="ps: 可以混用位置形参与默认形参，但是位置形参必须在前"></a>ps: 可以混用位置形参与默认形参，但是位置形参必须在前</h5><h5 id="默认形参需要注意的问题是"><a href="#默认形参需要注意的问题是" class="headerlink" title="默认形参需要注意的问题是:"></a>默认形参需要注意的问题是:</h5><p>​    1、默认形参的值只在函数定义阶段被赋值一次<br>​    2、默认形参的值通常应该是不可变类型</p>
<h5 id="实参："><a href="#实参：" class="headerlink" title="实参："></a>实参：</h5><p>​    1.位置实参：在函数调用阶段按照从左到右的顺序依次传入的值，称之为位置实参<br>​            特点：按照顺序与形参一一对应<br>​    2.关键字实参：在函数调用阶段按照key=value的格式传入的值，称之为关键字实参<br>​            特点：可以打乱顺序，但是仍然能够为指定的形参赋值</p>
<h5 id="ps：可以混用位置实参与关键字实参，但是"><a href="#ps：可以混用位置实参与关键字实参，但是" class="headerlink" title="ps：可以混用位置实参与关键字实参，但是"></a>ps：可以混用位置实参与关键字实参，但是</h5><p>​        1、位置实参必须在关键字实参前<br>​        2、不能为同一个形参重复赋值</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/29/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/29/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/" class="post-title-link" itemprop="url">面向过程编程与函数式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-29 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-29T17:27:55+08:00">2018-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向过程编程与函数式"><a href="#面向过程编程与函数式" class="headerlink" title="面向过程编程与函数式"></a>面向过程编程与函数式</h1><h3 id="一-编程范式"><a href="#一-编程范式" class="headerlink" title="一 .编程范式"></a>一 .编程范式</h3><p>编程范式指的就是编程的套路，打个比方，如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程、函数式、面向对象等，本节我们主要介绍前两者。</p>
<h3 id="二-面向过程"><a href="#二-面向过程" class="headerlink" title="二 面向过程"></a>二 面向过程</h3><p>”面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤，即先干什么再干什么……，基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。</p>
<p>详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</p>
<p> 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一：基于本章所学，我们可以用函数去实现这一个个的步骤</span></span><br><span class="line"><span class="comment"># 1、本地数据打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup</span>(<span class="params">folder</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到备份目录: %s&quot;</span> %folder)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在备份...&#x27;</span>)</span><br><span class="line">    zip_file=<span class="string">&#x27;/tmp/backup_%s.zip&#x27;</span> %time.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;备份成功，备份文件为: %s&#x27;</span> %zip_file)</span><br><span class="line">    <span class="keyword">return</span> zip_file</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、上传至云服务器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">    link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> link</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、检测备份文件可用性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#二：依次调用</span></span><br><span class="line"><span class="comment"># 步骤一：本地数据打包</span></span><br><span class="line">zip_file = data_backup(<span class="string">r&quot;/Users/egon/欧美100G高清无码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：上传至云服务器</span></span><br><span class="line">link=cloud_upload(zip_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：检测备份文件的可用性</span></span><br><span class="line">data_backup_check(link)</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.优点:</span><br><span class="line">	将复杂的问题流程化，进而简单化</span><br><span class="line">2.缺点:</span><br><span class="line">	牵一发而动全身，扩展性差</span><br><span class="line">3.应用场景:</span><br><span class="line">	面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。</span><br></pre></td></tr></table></figure>

<h3 id="三-函数式"><a href="#三-函数式" class="headerlink" title="三 .函数式"></a>三 .函数式</h3><p>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</p>
<h4 id="3-1-匿名函数与lambda"><a href="#3-1-匿名函数与lambda" class="headerlink" title="3.1 匿名函数与lambda"></a>3.1 匿名函数与lambda</h4><p> 对比使用def关键字创建的是有名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数，语法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数<span class="number">1</span>,参数<span class="number">2</span>,...: expression</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、定义</span><br><span class="line">	<span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">   	 	<span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、调用</span><br><span class="line">方式一：</span><br><span class="line">	res=(<span class="keyword">lambda</span> x,y,z:x+y+z)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">	func=<span class="keyword">lambda</span> x,y,z:x+y+z <span class="comment"># “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的</span></span><br><span class="line">	res=func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">salaries=&#123;</span><br><span class="line">    <span class="string">&#x27;siry&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;tom&#x27;</span>:<span class="number">7000</span>,</span><br><span class="line">    <span class="string">&#x27;lili&#x27;</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">&#x27;jack&#x27;</span>:<span class="number">2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想取得薪水的最大值和最小值，我们可以使用内置函数max和min（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(salaries)</span><br><span class="line">=&gt; <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="built_in">min</span>(salaries)</span><br><span class="line">==&gt; <span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>内置max和min都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字</span></span><br><span class="line"><span class="built_in">max</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k]) </span><br><span class="line">==&gt; <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line"><span class="built_in">min</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k])</span><br><span class="line">==&gt; <span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(salaries)</span><br><span class="line">==&gt; [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;siry&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-2-map、reduce、filter"><a href="#3-2-map、reduce、filter" class="headerlink" title="3.2 map、reduce、filter"></a>3.2 map、reduce、filter</h4><p>函数map、reduce、filter都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>要求一：对array的每个元素做平方处理，可以使用map函数</p>
<p>map函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,array)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">==&gt; &lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x1033f45f8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>解析：map会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而map函数得到的结果仍然是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(res) <span class="comment">#使用list可以依次迭代res，取得的值作为列表元素</span></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p>要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数</p>
<p>reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce </span><br><span class="line">res=reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">==&gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>​        1 没有初始值，reduce函数会先迭代一次array得到的值作为初始值，作为第一个值数传给x，然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为3</p>
<p>​        2 将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，依次类推，知道迭代完array的所有元素，得到最终的结果15也可以为reduce指定初始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res=reduce(<span class="keyword">lambda</span> x,y:x+y,array,<span class="number">100</span>) &gt;&gt;&gt; res</span><br><span class="line">==&gt; <span class="number">115</span></span><br></pre></td></tr></table></figure>

<p>要求三：对array进行过滤操作，这就用到了filter函数，比如过滤出大于3的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;<span class="number">3</span>,array)</span><br></pre></td></tr></table></figure>

<p>解析：filter函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而filter函数得到的结果仍然是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(res) </span><br><span class="line">==&gt; [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>​        我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者的功能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-28 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-28T17:27:55+08:00">2018-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h4 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、面向过程编程</span><br><span class="line">    核心是过程二字，过程指的是解决的步骤，即先干啥、再干啥、后干啥</span><br><span class="line">    基于该思想写程序就在设计一条条的流水线</span><br><span class="line"></span><br><span class="line">    优点：复杂的问题流程化、进而简单化</span><br><span class="line">    缺点：牵一发而动全身，扩展性差</span><br><span class="line"></span><br><span class="line">2、面向对象编程</span><br><span class="line">    核心是“对象”二字，对象指的是盛放相关的数据与功能的容器</span><br><span class="line">    基于该思想编写程序就在创造一个个的容器来把相关的东西盛到一起</span><br><span class="line"></span><br><span class="line">    优点：扩展性强</span><br><span class="line">    缺点：加大了编程的复杂度</span><br></pre></td></tr></table></figure>

<h2 id="一-对象的概念"><a href="#一-对象的概念" class="headerlink" title="一.对象的概念"></a>一.对象的概念</h2><p>”面向对象“的核心是“对象”二字，而对象的精髓在于“整合“，什么意思？</p>
<p>所有的程序都是由”数据”与“功能“组成，因而编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。在学习”对象“之前，程序中的数据与功能是分离开的，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据：name、age、sex</span></span><br><span class="line">name=<span class="string">&#x27;lili&#x27;</span></span><br><span class="line">age=<span class="number">18</span></span><br><span class="line">sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能：tell_info</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_info</span>(<span class="params">name,age,sex</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s:%s:%s&gt;&#x27;</span> %(name,age,sex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时若想执行查看个人信息的功能，需要同时拿来两样东西，一类是功能tell_info，另外一类则是多个数据name、age、sex，然后才能执行，非常麻烦</span></span><br><span class="line">tell_info(name,age,sex)</span><br></pre></td></tr></table></figure>

<p>在学习了“对象”之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说”对象“就是一个盛放数据与功能的容器/箱子/盒子。</p>
<p>如果把”数据“比喻为”睫毛膏“、”眼影“、”唇彩“等化妆所需要的原材料；把”功能“比喻为眼线笔、眉笔等化妆所需要的工具，那么”对象“就是一个彩妆盒，彩妆盒可以把”原材料“与”工具“都装到一起</p>
<p>如果我们把”化妆“比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了化妆所需的所有原材料与功能，这比起你分别拿来原材料与功能才能执行，要方便的多。</p>
<p> 在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性</p>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调:"></a>强调:</h4><p>​            软件质量属性包含很多方面，面向对象解决的仅仅只是扩展性问题</p>
<p><img src="https://pic1.zhimg.com/80/v2-be68cd9e27b83c937cf44dbe7a2cf56c_720w.jpg" alt="img"></p>
<h2 id="二-类与对象"><a href="#二-类与对象" class="headerlink" title="二.类与对象"></a>二.类与对象</h2><p>类即类别/种类，是面向对象分析和设计的基石，如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类。有了类的好处是：我们可以把同一类对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间。所以，如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器。</p>
<p><img src="https://pic2.zhimg.com/v2-0b1c2138d316307c0c830aa1df3aa1e1_r.jpg" alt="preview"></p>
<p> 综上所述，虽然我们是先介绍对象后介绍类，但是需要强调的是：在程序中，必须要事先定义类，然后再调用类产生对象（调用类拿到的返回值就是对象）。产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间、减少代码冗余的机制，面向对象编程最终的核心仍然是去使用对象。</p>
<h2 id="三-面向对象编程"><a href="#三-面向对象编程" class="headerlink" title="三.面向对象编程"></a>三.面向对象编程</h2><h3 id="3-1-类的定义与实例化"><a href="#3-1-类的定义与实例化" class="headerlink" title="3.1 类的定义与实例化"></a>3.1 类的定义与实例化</h3><p>面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用，但程序中要用到的数据以及功能那么多，如何找到相关连的呢？我需要先提取选课系统里的角色：学生、老师、课程等，然后显而易见的是：学生有学生相关的数据于功能，老师有老师相关的数据与功能，我们单以学生为例，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生的数据有</span></span><br><span class="line">学校</span><br><span class="line">名字</span><br><span class="line">年龄</span><br><span class="line">性别</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生的功能有</span></span><br><span class="line">选课</span><br></pre></td></tr></table></figure>

<p>详细的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生1：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=李建刚</span><br><span class="line">        性别=男</span><br><span class="line">        年龄=<span class="number">28</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生2：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=王大力</span><br><span class="line">        性别=女</span><br><span class="line">        年龄=<span class="number">18</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br></pre></td></tr></table></figure>

<p>我们可以总结出一个学生类，用来存放学生们相同的数据与功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生类</span></span><br><span class="line">    相同的特征:</span><br><span class="line">        学校=清华大学</span><br><span class="line">    相同的功能：</span><br><span class="line">        选课</span><br></pre></td></tr></table></figure>

<p>基于上述分析的结果，我们接下来需要做的就是在程序中定义出类，然后调用类产生对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="comment"># 类的命名应该使用“驼峰体”</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span> <span class="comment"># 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> <span class="comment"># 功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>打印Student.__dict__来查看类这个容器内盛放的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Student.__dict__)</span><br><span class="line">==&gt;  &#123;..., <span class="string">&#x27;school&#x27;</span>: <span class="string">&#x27;清华大学&#x27;</span>, <span class="string">&#x27;choose&#x27;</span>: &lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;, ...&#125;</span><br></pre></td></tr></table></figure>

<p>调用类的过程称为将类实例化，拿到的返回值就是程序中的对象，或称为一个实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu1=Student() <span class="comment"># 每实例化一次Student类就得到一个学生对象</span></span><br><span class="line">stu2=Student()</span><br></pre></td></tr></table></figure>

<p>如此stu1、stu2、stu3全都一样了（只有类中共有的内容，而没有各自独有的数据），想在实例化的过程中就为三位学生定制各自独有的数据：姓名，性别，年龄，需要我们在类内部新增一个__init__方法,如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<p>然后我们重新实例出三位学生</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1=Student(<span class="string">&#x27;李建刚&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">28</span>)</span><br><span class="line">stu2=Student(<span class="string">&#x27;王大力&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">stu3=Student(<span class="string">&#x27;牛嗷嗷&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">38</span>)</span><br></pre></td></tr></table></figure>

<p>单拿stu1的产生过程来分析，调用类会先产生一个空对象stu1，然后将stu1连同调用类时括号内的参数一起传给Student.<strong>init</strong>(stu1,’李建刚’,’男’,28)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex, age</span>):</span></span><br><span class="line">    self.name = name  <span class="comment"># stu1.name = &#x27;李建刚&#x27;</span></span><br><span class="line">    self.sex = sex    <span class="comment"># stu1.sex = &#x27;男&#x27;</span></span><br><span class="line">    self.age = age    <span class="comment"># stu1.age = 28</span></span><br></pre></td></tr></table></figure>

<p>会产生对象的名称空间，同样可以用__dict__查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(stu1.__dict__)</span><br><span class="line">==&gt; &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李建刚&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容</p>
<p><img src="https://pic2.zhimg.com/80/v2-c3bb7aefce6ffee1029b1ae5dee72689_720w.jpg" alt="img"></p>
<p>存的目的是为了用，那么如何访问对象或者类中存放的内容呢？</p>
<h3 id="3-2-属性访问"><a href="#3-2-属性访问" class="headerlink" title="3.2 属性访问"></a>3.2 属性访问</h3><h4 id="3-2-1-类属性与对象属性"><a href="#3-2-1-类属性与对象属性" class="headerlink" title="3.2.1 类属性与对象属性"></a>3.2.1 类属性与对象属性</h4><p>在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.<strong>dict</strong>[‘school’]，但Python提供了专门的属性访问语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student.school <span class="comment"># 访问数据属性，等同于Student.__dict__[&#x27;school&#x27;]</span></span><br><span class="line">==&gt; <span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line">Student.choose <span class="comment"># 访问函数属性，等同于Student.__dict__[&#x27;choose&#x27;]</span></span><br><span class="line">==&gt; &lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;</span><br><span class="line"><span class="comment"># 除了查看属性外，我们还可以使用Student.attrib=value(修改或新增属性),用del Student.attrib删除属性。</span></span><br></pre></td></tr></table></figure>

<p>操作对象的属性也是一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stu1.name <span class="comment"># 查看，等同于obj1.__dict__[‘name&#x27;]</span></span><br><span class="line">==&gt; <span class="string">&#x27;李建刚&#x27;</span></span><br><span class="line">stu1.course=’python’ <span class="comment"># 新增，等同于obj1.__dict__[‘course&#x27;]=&#x27;python&#x27;</span></span><br><span class="line">stu1.age=<span class="number">38</span> <span class="comment"># 修改，等同于obj1.__dict__[‘age&#x27;]=38</span></span><br><span class="line"><span class="keyword">del</span> obj1.course <span class="comment"># 删除，等同于del obj1.__dict__[&#x27;course&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-属性查找顺序与绑定方法"><a href="#3-2-2-属性查找顺序与绑定方法" class="headerlink" title="3.2.2 属性查找顺序与绑定方法"></a>3.2.2 属性查找顺序与绑定方法</h4><p>对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找</p>
<p><strong>1、类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id都一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.school)) <span class="comment"># 4301108704</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.school)) <span class="comment"># 4301108704</span></span><br></pre></td></tr></table></figure>

<p><strong>2、类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.choose(stu1) <span class="comment"># 李建刚 is choosing a course</span></span><br><span class="line">Student.choose(stu2) <span class="comment"># 王大力 is choosing a course</span></span><br><span class="line">Student.choose(stu3) <span class="comment"># 牛嗷嗷 is choosing a course</span></span><br></pre></td></tr></table></figure>

<p>但其实类中定义的函数主要是给对象使用的，而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.choose)) <span class="comment"># 4335426280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.choose)) <span class="comment"># 4300433608</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.choose)) <span class="comment"># 4300433625</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.choose)) <span class="comment"># 4300433694</span></span><br></pre></td></tr></table></figure>

<p>绑定到对象的方法特殊之处在于，绑定给谁就应该由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法__init__也是一样的道理）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1.choose()  <span class="comment"># 等同于Student.choose(stu1)</span></span><br><span class="line">stu2.choose()  <span class="comment"># 等同于Student.choose(stu2)</span></span><br><span class="line">stu3.choose()  <span class="comment"># 等同于Student.choose(stu3)</span></span><br></pre></td></tr></table></figure>

<p>绑定到不同对象的choose技能，虽然都是选课，但李建刚选的课，不会选给王大力，这正是”绑定“二字的精髓所在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">	绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h4><p>在上述介绍类与对象的使用过程中，我们更多的是站在底层原理的角度去介绍类与对象之间的关联关系，如果只是站在使用的角度，我们无需考虑语法“对象.属性”中”属性“到底源自于哪里，只需要知道是通过对象获取到的就可以了，所以说，对象是一个高度整合的产物，有了对象，我们只需要使用”对象.xxx“的语法就可以得到跟这个对象相关的所有数据与功能，十分方便且解耦合程度极高。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结:"></a>四.总结:</h2><h5 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">类的作用:</span><br><span class="line">	类是用来解决对象之间代码冗余问题的</span><br><span class="line">	</span><br><span class="line">类定义阶段发生的三件事:</span><br><span class="line">    1、会执行类体的代码</span><br><span class="line">    2、会产生一个类的名称空间，用来将类体代码运行过程中产生的名字都丢进去</span><br><span class="line">    3、将名称空间的内存地址绑定给类名</span><br><span class="line">    </span><br><span class="line">调用类也发生了三件事:</span><br><span class="line">    1、会创建空对象（调用__new__方法来创建的空对象）</span><br><span class="line">    2、会自动触发类中__init__函数的运行，__init__(空对象,&quot;zqw&quot;,18,&#x27;male&#x27;)，完成对象的初始化操作</span><br><span class="line">    3、返回该对象，赋值给stu1_dic</span><br><span class="line">    注意：__init__不能有返回值</span><br><span class="line">    </span><br><span class="line">类中有两种属性</span><br><span class="line">	1、数据属性</span><br><span class="line">	2、函数属性</span><br><span class="line">	</span><br><span class="line">类中的属性其实是为对象准备</span><br><span class="line">	1、类的属性是直接共享给所有对象用的</span><br><span class="line">	2、类的函数属性是绑定给对象用的</span><br></pre></td></tr></table></figure>

<h5 id="2-绑定方法"><a href="#2-绑定方法" class="headerlink" title="2.绑定方法"></a>2.绑定方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">	不管是类中的方法，还是类中函数，默认情况下都是绑定给对象使用的</span><br><span class="line">	</span><br><span class="line">类中定义的函数分为两大类:</span><br><span class="line">	一：绑定方法：绑定给谁就应该由谁来调用，谁来调用就会将自己当作第一个参数自动传入</span><br><span class="line">        绑定给对象:哪个对象来调用就将哪个对象当作第一个参数自动传入</span><br><span class="line">        绑定给类:绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍是类</span><br><span class="line">	二：非绑定方法：不与任何人绑定，意味着谁都可以来调用，但是无论谁来调用就是一个普通函数，没有自动传参的效果</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">	绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法(即普通函数)</span><br><span class="line"></span><br><span class="line">ps:类中定义了同名的对象方法、类方法、静态方法时，调用方法会优先执行最后定义的方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">绑定给类(@classmethod):</span><br><span class="line">	绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍是类</span><br><span class="line">	class Mysql:</span><br><span class="line">    def __init__(self, ip, port):</span><br><span class="line">        self.id = self.create_id()</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    def tell_info(self):</span><br><span class="line">        print(&quot;&lt;%s:%s&gt;&quot; % (self.ip, self.port))</span><br><span class="line"></span><br><span class="line">    @classmethod	# 默认参数cls，可以直接用类名调用，可以与类属性交互</span><br><span class="line">    def from_conf(cls):</span><br><span class="line">        return cls(&#x27;2.2.2&#x27;,6666)</span><br><span class="line"></span><br><span class="line">    res = Mysql.from_conf()</span><br><span class="line">    print(res.__dict__)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">非绑定方法(@staticmethod):</span><br><span class="line">	不与任何人绑定，意味着谁都可以来调用，但是无论谁来调用就是一个普通函数，没有自动传参的效果</span><br><span class="line">	class Mysql:</span><br><span class="line">    def __init__(self, ip, port):</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    def tell_info(self):</span><br><span class="line">        print(&quot;&lt;%s:%s&gt;&quot; % (self.ip, self.port))</span><br><span class="line"></span><br><span class="line">    @staticmethod	#静态方法:让类里的方法直接被类调用，就像正常的函数一样</span><br><span class="line">    def create_id(name):</span><br><span class="line">        import uuid</span><br><span class="line">        return uuid.uuid4(),name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    obj = Mysql(&#x27;1.1.1.1&#x27;, 3306)</span><br><span class="line"></span><br><span class="line">    res,msg = obj.create_id(&#x27;zqw&#x27;)</span><br><span class="line">    print(res,msg)</span><br></pre></td></tr></table></figure>

<h5 id="3-classmethod和staticmethod区别"><a href="#3-classmethod和staticmethod区别" class="headerlink" title="3.classmethod和staticmethod区别"></a>3.classmethod和staticmethod区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相同：都可以直接被类调用，不需要实例化</span><br><span class="line">不同:</span><br><span class="line">    1.类方法必须有一个cls参数表示这个类，可以使用类属性</span><br><span class="line">    2.静态方法不需要，静态方法不能直接使用,有几个参数传几个参数</span><br></pre></td></tr></table></figure>

<h5 id="4-实例-类-静态"><a href="#4-实例-类-静态" class="headerlink" title="4.实例,类,静态"></a>4.实例,类,静态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例方法</span><br><span class="line">    定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)；</span><br><span class="line">    调用：只能由实例对象调用。</span><br><span class="line"></span><br><span class="line">类方法</span><br><span class="line">    定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法(不能传实例的属性和方法)</span><br><span class="line">    调用：实例对象和类对象都可以调用(实例对象调用毫无意义)</span><br><span class="line"></span><br><span class="line">静态方法</span><br><span class="line">    定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</span><br><span class="line">    调用：实例对象和类对象都可以调用</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/20/%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/20/%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">反射、内置方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-20 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-20T17:27:55+08:00">2018-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="反射、内置方法"><a href="#反射、内置方法" class="headerlink" title="反射、内置方法"></a>反射、内置方法</h1><h3 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射：</span><br><span class="line">	通过字符串来操作属性</span><br></pre></td></tr></table></figure>

<p>python是动态语言，而反射(reflection)机制被视为动态语言的关键。</p>
<p>反射机制指的是在程序的运行状态中</p>
<p>对于任意一个类，都可以知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用他的任意方法和属性。</p>
<p>这种动态获取程序信息以及动态调用对象的功能称为反射机制。</p>
<p>在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数dir来获取任意一个类或者对象的属性列表，列表中全为字符串格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,gender</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.age=age</span><br><span class="line">         self.gender=gender</span><br><span class="line"> </span><br><span class="line">obj=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"><span class="built_in">dir</span>(obj) <span class="comment"># 列表中查看到的属性全为字符串</span></span><br><span class="line">==&gt; [......,<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>接下来就是想办法通过字符串来操作对象的属性了，这就涉及到内置函数hasattr、getattr、setattr、delattr的使用了（Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,full_name</span>):</span></span><br><span class="line">        self.full_name =full_name</span><br><span class="line"></span><br><span class="line">t=Teacher(<span class="string">&#x27;Egon Lin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hasattr(object,&#x27;name&#x27;)</span></span><br><span class="line"><span class="built_in">hasattr</span>(t,<span class="string">&#x27;full_name&#x27;</span>) <span class="comment"># 按字符串&#x27;full_name&#x27;判断有无属性t.full_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getattr(object, &#x27;name&#x27;, default=None)</span></span><br><span class="line"><span class="built_in">getattr</span>(t,<span class="string">&#x27;full_name&#x27;</span>,<span class="literal">None</span>) <span class="comment"># 等同于t.full_name,不存在该属性则返回默认值None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setattr(x, &#x27;y&#x27;, v)</span></span><br><span class="line"><span class="built_in">setattr</span>(t,<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>) <span class="comment"># 等同于t.age=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delattr(x, &#x27;y&#x27;)</span></span><br><span class="line"><span class="built_in">delattr</span>(t,<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 等同于del t.age</span></span><br></pre></td></tr></table></figure>

<p>基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FtpServer</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>            inp=<span class="built_in">input</span>(<span class="string">&#x27;input your cmd&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line"><span class="meta">... </span>            cmd,file=inp.split()</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd): <span class="comment"># 根据用户输入的cmd，判断对象self有无对应的方法属性</span></span><br><span class="line"><span class="meta">... </span>                func=<span class="built_in">getattr</span>(self,cmd) <span class="comment"># 根据字符串cmd，获取对象self对应的方法属性</span></span><br><span class="line"><span class="meta">... </span>                func(file)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,file</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Downloading %s...&#x27;</span> %file)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,file</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Uploading %s...&#x27;</span> %file)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server=FtpServer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.serve_forever()</span><br><span class="line"><span class="built_in">input</span> your cmd&gt;&gt;: get a.txt</span><br><span class="line">Downloading a.txt...</span><br><span class="line"><span class="built_in">input</span> your cmd&gt;&gt;: put a.txt</span><br><span class="line">Uploading a.txt...</span><br></pre></td></tr></table></figure>

<h3 id="二-内置方法"><a href="#二-内置方法" class="headerlink" title="二 内置方法"></a>二 内置方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内置方法:</span><br><span class="line">	在满足某种条件下会自动触发执行</span><br></pre></td></tr></table></figure>

<p>Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。</p>
<p>__str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        self.age=age</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>	<span class="comment"># 打印对象时自动触发执行，将返回值当作打印结果</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;&lt;Name:%s Age:%s&gt;&#x27;</span> %(self.name,self.age) <span class="comment">#返回类型必须是字符串</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p=People(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p) <span class="comment">#触发p.__str__()，拿到返回值后进行打印</span></span><br><span class="line">&lt;Name:lili Age:<span class="number">18</span>&gt;</span><br></pre></td></tr></table></figure>

<p>__del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ip,port</span>):</span></span><br><span class="line">        self.conn=connect(ip,port) <span class="comment"># 伪代码，发起网络连接，需要占用系统资源</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn.close() <span class="comment"># 关闭网络连接，回收系统资源</span></span><br><span class="line"></span><br><span class="line">obj=MySQL(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">3306</span>) <span class="comment"># 在对象obj被删除时，自动触发obj.__del__()</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/19/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/19/%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">多态性与鸭子类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-19 17:27:55" itemprop="dateCreated datePublished" datetime="2018-05-19T17:27:55+08:00">2018-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多态性与鸭子类型"><a href="#多态性与鸭子类型" class="headerlink" title="多态性与鸭子类型"></a>多态性与鸭子类型</h1><h3 id="一-多态与多态性"><a href="#一-多态与多态性" class="headerlink" title="一.多态与多态性"></a>一.多态与多态性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.什么是多态?</span><br><span class="line">	同一种事物有多种形态</span><br><span class="line">2.什么是多态性?</span><br><span class="line">	我们可以在不用知道对象具体类型的前提下，而直接使用对象</span><br><span class="line">3.多态性好处:</span><br><span class="line">	增强了程序的灵活性和可扩展性</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span> <span class="comment">#同一类事物:动物</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之一:猫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;喵喵喵&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之二:狗</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;汪汪汪&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的形态之三:猪</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;哼哼哼&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化得到三个对象</span></span><br><span class="line">cat=Cat()</span><br><span class="line">dog=Dog()</span><br><span class="line">pig=Pig()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat.talk()</span><br><span class="line">==&gt; 喵喵喵</span><br><span class="line">dog.talk()</span><br><span class="line">==&gt; 汪汪汪</span><br><span class="line">pig.talk()</span><br><span class="line">==&gt; 哼哼哼</span><br></pre></td></tr></table></figure>

<p>更进一步,我们可以定义一个统一的接口来使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Talk</span>(<span class="params">animal</span>):</span></span><br><span class="line">     animal.talk()</span><br><span class="line"> </span><br><span class="line">Talk(cat)</span><br><span class="line">==&gt; 喵喵喵</span><br><span class="line">Talk(dog)</span><br><span class="line">==&gt; 汪汪汪</span><br><span class="line">Talk(pig)</span><br><span class="line">==&gt; 哼哼哼</span><br></pre></td></tr></table></figure>

<p>Python中一切皆对象，本身就支持多态性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以在不考虑三者类型的情况下直接使用统计三个对象的长度</span></span><br><span class="line">s.__len__()</span><br><span class="line">l.__len__()</span><br><span class="line">t.__len__()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置了一个统一的接口</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">len</span>(l)</span><br><span class="line"><span class="built_in">len</span>(t)</span><br></pre></td></tr></table></figure>

<p>多态性的好处在于增强了程序的灵活性和可扩展性，比如通过继承Animal类创建了一个新的类，实例化得到的对象obj，可以使用相同的方式使用obj.talk()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf</span>(<span class="params">Animal</span>):</span> <span class="comment">#动物的另外一种形态：狼</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;嗷...&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">wolf=Wolf() <span class="comment"># 实例出一头狼</span></span><br><span class="line">wolf.talk() <span class="comment"># 使用者根本无需关心wolf是什么类型而调用talk</span></span><br><span class="line">==&gt; 嗷...</span><br></pre></td></tr></table></figure>

<p>综上我们得知，多态性的本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象，可以通过在父类引入抽象类的概念来硬性限制子类必须有某些方法名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment"># 该装饰器限制子类必须定义有一个名为talk的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span> <span class="comment"># 抽象方法中无需实现具体的功能</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment"># 但凡继承Animal的子类都必须遵循Animal规定的标准</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cat=Cat() <span class="comment"># 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化</span></span><br></pre></td></tr></table></figure>

<h3 id="二-鸭子类型"><a href="#二-鸭子类型" class="headerlink" title="二.鸭子类型"></a>二.鸭子类型</h3><p>但其实我们完全可以不依赖于继承，只需要制造出外观和行为相同对象，同样可以实现不考虑对象类型而使用对象，这正是Python崇尚的“鸭子类型”（duck typing）：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子”。比起继承的方式，鸭子类型在某种程度上实现了程序的松耦合度，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二者看起来都像文件,因而就可以当文件一样去用，然而它们并没有直接的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Txt</span>:</span> <span class="comment">#Txt类有两个与文件类型同名的方法，即read和write</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span>:</span> <span class="comment">#Disk类也有两个与文件类型同名的方法：read和write</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">左大大</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
