<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="左大大的博客">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="左大大的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="左大大">
<meta property="article:tag" content="Python Linux Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>左大大的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">左大大的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="左大大"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">左大大</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/23/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/23/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">异常处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-23 17:27:55" itemprop="dateCreated datePublished" datetime="2018-07-23T17:27:55+08:00">2018-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h3 id="一-什么是异常"><a href="#一-什么是异常" class="headerlink" title="一.什么是异常"></a>一.什么是异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、什么是异常?</span><br><span class="line">    异常是程序发生错误的信号，一旦程序出错python解释器就会产生一个异常</span><br><span class="line">    如果该异常没有被处理，该异常就会抛出来，程序的运行也随即终止</span><br><span class="line">2、为何要处理异常</span><br><span class="line">    增强程序的健壮性，鲁棒性</span><br><span class="line">3、如何处理异常</span><br><span class="line">    具体来说错误分类两大类：</span><br><span class="line">        1、语法错误SyntaxError(程序运行前会先检测语法，语法不通过程序都不会运行): 在程序运行前必须改正，不允许出现</span><br><span class="line">        2、逻辑错误（(程序运行时才会遇到逻辑错误）：</span><br><span class="line">            1、尽量避免</span><br><span class="line">            2、针对无法预防的错误，解决方案-》补救</span><br><span class="line">			print(&quot;start...&quot;)</span><br><span class="line">            try:</span><br><span class="line">                被监测的代码1</span><br><span class="line">                被监测的代码2</span><br><span class="line">                被监测的代码3</span><br><span class="line">            except 异常类型1 as e:</span><br><span class="line">                处理异常的代码1</span><br><span class="line">            except 异常类型2 as e:</span><br><span class="line">                处理异常的代码2</span><br><span class="line">            except (异常类型3,异常类型4) as e:</span><br><span class="line">                处理异常的代码</span><br><span class="line">            except Exception as e:</span><br><span class="line">                处理异常的代码</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;被监测代码块没有异常发生时会运行&quot;)</span><br><span class="line">            finally:</span><br><span class="line">                print(&quot;被监测代码块无论有没有异常发生都会运行&quot;)</span><br><span class="line"></span><br><span class="line">            print(&quot;end...&quot;)</span><br></pre></td></tr></table></figure>

<p>异常是程序发生错误的信号。程序一旦出现错误，便会产生一个异常，若程序中没有处理它，就会抛出该异常，程序的运行也随之终止。在Python中,错误触发的异常如下</p>
<p><img src="https://pic3.zhimg.com/80/v2-4653ca6dbe955793d1e4ed1fb750ce86_720w.jpg" alt="img"></p>
<p>而错误分成两种，一种是语法上的错误SyntaxError，这种错误应该在程序运行前就修改正确</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span>  </span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">     ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>另一类就是逻辑错误，常见的逻辑错误如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TypeError：数字类型无法与字符串类型相加</span></span><br><span class="line"><span class="number">1</span>+’<span class="number">2</span>’</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError：当字符串包含有非数字的值时，无法转成int类型</span></span><br><span class="line">num=<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;: &quot;</span>) <span class="comment">#输入hello</span></span><br><span class="line"><span class="built_in">int</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># NameError：引用了一个不存在的名字x</span></span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># IndexError：索引超出列表的限制</span></span><br><span class="line">l=[<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line">l[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError：引用了一个不存在的key</span></span><br><span class="line">dic=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;</span><br><span class="line">dic[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># AttributeError：引用的属性不存在</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">Foo.x</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZeroDivisionError：除数不能为0</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="二-异常处理"><a href="#二-异常处理" class="headerlink" title="二.异常处理"></a>二.异常处理</h3><p>为了保证程序的容错性与可靠性，即在遇到错误时有相应的处理机制不会任由程序崩溃掉，我们需要对异常进行处理，处理的基本形式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型：</span><br><span class="line">    检测到异常，就执行这个位置的逻辑</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment"># 引用了一个不存在的名字，触发异常NameError</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e: <span class="comment"># as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;异常值为：%s&#x27;</span> %e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run other code...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果为</span></span><br><span class="line">start...</span><br><span class="line">异常值为：name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">run other code...</span><br></pre></td></tr></table></figure>

<p>本来程序一旦出现异常就整体结束掉了，有了异常处理以后，在被检测的代码块出现异常时，被检测的代码块中异常发生位置之后的代码将不会执行，取而代之的是执行匹配异常的except子代码块，其余代码均正常运行。</p>
<p> 当被检测的代码块中有可能触发不同类型的异常时，针对不同类型的异常：</p>
<p> 如果我们想分别用不同的逻辑处理，需要用到多分支的except（类似于多分支的elif，从上到下依次匹配，匹配成功一次便不再匹配其他）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    触发NameError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    触发IndexError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    触发KeyError时对应的处理逻辑</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_int</span>(<span class="params">obj</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res=<span class="built_in">int</span>(obj)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError: %s&#x27;</span> %e)</span><br><span class="line">        res=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;TypeError: %s&#x27;</span> %e)</span><br><span class="line">        res=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">convert_int(<span class="string">&#x27;egon&#x27;</span>) <span class="comment"># ValueError: invalid literal for int() with base 10: &#x27;egon&#x27;</span></span><br><span class="line">convert_int(&#123;<span class="string">&#x27;n&#x27;</span>:<span class="number">1</span>&#125;) <span class="comment"># TypeError: int() argument must be a string, a bytes-like object or a number, not &#x27;dict&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们想多种类型的异常统一用一种逻辑处理，可以将多个异常放到一个元组内，用一个except匹配</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> (NameError,IndexError,TypeError):</span><br><span class="line">    触发NameError或IndexError或TypeError时对应的处理逻辑</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_int</span>(<span class="params">obj</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res=<span class="built_in">int</span>(obj)</span><br><span class="line">    <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;argument must be number or numeric string&#x27;</span>)</span><br><span class="line">        res=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">convert_int(<span class="string">&#x27;egon&#x27;</span>) <span class="comment"># argument must be number or numeric string</span></span><br><span class="line">convert_int(&#123;<span class="string">&#x27;n&#x27;</span>:<span class="number">1</span>&#125;) <span class="comment"># argument must be number or numeric string</span></span><br></pre></td></tr></table></figure>

<p>如果我们想捕获所有异常并用一种逻辑处理，Python提供了一个万能异常类型Exception</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    触发NameError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    触发IndexError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    其他类型的异常统一用此处的逻辑处理</span><br></pre></td></tr></table></figure>

<p>在多分支except之后还可以跟一个else（else必须跟在except之后，不能单独存在），只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有异常发生时执行的代码块</span><br></pre></td></tr></table></figure>

<p>此外try还可以与finally连用，从语法上讲finally必须放到else之后，但可以使用try-except-finally的形式，也可以直接使用try-finally的形式。无论被检测的代码块是否触发异常，都会执行finally的子代码块，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件、关闭数据库连接等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python try: 被检测的代码块 except 异常类型1: pass except 异常类型2: pass ...... else: 没有异常发生时执行的代码块 finally: 无论有无异常发生都会执行的代码块</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f=<span class="built_in">open</span>(‘db.txt’,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    s=f.read().strip()</span><br><span class="line">    <span class="built_in">int</span>(s)  <span class="comment"># 若字符串s中包含非数字时则会触发异常ValueError</span></span><br><span class="line">    <span class="comment"># f.close() # 若上面的代码触发异常，则根本不可能执行到此处的代码，应该将关闭文件的操作放到finally中</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f: <span class="comment"># 文件存在则f的值不为None</span></span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<p>在不符合Python解释器的语法或逻辑规则时，是由Python解释器主动触发的各种类型的异常，而对于违反程序员自定制的各类规则，则需要由程序员自己来明确地触发异常，这就用到了raise语句，raise后必须是一个异常的类或者是异常的实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(name,<span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;name must be str&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age,<span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;age must be int&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">stu1=Student(<span class="number">4573</span>,<span class="number">18</span>) <span class="comment"># TypeError: name must be str</span></span><br><span class="line">stu2=Student(<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;18&#x27;</span>) <span class="comment"># TypeError: age must be int</span></span><br></pre></td></tr></table></figure>

<p>在内置异常不够用的情况下，我们可以通过继承内置的异常类来自定义异常类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolEmptyError</span>(<span class="params">Exception</span>):</span> <span class="comment"># 可以通过继承Exception来定义一个全新的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value=<span class="string">&#x27;The proxy source is exhausted&#x27;</span></span>):</span> <span class="comment"># 可以定制初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>(PoolEmptyError,self).__init__()</span><br><span class="line">        self.value=value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span> <span class="comment"># 可以定义该方法用来定制触发异常时打印异常值的格式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt; %s &gt;&#x27;</span> %self.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkIOError</span>(<span class="params">IOError</span>):</span> <span class="comment"># 也可以在特定异常的基础上扩展一个相关的异常</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> PoolEmptyError <span class="comment"># __main__.PoolEmptyError: &lt; The proxy source is exhausted &gt;</span></span><br><span class="line"><span class="keyword">raise</span> NetworkIOError(<span class="string">&#x27;连接被拒绝&#x27;</span>) <span class="comment"># __main__.NetworkIOError: 连接被拒绝</span></span><br></pre></td></tr></table></figure>

<p>最后，Python还提供了一个断言语句assert expression，断定表达式expression成立，否则触发异常AssertionError，与raise-if-not的语义相同，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="string">&#x27;18&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若表达式isinstance(age,int)返回值为False则触发异常AssertionError</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(age,<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age,<span class="built_in">int</span>):</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>

<h3 id="三-何时使用异常处理"><a href="#三-何时使用异常处理" class="headerlink" title="三.何时使用异常处理"></a>三.何时使用异常处理</h3><p>在了解了异常处理机制后，本着提高程序容错性和可靠性的目的，读者可能会错误地认为应该尽可能多地为程序加上try…except…，这其是在过度消费程序的可读性，因为try…except本来就是你附加给程序的一种额外的逻辑，与你的主要工作是没有多大关系的。</p>
<p> 如果错误发生的条件是“可预知的”，我们应该用if来进行”预防”，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="built_in">input</span>(<span class="string">&#x27;input your age&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line"><span class="keyword">if</span> age.isdigit(): <span class="comment"># 可预知只有满足字符串age是数字的条件，int(age)才不会触发异常，</span></span><br><span class="line">    age=<span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You must enter the number&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果错误发生的条件“不可预知”，即异常一定会触发，那么我们才应该使用try…except语句来处理。例如我们编写一个下载网页内容的功能，网络发生延迟之类的异常是很正常的事，而我们根本无法预知在满足什么条件的情况下才会出现延迟，因而只能用异常处理机制了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ConnectTimeout <span class="comment"># 导入requests模块内自定义的异常</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response=requests.get(url,timeout=<span class="number">3</span>)<span class="comment">#超过3秒未下载成功则触发ConnectTimeout异常</span></span><br><span class="line">        res=response.text</span><br><span class="line">    <span class="keyword">except</span> ConnectTimeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;连接请求超时&#x27;</span>)</span><br><span class="line">        res=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;网络出现其他异常&#x27;</span>)</span><br><span class="line">        res=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/07/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/07/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">软件开发的目录规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-07 17:27:55" itemprop="dateCreated datePublished" datetime="2018-07-07T17:27:55+08:00">2018-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="软件开发的目录规范"><a href="#软件开发的目录规范" class="headerlink" title="软件开发的目录规范"></a>软件开发的目录规范</h1><h2 id="软件开发目录规范"><a href="#软件开发目录规范" class="headerlink" title="软件开发目录规范"></a>软件开发目录规范</h2><p>为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。软件的目录规范并无硬性标准，只要清晰可读即可，假设你的软件名为foo，笔者推荐目录结构如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- core/</span><br><span class="line">|   |-- core.py</span><br><span class="line">|</span><br><span class="line">|-- api/</span><br><span class="line">|   |-- api.py</span><br><span class="line">|</span><br><span class="line">|-- db/</span><br><span class="line">|   |-- db_handle.py</span><br><span class="line">|</span><br><span class="line">|-- lib/</span><br><span class="line">|   |-- common.py</span><br><span class="line">|</span><br><span class="line">|-- conf/</span><br><span class="line">|   |-- settings.py</span><br><span class="line">|</span><br><span class="line">|-- run.py</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>

<p>简要解释一下:</p>
<p> • core/: 存放业务逻辑相关代码</p>
<p> • api/: 存放接口文件，接口主要用于为业务逻辑提供数据操作。</p>
<p> • db/: 存放操作数据库相关文件，主要用于与数据库交互</p>
<p> • lib/: 存放程序中常用的自定义模块</p>
<p> • conf/: 存放配置文件</p>
<p> • run.py: 程序的启动文件，一般放在项目的根目录下，因为在运行时会默认将运行文件所在的文件夹作为sys.path的第一个路径，这样就省去了处理环境变量的步骤</p>
<p> • setup.py: 安装、部署、打包的脚本。</p>
<p> • requirements.txt: 存放软件依赖的外部Python包列表。</p>
<p> • README: 项目说明文件。</p>
<p>除此之外，有一些方案给出了更加多的内容，比如LICENSE.txt,ChangeLog.txt文件等，主要是在项目需要开源时才会用到，请读者自行查阅。</p>
<p>关于README的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、软件定位，软件的基本功能；</span><br><span class="line"><span class="number">2</span>、运行代码的方法: 安装环境、启动命令等；</span><br><span class="line"><span class="number">3</span>、简要的使用说明；</span><br><span class="line"><span class="number">4</span>、代码目录结构说明，更详细点可以说明软件的基本原理；</span><br><span class="line"><span class="number">5</span>、常见问题说明。</span><br></pre></td></tr></table></figure>

<p>关于setup.py和requirements.txt：</p>
<p>一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p>
<p>requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。</p>
<p>这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python依赖库都装好了，具体格式参照<a href="https://link.zhihu.com/?target=https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/23/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/23/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">文件处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-23 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-23T17:27:55+08:00">2018-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一.引子"></a>一.引子</h3><p>​             应用程序运行过程中产生的数据最先都是存放于内存中的，若想永久保存下来，必须要保存于硬盘中。应用程序若想操作硬件必须通过操作系统，而文件就是操作系统提供给应用程序来操作硬盘的虚拟概念，用户或应用程序对文件的操作，就是向操作系统发起调用，然后由操作系统完成对硬盘的具体操作。</p>
<h3 id="二-文件操作基本流程"><a href="#二-文件操作基本流程" class="headerlink" title="二.文件操作基本流程"></a>二.文件操作基本流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>基本流程:</span><br><span class="line">    有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</span><br><span class="line">            <span class="number">1.</span> 打开文件，由应用程序向操作系统发起系统调用<span class="built_in">open</span>(...)，操作系统打开该文件，对应一块硬盘空			   间，并返回一个文件对象赋值给一个变量f</span><br><span class="line">            	f=<span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#默认打开模式就为r</span></span><br><span class="line">            <span class="number">2.</span> 调用文件对象下的读/写方法，会被操作系统转换为读/写硬盘的操作</span><br><span class="line">            	data=f.read()</span><br><span class="line">            <span class="number">3.</span> 向操作系统发起关闭文件的请求，回收系统资源</span><br><span class="line">            	f.close()</span><br><span class="line"><span class="number">2.</span>资源回收与<span class="keyword">with</span>上下文管理:</span><br><span class="line">    打开一个文件包含两部分资源：应用程序的变量f和操作系统打开的文件。在操作完毕一个文件时，必须把与该文件的这两部分资源全部回收，回收方法为：</span><br><span class="line">        <span class="number">1</span>、f.close() <span class="comment">#回收操作系统打开的文件资源</span></span><br><span class="line">        <span class="number">2</span>、<span class="keyword">del</span> f <span class="comment">#回收应用程序级的变量</span></span><br><span class="line">        </span><br><span class="line">	<span class="keyword">with</span>关键字来帮我们管理上下文:</span><br><span class="line">        <span class="number">1.</span>在执行完子代码块后，<span class="keyword">with</span> 会自动执行f.close()</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">pass</span> </span><br><span class="line">        <span class="number">2.</span>可用用<span class="keyword">with</span>同时打开多个文件，用逗号分隔开即可</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> read_f,<span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> write_f:  </span><br><span class="line">                data = read_f.read()</span><br><span class="line">                write_f.write(data)</span><br><span class="line"><span class="number">3.</span>指定操作文本文件的字符编码:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="三-文件操作模式"><a href="#三-文件操作模式" class="headerlink" title="三.文件操作模式"></a>三.文件操作模式</h3><h4 id="3-1控制文件读写操作的模式"><a href="#3-1控制文件读写操作的模式" class="headerlink" title="3.1控制文件读写操作的模式"></a>3.1控制文件读写操作的模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r(默认的)：只读</span><br><span class="line">w：只写</span><br><span class="line">a：只追加写</span><br></pre></td></tr></table></figure>
<h5 id="3-1-1-案例一：r-模式的使用"><a href="#3-1-1-案例一：r-模式的使用" class="headerlink" title="3.1.1 案例一：r 模式的使用"></a>3.1.1 案例一：r 模式的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r只读模式: 在文件不存在时则报错,文件存在文件内指针直接跳到文件开头</span><br><span class="line"> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     res=f.read() <span class="comment"># 会将文件的内容由硬盘全部读入内存，赋值给res</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-案例二：w-模式的使用"><a href="#3-1-2-案例二：w-模式的使用" class="headerlink" title="3.1.2 案例二：w 模式的使用"></a>3.1.2 案例二：w 模式的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w只写模式: 在文件不存在时会创建空文档,文件存在会清空文件,文件指针跑到文件开头</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;你好\n&#x27;</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;我好\n&#x27;</span>) </span><br><span class="line">        f.write(<span class="string">&#x27;大家好\n&#x27;</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;111\n222\n333\n&#x27;</span>)</span><br><span class="line">强调：</span><br><span class="line">    <span class="number">1</span> 在文件不关闭的情况下,连续的写入，后写的内容一定跟在前写内容的后面</span><br><span class="line">    <span class="number">2</span> 如果重新以w模式打开文件，则会清空文件内容</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-案例三：a-模式的使用"><a href="#3-1-3-案例三：a-模式的使用" class="headerlink" title="3.1.3 案例三：a 模式的使用"></a>3.1.3 案例三：a 模式的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a只追加写模式: 在文件不存在时会创建空文档,文件存在会将文件指针直接移动到文件末尾</span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;c.txt&#x27;</span>,mode=<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         f.write(<span class="string">&#x27;44444\n&#x27;</span>)</span><br><span class="line">         f.write(<span class="string">&#x27;55555\n&#x27;</span>)</span><br><span class="line">强调 w 模式与 a 模式的异同：</span><br><span class="line">    <span class="number">1</span> 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后</span><br><span class="line">    <span class="number">2</span> 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-案例四：-模式的使用-了解"><a href="#3-1-4-案例四：-模式的使用-了解" class="headerlink" title="3.1.4 案例四：+ 模式的使用(了解)"></a>3.1.4 案例四：+ 模式的使用(了解)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r+ w+ a+ :可读可写</span><br><span class="line">在平时工作中，我们只单纯使用r/w/a，要么只读，要么只写，一般不用可读可写的模式</span><br></pre></td></tr></table></figure>

<h4 id="3-2-控制文件读写内容的模式"><a href="#3-2-控制文件读写内容的模式" class="headerlink" title="3.2 控制文件读写内容的模式"></a>3.2 控制文件读写内容的模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">大前提: tb模式均不能单独使用,必须与r/w/a之一结合使用</span><br><span class="line">t（默认的）：文本模式</span><br><span class="line">    <span class="number">1.</span> 读写文件都是以字符串为单位的</span><br><span class="line">    <span class="number">2.</span> 只能针对文本文件</span><br><span class="line">    <span class="number">3.</span> 必须指定encoding参数</span><br><span class="line">b：二进制模式:</span><br><span class="line">   <span class="number">1.</span>读写文件都是以<span class="built_in">bytes</span>/二进制为单位的</span><br><span class="line">   <span class="number">2.</span> 可以针对所有文件</span><br><span class="line">   <span class="number">3.</span> 一定不能指定encoding参数</span><br></pre></td></tr></table></figure>

<h5 id="3-2-1-案例一：t-模式的使用"><a href="#3-2-1-案例一：t-模式的使用" class="headerlink" title="3.2.1 案例一：t 模式的使用"></a>3.2.1 案例一：t 模式的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t 模式：如果我们指定的文件打开模式为r/w/a，其实默认就是rt/wt/at</span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         res=f.read() </span><br><span class="line">         <span class="built_in">print</span>(<span class="built_in">type</span>(res)) <span class="comment"># 输出结果为：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         s=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">         f.write(s) <span class="comment"># 写入的也必须是字符串类型</span></span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">	t 模式只能用于操作文本文件,无论读写，都应该以字符串为单位，而存取硬盘本质都是二进制的形式，当指定 t 模式时，内部帮我们做了编码与解码</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-案例二：-b-模式的使用"><a href="#3-2-2-案例二：-b-模式的使用" class="headerlink" title="3.2.2 案例二： b 模式的使用"></a>3.2.2 案例二： b 模式的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">b: 读写都是以二进制位单位</span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.mp4&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         data=f.read()</span><br><span class="line">         <span class="built_in">print</span>(<span class="built_in">type</span>(data)) <span class="comment"># 输出结果为：&lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         msg=<span class="string">&quot;你好&quot;</span></span><br><span class="line">         res=msg.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># res为bytes类型</span></span><br><span class="line">         f.write(res) <span class="comment"># 在b模式下写入文件的只能是bytes类型</span></span><br><span class="line"></span><br><span class="line">强调：b模式对比t模式</span><br><span class="line">    <span class="number">1</span>、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便</span><br><span class="line">    <span class="number">2</span>、针对非文本文件（如图片、视频、音频等）只能使用b模式</span><br><span class="line"></span><br><span class="line">小练习: 编写拷贝工具</span><br><span class="line">    src_file=<span class="built_in">input</span>(<span class="string">&#x27;源文件路径: &#x27;</span>).strip()</span><br><span class="line">    dst_file=<span class="built_in">input</span>(<span class="string">&#x27;目标文件路径: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;%s&#x27;</span> %src_file,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> read_f,<span class="built_in">open</span>(<span class="string">r&#x27;%s&#x27;</span> %dst_file,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> 		write_f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> read_f:</span><br><span class="line">            <span class="comment"># print(line)</span></span><br><span class="line">            write_f.write(line)</span><br></pre></td></tr></table></figure>

<h3 id="四-操作文件的方法"><a href="#四-操作文件的方法" class="headerlink" title="四 .操作文件的方法"></a>四 .操作文件的方法</h3><h4 id="4-1重点"><a href="#4-1重点" class="headerlink" title="4.1重点"></a>4.1重点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">读操作:</span><br><span class="line">    f.read()  <span class="comment"># 读取所有内容,执行完该操作后，文件指针会移动到文件末尾</span></span><br><span class="line">    f.readline()  <span class="comment"># 读取一行内容,光标移动到第二行首部</span></span><br><span class="line">    f.readlines()  <span class="comment"># 读取每一行内容,存放于列表中</span></span><br><span class="line"></span><br><span class="line">强调:</span><br><span class="line">	f.read()与f.readlines()都是将内容一次性读入内容，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式：   </span><br><span class="line">    方式一:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="built_in">print</span>(line) <span class="comment"># 同一时刻只读入一行内容到内存中</span></span><br><span class="line"></span><br><span class="line">    方式二:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.mp4&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data=f.read(<span class="number">1024</span>) <span class="comment"># 同一时刻只读入1024个Bytes到内存中</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="built_in">print</span>(data)</span><br><span class="line">                </span><br><span class="line">写操作:</span><br><span class="line">    f.write(<span class="string">&#x27;1111\n222\n&#x27;</span>)  <span class="comment"># 针对文本模式的写,需要自己写换行符</span></span><br><span class="line">    f.write(<span class="string">&#x27;1111\n222\n&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 针对b模式的写,需要自己写换行符</span></span><br><span class="line">    f.writelines([<span class="string">&#x27;333\n&#x27;</span>,<span class="string">&#x27;444\n&#x27;</span>])  <span class="comment"># 文件模式</span></span><br><span class="line">    f.writelines([<span class="built_in">bytes</span>(<span class="string">&#x27;333\n&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>),<span class="string">&#x27;444\n&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)]) <span class="comment">#b模式</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-了解"><a href="#4-2-了解" class="headerlink" title="4.2 了解"></a>4.2 了解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f.readable()  <span class="comment"># 文件是否可读</span></span><br><span class="line">f.writable()  <span class="comment"># 文件是否可读</span></span><br><span class="line">f.closed  <span class="comment"># 文件是否关闭</span></span><br><span class="line">f.encoding  <span class="comment"># 如果文件打开模式为b,则没有该属性</span></span><br><span class="line">f.flush()  <span class="comment"># 立刻将文件内容从内存刷到硬盘</span></span><br></pre></td></tr></table></figure>

<h3 id="五-主动控制文件内指针移动"><a href="#五-主动控制文件内指针移动" class="headerlink" title="五 .主动控制文件内指针移动"></a>五 .主动控制文件内指针移动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">大前提:文件内指针的移动都是Bytes为单位的,唯一例外的是t模式下的read(n),n以字符为单位</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         data=f.read(<span class="number">3</span>) <span class="comment"># 读取3个字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         data=f.read(<span class="number">3</span>) <span class="comment"># 读取3个Bytes</span></span><br><span class="line"></span><br><span class="line">之前文件内指针的移动都是由读/写操作而被动触发的，若想读取文件某一特定位置的数据，则则需要用f.seek方法主动控制文件内指针的移动，详细用法如下：</span><br><span class="line">	f.seek(指针移动的字节数,模式控制): </span><br><span class="line">模式控制:</span><br><span class="line">    <span class="number">0</span>: 默认的模式,该模式代表指针移动的字节数是以文件开头为参照的</span><br><span class="line">    <span class="number">1</span>: 该模式代表指针移动的字节数是以当前所在的位置为参照的</span><br><span class="line">    <span class="number">2</span>: 该模式代表指针移动的字节数是以文件末尾的位置为参照的</span><br><span class="line">    强调:其中<span class="number">0</span>模式可以在t或者b模式使用,而<span class="number">1</span>跟<span class="number">2</span>模式只能在b模式下用</span><br></pre></td></tr></table></figure>

<h4 id="5-1-案例一：-0模式详解"><a href="#5-1-案例一：-0模式详解" class="headerlink" title="5.1 案例一： 0模式详解"></a>5.1 案例一： 0模式详解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a.txt用utf-<span class="number">8</span>编码，内容如下（abc各占<span class="number">1</span>个字节，中文“你好”各占<span class="number">3</span>个字节）</span><br><span class="line">abc你好</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>模式的使用</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">3</span>,<span class="number">0</span>)     <span class="comment"># 参照文件开头移动了3个字节</span></span><br><span class="line">        <span class="built_in">print</span>(f.tell()) <span class="comment"># 查看当前文件指针距离文件开头的位置，输出结果为3</span></span><br><span class="line">        <span class="built_in">print</span>(f.read()) <span class="comment"># 从第3个字节的位置读到文件末尾，输出结果为：你好</span></span><br><span class="line">    注意：由于在t模式下，会将读取的内容自动解码，所以必须保证读取的内容是一个完整中文数据，否则解码失败</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">6</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#输出结果为: 好</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-案例二：-1模式详解"><a href="#5-2-案例二：-1模式详解" class="headerlink" title="5.2 案例二： 1模式详解"></a>5.2 案例二： 1模式详解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>模式的使用</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">3</span>,<span class="number">1</span>) <span class="comment"># 从当前位置往后移动3个字节，而此时的当前位置就是文件开头</span></span><br><span class="line">        <span class="built_in">print</span>(f.tell()) <span class="comment"># 输出结果为：3</span></span><br><span class="line">        f.seek(<span class="number">4</span>,<span class="number">1</span>)     <span class="comment"># 从当前位置往后移动4个字节，而此时的当前位置为3</span></span><br><span class="line">        <span class="built_in">print</span>(f.tell()) <span class="comment"># 输出结果为：7</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-案例三：-2模式详解"><a href="#5-3-案例三：-2模式详解" class="headerlink" title="5.3 案例三： 2模式详解"></a>5.3 案例三： 2模式详解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a.txt用utf-<span class="number">8</span>编码，内容如下（abc各占<span class="number">1</span>个字节，中文“你好”各占<span class="number">3</span>个字节）</span><br><span class="line">abc你好</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>模式的使用</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">0</span>,<span class="number">2</span>)     <span class="comment"># 参照文件末尾移动0个字节， 即直接跳到文件末尾</span></span><br><span class="line">        <span class="built_in">print</span>(f.tell()) <span class="comment"># 输出结果为：9</span></span><br><span class="line">        f.seek(-<span class="number">3</span>,<span class="number">2</span>)     <span class="comment"># 参照文件末尾往前移动了3个字节</span></span><br><span class="line">        <span class="built_in">print</span>(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 输出结果为：好</span></span><br><span class="line"></span><br><span class="line">小练习：实现动态查看最新一条日志的效果</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;access.log&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            line=f.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 没有内容</span></span><br><span class="line">                time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(line.decode(<span class="string">&#x27;utf-8&#x27;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="六-文件的修改"><a href="#六-文件的修改" class="headerlink" title="六 .文件的修改"></a>六 .文件的修改</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">文件a.txt内容如下:</span><br><span class="line">    张一蛋     山东    <span class="number">179</span>    <span class="number">49</span>    <span class="number">12344234523</span></span><br><span class="line">    李二蛋     河北    <span class="number">163</span>    <span class="number">57</span>    <span class="number">13913453521</span></span><br><span class="line">    王全蛋     山西    <span class="number">153</span>    <span class="number">62</span>    <span class="number">18651433422</span></span><br><span class="line"></span><br><span class="line">执行操作:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;r+t&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">9</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;&lt;妇女主任&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">文件修改后的内容如下:</span><br><span class="line">    张一蛋&lt;妇女主任&gt; <span class="number">179</span>    <span class="number">49</span>    <span class="number">12344234523</span></span><br><span class="line">    李二蛋     河北    <span class="number">163</span>    <span class="number">57</span>    <span class="number">13913453521</span></span><br><span class="line">    王全蛋     山西    <span class="number">153</span>    <span class="number">62</span>    <span class="number">18651433422</span></span><br><span class="line"></span><br><span class="line">强调:</span><br><span class="line">    <span class="number">1</span>、硬盘空间是无法修改的,硬盘中数据的更新都是用新内容覆盖旧内容</span><br><span class="line">    <span class="number">2</span>、内存中的数据是可以修改的</span><br></pre></td></tr></table></figure>

<h4 id="6-1-文件修改方式一"><a href="#6-1-文件修改方式一" class="headerlink" title="6.1 文件修改方式一"></a>6.1 文件修改方式一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实现思路：将文件内容发一次性全部读入内存,然后在内存中修改完毕后再覆盖写回原文件</span><br><span class="line">    优点: 在文件修改过程中同一份数据只有一份</span><br><span class="line">    缺点: 会过多地占用内存</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data=f.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(data.replace(<span class="string">&#x27;kevin&#x27;</span>,<span class="string">&#x27;SB&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="6-2文件修改方式二"><a href="#6-2文件修改方式二" class="headerlink" title="6.2文件修改方式二"></a>6.2文件修改方式二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现思路：以读的方式打开原文件,以写的方式打开一个临时文件,一行行读取原文件内容,修改完后写入临时文件...,删掉原文件,将临时文件重命名原文件名</span><br><span class="line">    优点: 不会占用过多的内存</span><br><span class="line">    缺点: 在文件修改过程中同一份数据存了两份</span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> read_f,\</span><br><span class="line">                <span class="built_in">open</span>(<span class="string">&#x27;.db.txt.swap&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> wrife_f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> read_f:</span><br><span class="line">                wrife_f.write(line.replace(<span class="string">&#x27;SB&#x27;</span>,<span class="string">&#x27;kevin&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        os.remove(<span class="string">&#x27;db.txt&#x27;</span>)</span><br><span class="line">        os.rename(<span class="string">&#x27;.db.txt.swap&#x27;</span>,<span class="string">&#x27;db.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/21/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%AE%80%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/21/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%AE%80%E7%89%88/" class="post-title-link" itemprop="url">网络编程精简版</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-21 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-21T17:27:55+08:00">2018-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络编程精简版"><a href="#网络编程精简版" class="headerlink" title="网络编程精简版"></a>网络编程精简版</h1><h2 id="一-osi七层，tcp-ip-5层"><a href="#一-osi七层，tcp-ip-5层" class="headerlink" title="一.osi七层，tcp/ip 5层"></a>一.osi七层，tcp/ip 5层</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> cs架构和bs架构</span><br><span class="line"><span class="number">2</span> 互联网</span><br><span class="line"><span class="number">3</span> osi七层、<span class="number">5</span>层（<span class="number">5</span>层名字记住：重点）</span><br><span class="line">	-物理层</span><br><span class="line">    	-网线，光纤</span><br><span class="line">    -数据链路层</span><br><span class="line">    	-网卡</span><br><span class="line">    -网络层</span><br><span class="line">    	-路由器</span><br><span class="line">    -传输层（运输层）</span><br><span class="line">    	-四层路由器</span><br><span class="line">    -应用层(会话层，表示层，应用层)</span><br><span class="line">    	-http协议，ftp协议，websocket协议。。。</span><br></pre></td></tr></table></figure>

<h3 id="1-1每一层功能"><a href="#1-1每一层功能" class="headerlink" title="1.1每一层功能"></a>1.1每一层功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 物理层</span><br><span class="line">	-网线----》01010101电信号---》从网线中传输电信号</span><br><span class="line">    -<span class="number">8</span>个比特位是一个字节</span><br><span class="line"><span class="number">2</span> 数据链路层</span><br><span class="line">	-数据帧：一组电信号是一个数据帧，有头和数据部分</span><br><span class="line">	-网卡---》mac地址---》全球唯一---》网卡出厂--》烧在了网卡上</span><br><span class="line">    -<span class="number">48</span>位二进制---》看到的都是<span class="number">16</span>进制表示</span><br><span class="line">    -广播：</span><br><span class="line">   		-局域网内通信，所有人都会接受到，通过mac地址确定给谁的数据报，如果不是自己的就不处理</span><br><span class="line">    -广播风暴</span><br><span class="line"> <span class="number">3</span> 网络层</span><br><span class="line">	-跨局域网通信，需要经过网络层</span><br><span class="line">    -IP地址：<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>-<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    -子网掩码：</span><br><span class="line">    -<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>  <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    -<span class="number">192.168</span><span class="number">.2</span><span class="number">.1</span>  <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    -ARP：ip和mac的对照表</span><br><span class="line">    </span><br><span class="line"> <span class="number">4</span> 传输层：</span><br><span class="line">	-端口：<span class="number">0</span>--<span class="number">65535</span>，一个应用程序可以监听多个端口，但是一个端口只能属于一个应用程序</span><br><span class="line">    -TCP协议：可靠传输（可靠传输如何保证？三次握手，四次挥手）</span><br><span class="line">    -UDP协议：不可靠传输</span><br><span class="line"><span class="number">5</span> 应用层</span><br><span class="line">	-htpp，ftp，websocket....</span><br></pre></td></tr></table></figure>



<h3 id="1-2常用端口号"><a href="#1-2常用端口号" class="headerlink" title="1.2常用端口号"></a>1.2常用端口号</h3><table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td><strong>TCP</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>DNS:把网址转换成ip地址</p>
<p>从浏览器发送出去的数据，都是http协议，默认是80端口</p>
</blockquote>
<h3 id="1-3Tcp三次握手四次挥手（面试题）"><a href="#1-3Tcp三次握手四次挥手（面试题）" class="headerlink" title="1.3Tcp三次握手四次挥手（面试题）"></a>1.3Tcp三次握手四次挥手（面试题）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> tcp可靠传输：三次握手，四次挥手保证数据可靠</span><br><span class="line"><span class="number">2</span> 三次握手</span><br><span class="line">	-客户端向服务端发送链接请求  </span><br><span class="line">    -服务端回复可以建立，并且带着跟客户端建立链接的数据报  </span><br><span class="line">    -客户端收到后，链接建好了    </span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> 这个过程后就可以可靠传输数据</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 断开链接（<span class="number">4</span>四挥手）</span><br><span class="line">	-客户端告诉服务端，要断开   </span><br><span class="line">    -服务端收到，回复ok        </span><br><span class="line">    -服务端可能还有数据在传递，暂时还没断开---等数据传完</span><br><span class="line">    -服务端告诉客户端，我要断了  </span><br><span class="line">    -客户端收到，回复ok        </span><br></pre></td></tr></table></figure>

<h2 id="二-Socket层"><a href="#二-Socket层" class="headerlink" title="二.Socket层"></a>二.Socket层</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Socket抽象层,从osi七层抽象出来的，抽象了网络层和传输层，跟语言无关，任何语言都会有socket的封装</span><br><span class="line"><span class="number">2</span> 专门给开发人员用的</span><br></pre></td></tr></table></figure>



<h2 id="三-基于Tcp的socket套接字-重点"><a href="#三-基于Tcp的socket套接字-重点" class="headerlink" title="三.基于Tcp的socket套接字(重点)"></a>三.基于Tcp的socket套接字(重点)</h2><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 第一个socket是模块名，第二个socket是类名</span></span><br><span class="line"><span class="comment">#类实例化得到对象，得到一个socket对象</span></span><br><span class="line"><span class="comment"># server=socket.socket(family=socket.AF_INET,type=socket.SOCK_STREAM)</span></span><br><span class="line"><span class="comment">#不写默认就是他</span></span><br><span class="line">server=socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定地址跟端口  ,传一个元组，监听的地址，监听的端口</span></span><br><span class="line">server.bind((<span class="string">&#x27;192.168.11.28&#x27;</span>,<span class="number">8008</span>))</span><br><span class="line"><span class="comment">#监听</span></span><br><span class="line"><span class="comment"># 半连接池是5，可以缓冲5个</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#等待用户连接(看源码，有两个返回结果)</span></span><br><span class="line"><span class="comment"># sock是连接对象，以后这个服务端和客户端交互，使用这个对象交互</span></span><br><span class="line"><span class="comment"># addr是客户端地址（ip和端口）</span></span><br><span class="line">sock,addr=server.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收客户端发给我的消息</span></span><br><span class="line">data=sock.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端给客户端发送消息（必须是byte格式）</span></span><br><span class="line">sock.send(<span class="string">b&#x27;helloworld&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 关闭连接对象</span></span><br><span class="line">sock.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭服务</span></span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象</span></span><br><span class="line">client=socket.socket()</span><br><span class="line"><span class="comment"># 连接服务端</span></span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8008</span>))</span><br><span class="line"><span class="comment">#给服务端发了一个sb</span></span><br><span class="line">client.send(<span class="string">b&#x27;sb&#x27;</span>)</span><br><span class="line"><span class="comment"># 收到了服务端给我的</span></span><br><span class="line">data=client.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-1加入链接循环的套接字服务端"><a href="#2-1加入链接循环的套接字服务端" class="headerlink" title="2.1加入链接循环的套接字服务端"></a>2.1加入链接循环的套接字服务端</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.1 基于文件类型的套接字家族</span></span><br><span class="line"><span class="string">套接字家族的名字：AF_UNIX</span></span><br><span class="line"><span class="string">unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.2 基于网络类型的套接字家族</span></span><br><span class="line"><span class="string">套接字家族的名字：AF_INET</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#实例化得到一个对象</span></span><br><span class="line"><span class="comment">#type=socket.SOCK_STREAM   TCP服务端</span></span><br><span class="line"><span class="comment">#type=socket.SOCK_DGRAM   UDP服务端</span></span><br><span class="line">server=socket.socket(family=socket.AF_INET, <span class="built_in">type</span>=socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定地址和端口</span></span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># listen:监听</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待用户连接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始等待客户端连接了&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sock,addr=server.accept()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(sock)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端的地址是：&#x27;</span>,addr)</span><br><span class="line"></span><br><span class="line">    data=sock.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这不是字符串的upper</span></span><br><span class="line">    sock.send(data.upper())</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client=socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">client.send(<span class="string">&#x27;sb&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">data=client.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-2加入通信循环的套接字服务端"><a href="#2-2加入通信循环的套接字服务端" class="headerlink" title="2.2加入通信循环的套接字服务端"></a>2.2加入通信循环的套接字服务端</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">server=socket.socket(family=socket.AF_INET, <span class="built_in">type</span>=socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">81</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始等待客户端连接了&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    sock,addr=server.accept()</span><br><span class="line">    <span class="built_in">print</span>(sock)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端的地址是：&#x27;</span>,addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待客户端发送过来的数据，如果客户端没有发送数据，会一直等着</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data=sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data)==<span class="number">0</span>: <span class="comment"># 这个表示客户端正常断开了，结束通信循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            sock.send(data.upper())</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e) <span class="comment">#客户端非正常断开，需要异常捕获</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client=socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">81</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    input_data=<span class="built_in">input</span>(<span class="string">&#x27;请输入发送给客户端的内容（输入q退出）：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> input_data==<span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client.send(input_data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    data=client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<h2 id="四-基于UDP的套接字客户端和服务端"><a href="#四-基于UDP的套接字客户端和服务端" class="headerlink" title="四.基于UDP的套接字客户端和服务端"></a>四.基于UDP的套接字客户端和服务端</h2><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># udp的服务端</span></span><br><span class="line">server = socket.socket(<span class="built_in">type</span>=socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听地址和端口</span></span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">82</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要listen，直接建立链接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;等待客户端发送数据：&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#recvfrom会返回数据和客户端的地址</span></span><br><span class="line">    data,addr = server.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    server.sendto(data.upper(), addr)</span><br><span class="line"></span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=socket.socket(<span class="built_in">type</span>=socket.SOCK_DGRAM)</span><br><span class="line">client.sendto(<span class="string">b&#x27;sb&#x27;</span>,(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">82</span>))</span><br><span class="line"><span class="comment"># data,addr=client.recvfrom(1024)</span></span><br><span class="line"><span class="comment"># data,_=client.recvfrom(1024)</span></span><br><span class="line">data=client.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># print(addr)</span></span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-20 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-20T17:27:55+08:00">2018-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h3 id="一-客户端-服务器架构"><a href="#一-客户端-服务器架构" class="headerlink" title="一 客户端/服务器架构"></a>一 客户端/服务器架构</h3><p>1.硬件C/S架构(打印机)</p>
<p>2.软件C/S架构</p>
<p><em>互联网中处处是C/S架构</em></p>
<p><em>如黄色网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种）</em></p>
<p><em>腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）</em></p>
<p>C/S架构与socket的关系：</p>
<p><em>我们学习socket就是为了完成C/S架构的开发</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学习网络编程的目的是为了开发一个CS架构或者BS架构的软件</span><br><span class="line">    Client------------网络------------------Server</span><br><span class="line">    Browser-----------网络------------------Server</span><br></pre></td></tr></table></figure>

<h3 id="二-osi七层"><a href="#二-osi七层" class="headerlink" title="二 osi七层"></a>二 osi七层</h3><p><strong>引子：</strong></p>
<p><em>须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</em></p>
<p><em>如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</em></p>
<p><em>互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语</em></p>
<p><em>如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</em></p>
<p><em>人们按照分工不同把互联网协议从逻辑上划分了层级，</em></p>
<p><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p>
<p><strong>为何学习socket一定要先学习互联网协议：</strong></p>
<p><em>1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件</em></p>
<p><em>2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的</em></p>
<p><em>3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。</em></p>
<p><em>4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅</em></p>
<p><img src="https://pic4.zhimg.com/80/v2-3f2ab5646d1bbca993e920c8ae27f40f_720w.jpg" alt="img"></p>
<h4 id="2-1osi七层，tcp-ip-5层"><a href="#2-1osi七层，tcp-ip-5层" class="headerlink" title="2.1osi七层，tcp/ip 5层"></a>2.1osi七层，tcp/ip 5层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 cs架构和bs架构</span><br><span class="line">2 互联网</span><br><span class="line">3 osi七层、5层（5层名字记住：重点）</span><br><span class="line">	-物理层</span><br><span class="line">    	-网线，光纤</span><br><span class="line">    -数据链路层</span><br><span class="line">    	-网卡</span><br><span class="line">    -网络层</span><br><span class="line">    	-路由器</span><br><span class="line">    -传输层（运输层）</span><br><span class="line">    	-四层路由器</span><br><span class="line">    -应用层(会话层，表示层，应用层)</span><br><span class="line">    	-http协议，ftp协议，websocket协议。。。</span><br></pre></td></tr></table></figure>

<h4 id="2-2每一层功能"><a href="#2-2每一层功能" class="headerlink" title="2.2每一层功能"></a>2.2每一层功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1 物理层</span><br><span class="line">	-网线----》01010101电信号---》从网线中传输电信号</span><br><span class="line">    -8个比特位是一个字节</span><br><span class="line">2 数据链路层</span><br><span class="line">	-数据帧：一组电信号是一个数据帧，有头和数据部分</span><br><span class="line">	-网卡---》mac地址---》全球唯一---》网卡出厂--》烧在了网卡上</span><br><span class="line">    -48位二进制---》看到的都是16进制表示</span><br><span class="line">    -广播：</span><br><span class="line">   		-局域网内通信，所有人都会接受到，通过mac地址确定给谁的数据报，如果不是自己的就不处理</span><br><span class="line">    -广播风暴</span><br><span class="line"> 3 网络层</span><br><span class="line">	-跨局域网通信，需要经过网络层</span><br><span class="line">    -IP地址：0.0.0.0-255.255.255.255</span><br><span class="line">    -子网掩码：</span><br><span class="line">    -192.168.1.1  255.255.255.0</span><br><span class="line">    -192.168.2.1  255.255.255.0</span><br><span class="line">    -ARP：ip和mac的对照表</span><br><span class="line">    </span><br><span class="line"> 4 传输层：</span><br><span class="line">	-端口：0--65535，一个应用程序可以监听多个端口，但是一个端口只能属于一个应用程序</span><br><span class="line">    -TCP协议：可靠传输（可靠传输如何保证？三次握手，四次挥手）</span><br><span class="line">    -UDP协议：不可靠传输</span><br><span class="line">5 应用层</span><br><span class="line">	-htpp，ftp，websocket....</span><br></pre></td></tr></table></figure>

<h4 id="2-3常用端口号"><a href="#2-3常用端口号" class="headerlink" title="2.3常用端口号"></a>2.3常用端口号</h4><table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td><strong>TCP</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>DNS:把网址转换成ip地址</p>
<p>从浏览器发送出去的数据，都是http协议，默认是80端口</p>
</blockquote>
<h4 id="2-4Tcp三次握手四次挥手（面试题）"><a href="#2-4Tcp三次握手四次挥手（面试题）" class="headerlink" title="2.4Tcp三次握手四次挥手（面试题）"></a>2.4Tcp三次握手四次挥手（面试题）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> tcp可靠传输：三次握手，四次挥手保证数据可靠</span><br><span class="line"><span class="number">2</span> 三次握手</span><br><span class="line">	-客户端向服务端发送链接请求  </span><br><span class="line">    -服务端回复可以建立，并且带着跟客户端建立链接的数据报  </span><br><span class="line">    -客户端收到后，链接建好了    </span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> 这个过程后就可以可靠传输数据</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 断开链接（<span class="number">4</span>四挥手）</span><br><span class="line">	-客户端告诉服务端，要断开   </span><br><span class="line">    -服务端收到，回复ok        </span><br><span class="line">    -服务端可能还有数据在传递，暂时还没断开---等数据传完</span><br><span class="line">    -服务端告诉客户端，我要断了  </span><br><span class="line">    -客户端收到，回复ok        </span><br></pre></td></tr></table></figure>

<h3 id="三-socket层"><a href="#三-socket层" class="headerlink" title="三 socket层"></a>三 socket层</h3><p>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a4a1fd105e5e7af5d7db820b303ad7e2_720w.jpg" alt="img"></p>
<h3 id="四-socket是什么"><a href="#四-socket是什么" class="headerlink" title="四 socket是什么"></a>四 socket是什么</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Socket抽象层,从osi七层抽象出来的，抽象了网络层和传输层，跟语言无关，任何语言都会有socket的封装</span><br><span class="line">2 专门给开发人员用的</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序</span><br><span class="line"></span><br><span class="line">而程序的pid是同一台机器上不同进程或者线程的标识</span><br></pre></td></tr></table></figure>

<h3 id="五-套接字发展史及分类"><a href="#五-套接字发展史及分类" class="headerlink" title="五 套接字发展史及分类"></a>五 套接字发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p>
<p>*<strong>基于文件类型的套接字家族*</strong></p>
<p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p>*<strong>基于网络类型的套接字家族*</strong></p>
<p>套接字家族的名字：AF_INET</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="六-套接字工作流程"><a href="#六-套接字工作流程" class="headerlink" title="六 套接字工作流程"></a>六 套接字工作流程</h3><p> 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。</p>
<p><img src="https://pic1.zhimg.com/80/v2-7d4ff6c59a5201bac25926b792826a40_720w.jpg" alt="img"></p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>
<p>socket()模块函数用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(socket_family,socket_type,protocal=<span class="number">0</span>)</span><br><span class="line">socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">获取tcp/ip套接字</span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"> </span><br><span class="line">获取udp/ip套接字</span><br><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"> </span><br><span class="line">由于 socket 模块中有太多的属性。我们在这里破例使用了<span class="string">&#x27;from module import *&#x27;</span>语句。使用 <span class="string">&#x27;from socket import *&#x27;</span>,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。</span><br><span class="line"></span><br><span class="line">例如tcpSock = socket(AF_INET, SOCK_STREAM</span><br></pre></td></tr></table></figure>

<p><em><strong>服务端套接字函数</strong></em><br>        s.bind() 绑定(主机,端口号)到套接字<br>        s.listen() 开始TCP监听<br>        s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来</p>
<p><em><strong>客户端套接字函数</strong></em><br>        s.connect() 主动初始化TCP服务器连接<br>        s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</p>
<p><em><strong>公共用途的套接字函数</strong></em><br>        s.recv() 接收TCP数据<br>        s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)<br>        s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)<br>        s.recvfrom() 接收UDP数据<br>        s.sendto() 发送UDP数据<br>        s.getpeername() 连接到当前套接字的远端的地址<br>        s.getsockname() 当前套接字的地址<br>        s.getsockopt() 返回指定套接字的参数<br>        s.setsockopt() 设置指定套接字的参数<br>        s.close() 关闭套接字</p>
<p><em><strong>面向锁的套接字方法</strong></em><br>        s.setblocking() 设置套接字的阻塞与非阻塞模式<br>        s.settimeout() 设置阻塞套接字操作的超时时间<br>        s.gettimeout() 得到阻塞套接字操作的超时时间</p>
<p><em><strong>面向文件的套接字的函数</strong></em><br>        s.fileno() 套接字的文件描述符<br>        s.makefile() 创建一个与该套接字相关的文件</p>
<h3 id="七-基于TCP的套接字"><a href="#七-基于TCP的套接字" class="headerlink" title="七 基于TCP的套接字"></a>七 基于TCP的套接字</h3><p><strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</strong></p>
<p><strong>tcp服务端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ss = socket() <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()      <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">ss.listen()      <span class="comment">#监听链接</span></span><br><span class="line">inf_loop:      <span class="comment">#服务器无限循环</span></span><br><span class="line">     cs = ss.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">     comm_loop:         <span class="comment">#通讯循环</span></span><br><span class="line">         cs.recv()/cs.send() <span class="comment">#对话(接收与发送)</span></span><br><span class="line">     cs.close()    <span class="comment">#关闭客户端套接字</span></span><br><span class="line">ss.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>tcp客户端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()    <span class="comment"># 创建客户套接字</span></span><br><span class="line">cs.connect()    <span class="comment"># 尝试连接服务器</span></span><br><span class="line">comm_loop:        <span class="comment"># 通讯循环</span></span><br><span class="line">     cs.send()/cs.recv()    <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()            <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p>socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信</p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)  <span class="comment">#电话卡</span></span><br><span class="line">BUFSIZE=<span class="number">1024</span>                <span class="comment">#收发消息的尺寸</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="comment">#买手机</span></span><br><span class="line">s.bind(ip_port) <span class="comment">#手机插卡</span></span><br><span class="line">s.listen(<span class="number">5</span>)     <span class="comment">#手机待机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=s.accept()            <span class="comment">#手机接电话</span></span><br><span class="line"><span class="comment"># print(conn)</span></span><br><span class="line"><span class="comment"># print(addr)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;接到来自%s的电话&#x27;</span> %addr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">msg=conn.recv(BUFSIZE)             <span class="comment">#听消息,听话</span></span><br><span class="line"><span class="built_in">print</span>(msg,<span class="built_in">type</span>(msg))</span><br><span class="line"></span><br><span class="line">conn.send(msg.upper())          <span class="comment">#发消息,说话</span></span><br><span class="line"></span><br><span class="line">conn.close()                    <span class="comment">#挂电话</span></span><br><span class="line"></span><br><span class="line">s.close()                       <span class="comment">#手机关机</span></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)   <span class="comment">#拨电话</span></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;linhaifeng nb&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))     <span class="comment">#发消息,说话(只能发送字节类型)</span></span><br><span class="line"></span><br><span class="line">feedback=s.recv(BUFSIZE)      <span class="comment">#收消息,听话</span></span><br><span class="line"><span class="built_in">print</span>(feedback.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">s.close()        <span class="comment">#挂电话</span></span><br></pre></td></tr></table></figure>

<p>加上链接循环与通信循环</p>
<p>服务端改进版:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)<span class="comment">#电话卡</span></span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="comment">#买手机</span></span><br><span class="line">s.bind(ip_port) <span class="comment">#手机插卡</span></span><br><span class="line">s.listen(<span class="number">5</span>)     <span class="comment">#手机待机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:         <span class="comment">#新增接收链接循环,可以不停的接电话</span></span><br><span class="line">    conn,addr=s.accept()            <span class="comment">#手机接电话</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;接到来自%s的电话&#x27;</span> %addr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:                         <span class="comment">#新增通信循环,可以不断的通信,收发消息</span></span><br><span class="line">        msg=conn.recv(BUFSIZE)             <span class="comment">#听消息,听话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if len(msg) == 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(msg,<span class="built_in">type</span>(msg))</span><br><span class="line"></span><br><span class="line">        conn.send(msg.upper())          <span class="comment">#发消息,说话</span></span><br><span class="line"></span><br><span class="line">    conn.close()                    <span class="comment">#挂电话</span></span><br><span class="line"></span><br><span class="line">s.close()                       <span class="comment">#手机关机</span></span><br></pre></td></tr></table></figure>

<p>客户端改进版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)     <span class="comment">#拨电话</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:     <span class="comment">#新增通信循环,客户端可以不断发收消息</span></span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))   <span class="comment">#发消息,说话(只能发送字节类型)</span></span><br><span class="line"></span><br><span class="line">    feedback=s.recv(BUFSIZE)           <span class="comment">#收消息,听话</span></span><br><span class="line">    <span class="built_in">print</span>(feedback.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">s.close()          <span class="comment">#挂电话</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>重启服务端时可能会遇到</p>
<p><img src="https://pic2.zhimg.com/80/v2-aeeffa09a60bc1037ae69a2856cf8941_720w.png" alt="img"></p>
<p>这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）</p>
<p>解决方法：</p>
<p>方法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入一条socket配置，重用ip和端口</span></span><br><span class="line"></span><br><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，</span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">编辑文件，加入以下内容：</span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">然后执行 /sbin/sysctl -p 让参数生效。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="number">0</span>，表示关闭。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

<h3 id="八-基于UDP的套接字"><a href="#八-基于UDP的套接字" class="headerlink" title="八 基于UDP的套接字"></a>八 基于UDP的套接字</h3><p><strong>udp是无链接的，先启动哪一端都不会报错</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ss = socket()   <span class="comment">#创建一个服务器的套接字</span></span><br><span class="line"><span class="number">2</span> ss.bind()       <span class="comment">#绑定服务器套接字</span></span><br><span class="line"><span class="number">3</span> inf_loop:       <span class="comment">#服务器无限循环</span></span><br><span class="line"><span class="number">4</span>     cs = ss.recvfrom()/ss.sendto() <span class="comment"># 对话(接收与发送)</span></span><br><span class="line"><span class="number">5</span> ss.close()                         <span class="comment"># 关闭服务器套接字</span></span><br></pre></td></tr></table></figure>

<p>udp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()   <span class="comment"># 创建客户套接字</span></span><br><span class="line">comm_loop:      <span class="comment"># 通讯循环</span></span><br><span class="line">    cs.sendto()/cs.recvfrom()   <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()                      <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>udp套接字简单示例</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    <span class="built_in">print</span>(msg,addr)</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br></pre></td></tr></table></figure>

<p>udp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    <span class="built_in">print</span>(back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br></pre></td></tr></table></figure>

<p><strong>qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)</strong></p>
<p>udp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>)</span><br><span class="line">udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) <span class="comment">#买手机</span></span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_msg,addr=udp_server_sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],qq_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    back_msg=<span class="built_in">input</span>(<span class="string">&#x27;回复消息: &#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br></pre></td></tr></table></figure>

<p>udp客户端1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">&#x27;狗哥alex&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;瞎驴&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;一棵树&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;武大郎&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=<span class="built_in">input</span>(<span class="string">&#x27;请选择聊天对象: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入消息,回车发送: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<p>udp客户端2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">&#x27;狗哥alex&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;瞎驴&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;一棵树&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">&#x27;武大郎&#x27;</span>:(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=<span class="built_in">input</span>(<span class="string">&#x27;请选择聊天对象: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入消息,回车发送: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<p>服务端运行结果</p>
<p><img src="https://pic3.zhimg.com/80/v2-b8475dd2de46da061d4f507bc2414206_720w.jpg" alt="img"></p>
<p>客户端1运行结果</p>
<p><img src="https://pic1.zhimg.com/80/v2-7fa4072d1b9ed772c81fe72b20497eec_720w.jpg" alt="img"></p>
<p>客户端2运行结果</p>
<p><img src="https://pic2.zhimg.com/80/v2-c70ea48a4774814cbc6d58657b811539_720w.jpg" alt="img"></p>
<p><strong>时间服务器</strong></p>
<p>ntp服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg,addr=tcp_server.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===&gt;&#x27;</span>,msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        time_fmt=<span class="string">&#x27;%Y-%m-%d %X&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_fmt=msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    back_msg=strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>

<p>ntp客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;请输入时间格式(例%Y %m %d)&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line">    data=tcp_client.recv(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">tcp_client.close()</span><br></pre></td></tr></table></figure>

<h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）</p>
<p><strong>注意注意注意：</strong></p>
<p>res=subprocess.Popen(cmd.decode(‘utf-8’), shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)</p>
<p>的结果的编码是以当前所在的系统为准的，如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p>
<p><strong>且只能从管道里读一次结果</strong></p>
<p>注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=tcp_socket_server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端&#x27;</span>,addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,</span><br><span class="line">                         stdout=subprocess.PIPE,</span><br><span class="line">                         stdin=subprocess.PIPE,</span><br><span class="line">                         stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr=act_res.stderr.read()</span><br><span class="line">        stdout=act_res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    act_res=s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(act_res.decode(<span class="string">&#x27;utf-8&#x27;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于tcp的socket，在运行时会发生粘包</p>
<p>让我们再基于udp制作一个远程执行命令的程序</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9003</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#收消息</span></span><br><span class="line">    cmd,addr=udp_server.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;用户命令-----&gt;&#x27;</span>,cmd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#逻辑处理</span></span><br><span class="line">    res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)</span><br><span class="line">    stderr=res.stderr.read()</span><br><span class="line">    stdout=res.stdout.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#发消息</span></span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9003</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    data,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于udp的socket，在运行时永远不会发生粘包</p>
<h3 id="十-什么是粘包"><a href="#十-什么是粘包" class="headerlink" title="十 什么是粘包"></a>十 什么是粘包</h3><p>须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来</p>
<p>首先需要掌握一个socket收发消息的原理</p>
<p><img src="https://pic4.zhimg.com/80/v2-5e9568f888a55cd273aca6f561cea2d7_720w.jpg" alt="img"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。</p>
<p>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p>
<p>此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">算法</a>把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li>
<li><strong>tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略</strong></li>
</ol>
<p>udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠</p>
<p>tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</p>
<p>*<strong>两种情况下会发生粘包。*</strong></p>
<p>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">10</span>)</span><br><span class="line">data2=conn.recv(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.send(<span class="string">&#x27;feng&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">2</span>) <span class="comment">#一次没有收完整</span></span><br><span class="line">data2=conn.recv(<span class="number">10</span>)<span class="comment">#下次收的时候,会先取旧的数据,然后取新的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,data2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">&#x27;hello feng&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>*<strong>拆包的发生情况*</strong></p>
<p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。</p>
<p>*<strong>补充问题一：为何tcp是可靠传输，udp是不可靠传输*</strong></p>
<p>基于tcp的数据传输请参考我的另一篇文章<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">http://www.cnblogs.com/linhaifeng/articles/5937962.html</a>，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的</p>
<p>而udp发送数据，对端是不会返回确认信息的，因此不可靠</p>
<p>*<strong>补充问题二：send(字节流)和recv(1024)及sendall*</strong></p>
<p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据</p>
<p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失</p>
<h3 id="十一-解决粘包的low比处理方法"><a href="#十一-解决粘包的low比处理方法" class="headerlink" title="十一 解决粘包的low比处理方法"></a>十一 解决粘包的low比处理方法</h3><p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据</p>
<p>low版本的解决方法</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,subprocess</span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s.bind(ip_port)</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=s.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端&#x27;</span>,addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">break</span></span><br><span class="line">        res=subprocess.Popen(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>),shell=<span class="literal">True</span>,\</span><br><span class="line">                            stdin=subprocess.PIPE,\</span><br><span class="line">                         stderr=subprocess.PIPE,\</span><br><span class="line">                         stdout=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            ret=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret=res.stdout.read()</span><br><span class="line">        data_length=<span class="built_in">len</span>(ret)</span><br><span class="line">        conn.send(<span class="built_in">str</span>(data_length).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;recv_ready&#x27;</span>:</span><br><span class="line">            conn.sendall(ret)</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,time</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    length=<span class="built_in">int</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    s.send(<span class="string">&#x27;recv_ready&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    send_size=<span class="number">0</span></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; length:</span><br><span class="line">        data+=s.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=<span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>为何low：</p>
<p>程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</p>
<h3 id="十二-峰哥解决粘包的方法"><a href="#十二-峰哥解决粘包的方法" class="headerlink" title="十二 峰哥解决粘包的方法"></a>十二 峰哥解决粘包的方法</h3><p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p>
<p><strong>struct模块</strong></p>
<p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<p>&gt;&gt;&gt; struct.pack(‘i’,1111111111111)</p>
<p>。。。。。。。。。</p>
<p>struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</p>
<p><img src="https://pic2.zhimg.com/80/v2-d7c66c9a0abe12041ae948a553b908c9_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json,struct</span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line">header=&#123;<span class="string">&#x27;file_size&#x27;</span>:<span class="number">1073741824000</span>,<span class="string">&#x27;file_name&#x27;</span>:<span class="string">&#x27;/a/b/c/d/e/a.txt&#x27;</span>,<span class="string">&#x27;md5&#x27;</span>:<span class="string">&#x27;8f6fbf8347faa4924a76856701edb0f3&#x27;</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=<span class="built_in">bytes</span>(json.dumps(header),encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#序列化并转成bytes,用于传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">&#x27;i&#x27;</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">&#x27;file_size&#x27;</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>

<p>关于struct的详细用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">values1 = (<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="number">2.7</span>)</span><br><span class="line">values2 = (<span class="string">&#x27;defg&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">101</span>)</span><br><span class="line">s1 = struct.Struct(<span class="string">&#x27;I3sf&#x27;</span>)</span><br><span class="line">s2 = struct.Struct(<span class="string">&#x27;4sI&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before : &#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="comment"># t=binascii.hexlify(&#x27;asdfaf&#x27;.encode(&#x27;utf-8&#x27;))</span></span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,<span class="number">0</span>,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After pack&#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="built_in">print</span>(s1.unpack_from(prebuffer,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(<span class="string">&#x27;ii&#x27;</span>)</span><br><span class="line">s3.pack_into(prebuffer,<span class="number">0</span>,<span class="number">123</span>,<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After pack&#x27;</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="built_in">print</span>(s3.unpack_from(prebuffer,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>服务端（自定制报头）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cmd: %s&#x27;</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(back_msg))) <span class="comment">#先发back_msg的长度</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端（自定制报头）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket,time,struct</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l=s.recv(<span class="number">4</span>)</span><br><span class="line">    x=struct.unpack(<span class="string">&#x27;i&#x27;</span>,l)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(x),x)</span><br><span class="line">    <span class="comment"># print(struct.unpack(&#x27;I&#x27;,l))</span></span><br><span class="line">    r_s=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> r_s &lt; x:</span><br><span class="line">        r_d=s.recv(<span class="number">1024</span>)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=<span class="built_in">len</span>(r_d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.decode(&#x27;utf-8&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;gbk&#x27;</span>)) <span class="comment">#windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<p>发送时：</p>
<p>先发报头长度</p>
<p>再编码报头内容然后发送</p>
<p>最后发真实内容</p>
<p>接收时：</p>
<p>先手报头长度，用struct取出来</p>
<p>根据取出的长度收取报头内容，然后解码，反序列化</p>
<p>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p>
<p>服务端：定制稍微复杂一点的报头</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cmd: %s&#x27;</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">&#x27;data_size&#x27;</span>:<span class="built_in">len</span>(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))) <span class="comment">#先发报头的长度</span></span><br><span class="line">        conn.send(head_json_bytes) <span class="comment">#再发报头</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,json</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(<span class="built_in">bytes</span>(cmd,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">&#x27;i&#x27;</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data_len=head_json[<span class="string">&#x27;data_size&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=<span class="built_in">len</span>(recv_data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(recv_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">#print(recv_data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<p>FTP作业：上传下载文件</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPServer</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    server_dir=<span class="string">&#x27;file_upload&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, bind_and_activate=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.server_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_bind</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called by constructor to bind the socket.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.allow_reuse_address:</span><br><span class="line">            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        self.socket.bind(self.server_address)</span><br><span class="line">        self.server_address = self.socket.getsockname()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_activate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called by constructor to activate the server.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called to clean-up the server.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get the request and client address from the socket.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.socket.accept()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span></span><br><span class="line">        request.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.conn,self.client_addr=self.get_request()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;from client &#x27;</span>,self.client_addr)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    head_struct = self.conn.recv(<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> head_struct:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    head_len = struct.unpack(<span class="string">&#x27;i&#x27;</span>, head_struct)[<span class="number">0</span>]</span><br><span class="line">                    head_json = self.conn.recv(head_len).decode(self.coding)</span><br><span class="line">                    head_dic = json.loads(head_json)</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">print</span>(head_dic)</span><br><span class="line">                    <span class="comment">#head_dic=&#123;&#x27;cmd&#x27;:&#x27;put&#x27;,&#x27;filename&#x27;:&#x27;a.txt&#x27;,&#x27;filesize&#x27;:123123&#125;</span></span><br><span class="line">                    cmd=head_dic[<span class="string">&#x27;cmd&#x27;</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                        func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                        func(head_dic)</span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        file_path=os.path.normpath(os.path.join(</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize=args[<span class="string">&#x27;filesize&#x27;</span>]</span><br><span class="line">        recv_size=<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>,file_path)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> recv_size &lt; filesize:</span><br><span class="line">                recv_data=self.conn.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size+=<span class="built_in">len</span>(recv_data)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;recvsize:%s filesize:%s&#x27;</span> %(recv_size,filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpserver1=MYTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">tcpserver1.run()</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPClient</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, connect=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> connect:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.client_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            inp=<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inp:<span class="keyword">continue</span></span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        cmd=args[<span class="number">0</span>]</span><br><span class="line">        filename=args[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;file:%s is not exists&#x27;</span> %filename)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;<span class="string">&#x27;cmd&#x27;</span>:cmd,<span class="string">&#x27;filename&#x27;</span>:os.path.basename(filename),<span class="string">&#x27;filesize&#x27;</span>:filesize&#125;</span><br><span class="line">        <span class="built_in">print</span>(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=<span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=<span class="built_in">len</span>(line)</span><br><span class="line">                <span class="built_in">print</span>(send_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;upload successful&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>

<h3 id="十三-认证客户端的链接合法性"><a href="#十三-认证客户端的链接合法性" class="headerlink" title="十三 认证客户端的链接合法性"></a>十三 认证客户端的链接合法性</h3><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    认证客户端链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始验证新链接的合法性&#x27;</span>)</span><br><span class="line">    msg=os.urandom(<span class="number">32</span>)</span><br><span class="line">    conn.sendall(msg)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    respone=conn.recv(<span class="built_in">len</span>(digest))</span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(respone,digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_handler</span>(<span class="params">conn,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> conn_auth(conn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;该链接不合法,关闭&#x27;</span>)</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;链接合法,开始通信&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=conn.recv(bufsize)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">break</span></span><br><span class="line">        conn.sendall(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_handler</span>(<span class="params">ip_port,bufsize,backlog=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    只处理链接</span></span><br><span class="line"><span class="string">    :param ip_port:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_server.bind(ip_port)</span><br><span class="line">    tcp_socket_server.listen(backlog)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=tcp_socket_server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;新连接[%s:%s]&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">        data_handler(conn,bufsize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    server_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(合法)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(非法:不知道加密方式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端(非法:不知道secret_key)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b&#x27;linhaifeng bang bang bang1111&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">ip_port,bufsize=<span class="number">1024</span></span>):</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&#x27;quit&#x27;</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        <span class="built_in">print</span>(respone.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_port=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<h3 id="十四-socketserver实现并发"><a href="#十四-socketserver实现并发" class="headerlink" title="十四 socketserver实现并发"></a>十四 socketserver实现并发</h3><p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p>
<p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p>
<p>server类：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8888d725cb767594afe03b558814ba28_720w.jpg" alt="img"></p>
<p>request类：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d39565c190e7edc28f8cf8be1bf981f9_720w.jpg" alt="img"></p>
<p>继承关系:</p>
<p><img src="https://pic1.zhimg.com/80/v2-16fcc2d93beebe3f1739951dc5d80114_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-154c5cb9cc464fac3e81703938479446_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-43cec3a3b133fd33c4d4db33af86807a_720w.jpg" alt="img"></p>
<p>以下述代码为例，分析socketserver源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftpserver=socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p>
<ol>
<li>实例化得到ftpserver，先找类ThreadingTCPServer的<strong>init</strong>,在TCPServer中找到，进而执行server_bind,server_active</li>
<li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li>
<li>执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li>
<li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li>
<li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找<strong>init</strong>方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li>
</ol>
<p>源码分析总结：</p>
<p>基于tcp的socketserver我们自己定义的类中的</p>
<ol>
<li>self.server即套接字对象</li>
<li>self.request即一个链接</li>
<li>self.client_address即客户端地址</li>
</ol>
<p>基于udp的socketserver我们自己定义的类中的</p>
<ol>
<li>self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, )</li>
<li>self.client_address即客户端地址</li>
</ol>
<p>FtpServer</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FtpServer</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    server_dir=<span class="string">&#x27;file_upload&#x27;</span></span><br><span class="line">    max_packet_size=<span class="number">1024</span></span><br><span class="line">    BASE_DIR=os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.request)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=self.request.recv(<span class="number">4</span>)</span><br><span class="line">            data_len=struct.unpack(<span class="string">&#x27;i&#x27;</span>,data)[<span class="number">0</span>]</span><br><span class="line">            head_json=self.request.recv(data_len).decode(self.coding)</span><br><span class="line">            head_dic=json.loads(head_json)</span><br><span class="line">            <span class="comment"># print(head_dic)</span></span><br><span class="line">            cmd=head_dic[<span class="string">&#x27;cmd&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(head_dic)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        file_path = os.path.normpath(os.path.join(</span><br><span class="line">            self.BASE_DIR,</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize = args[<span class="string">&#x27;filesize&#x27;</span>]</span><br><span class="line">        recv_size = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----&gt;&#x27;</span>, file_path)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> recv_size &lt; filesize:</span><br><span class="line">                recv_data = self.request.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size += <span class="built_in">len</span>(recv_data)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;recvsize:%s filesize:%s&#x27;</span> % (recv_size, filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftpserver=socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<p>FtpClient</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYTCPClient</span>:</span></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    coding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, connect=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> connect:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.client_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            inp=<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inp:<span class="keyword">continue</span></span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,cmd):</span><br><span class="line">                func=<span class="built_in">getattr</span>(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,args</span>):</span></span><br><span class="line">        cmd=args[<span class="number">0</span>]</span><br><span class="line">        filename=args[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;file:%s is not exists&#x27;</span> %filename)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;<span class="string">&#x27;cmd&#x27;</span>:cmd,<span class="string">&#x27;filename&#x27;</span>:os.path.basename(filename),<span class="string">&#x27;filesize&#x27;</span>:filesize&#125;</span><br><span class="line">        <span class="built_in">print</span>(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=<span class="built_in">bytes</span>(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=<span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=<span class="built_in">len</span>(line)</span><br><span class="line">                <span class="built_in">print</span>(send_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;upload successful&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/07/%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/07/%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-07 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-07T17:27:55+08:00">2018-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="一-模块介绍"><a href="#一-模块介绍" class="headerlink" title="一. 模块介绍"></a>一. 模块介绍</h2><p>在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。如果把开发程序比喻成制造一台电脑，编写模块就像是在制造电脑的零部件，准备好零部件后，剩下的工作就是按照逻辑把它们组装到一起。</p>
<p>将程序模块化会使得程序的组织结构清晰，维护起来更加方便。比起直接开发一个完整的程序，单独开发一个小的模块也会更加简单，并且程序中的模块与电脑中的零部件稍微不同的是：程序中的模块可以被重复使用。所以总结下来，使用模块既保证了代码的重用性，又增强了程序的结构性和可维护性。另外除了自定义模块外，我们还可以导入使用内置或第三方模块提供的现成功能，这种“拿来主义”极大地提高了程序员的开发效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1、什么是模块?</span><br><span class="line">    模块就是一系列功能的集合体</span><br><span class="line"></span><br><span class="line">    模块分为四种类别：</span><br><span class="line">        1、一个py文件就可以是一个模块</span><br><span class="line">        2、包：就是一个存放有__init__.py文件的文件夹</span><br><span class="line"></span><br><span class="line">        3、使用C编写并链接到python解释器的内置模块</span><br><span class="line">        4、已被编译为共享库或DLL的C或C++扩展</span><br><span class="line"></span><br><span class="line">    模块有三种来源</span><br><span class="line">        1、python解释器自带的</span><br><span class="line">            内置的</span><br><span class="line">            标准库</span><br><span class="line"></span><br><span class="line">            import time  # 内置库</span><br><span class="line">            print(time)</span><br><span class="line">            import os  # 标准库</span><br><span class="line">            print(os)</span><br><span class="line"></span><br><span class="line">        2、第三方的库</span><br><span class="line"></span><br><span class="line">        3、自定义的库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、为何要用模块?</span><br><span class="line">    1、拿来主义，极大地提升开发效率</span><br><span class="line">    2、解决代码冗余问题</span><br></pre></td></tr></table></figure>

<h2 id="二-模块的使用"><a href="#二-模块的使用" class="headerlink" title="二 模块的使用"></a>二 模块的使用</h2><h4 id="2-1-import语句"><a href="#2-1-import语句" class="headerlink" title="2.1 import语句"></a>2.1 import语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要想在另外一个py文件中引用foo.py中的功能，需要使用import foo，首次导入模块会做三件事：</span><br><span class="line">	1、执行源文件代码</span><br><span class="line">	2、产生一个新的名称空间用于存放源文件执行过程中产生的名字</span><br><span class="line">	3、在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀</span><br></pre></td></tr></table></figure>

<p>如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="comment">#导入模块foo</span></span><br><span class="line">a=foo.x <span class="comment">#引用模块foo中变量x的值赋值给当前名称空间中的名字a</span></span><br><span class="line">foo.get() <span class="comment">#调用模块foo的get函数</span></span><br><span class="line">foo.change() <span class="comment">#调用模块foo中的change函数</span></span><br><span class="line">obj=foo.Foo() <span class="comment">#使用模块foo的类Foo来实例化，进一步可以执行obj.func()</span></span><br></pre></td></tr></table></figure>

<p>加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">强调:</span><br><span class="line">	第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名</span><br><span class="line">	</span><br><span class="line">注意:</span><br><span class="line">	1.在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。</span><br><span class="line">	2.模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。</span><br></pre></td></tr></table></figure>

<p>用import语句导入多个模块，可以写多行import语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">import</span> module2</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">import</span> moduleN</span><br></pre></td></tr></table></figure>

<p>还可以在一行导入，用逗号分隔开不同的模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1,module2,...,moduleN</span><br></pre></td></tr></table></figure>

<p>但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开，不同类别的导入顺序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. python内置模块</span></span><br><span class="line"><span class="comment">#2. 第三方模块</span></span><br><span class="line"><span class="comment">#3. 程序员自定义模块</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-from-import-语句"><a href="#2-2-from-import-语句" class="headerlink" title="2.2 from-import 语句"></a>2.2 from-import 语句</h4><p>from…import…与import语句基本一致，唯一不同的是：使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo import x,get,change,Foo则可以在当前执行文件中直接引用模块foo中的名字，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> x,get,change <span class="comment">#将模块foo中的x和get导入到当前名称空间</span></span><br><span class="line">a=x <span class="comment">#直接使用模块foo中的x赋值给a</span></span><br><span class="line">get() <span class="comment">#直接执行foo中的get函数</span></span><br><span class="line">change() <span class="comment">#即便是当前有重名的x，修改的仍然是源文件中的x</span></span><br></pre></td></tr></table></figure>

<p>无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</p>
<p>另外from语句支持from foo import <em>语法，</em>代表将foo中所有的名字都导入到当前位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字</span></span><br><span class="line"></span><br><span class="line">a=x</span><br><span class="line">get()</span><br><span class="line">change()</span><br><span class="line">obj=Foo()</span><br></pre></td></tr></table></figure>

<p>如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用<em>的方式导入，在函数内则非法，并且</em>的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">__all__=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;get&#x27;</span>] <span class="comment">#该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;from the func&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#此时的*只代表x和get</span></span><br><span class="line"></span><br><span class="line">x <span class="comment">#可用</span></span><br><span class="line">get() <span class="comment">#可用</span></span><br><span class="line">change() <span class="comment">#不可用</span></span><br><span class="line">Foo() <span class="comment">#不可用</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-其他导入语法-as"><a href="#2-3-其他导入语法-as" class="headerlink" title="2.3 其他导入语法(as)"></a>2.3 其他导入语法(as)</h4><p>我们还可以在当前位置为导入的模块起一个别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">as</span> f <span class="comment">#为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名f</span></span><br><span class="line">f.x</span><br><span class="line">f.get()</span><br></pre></td></tr></table></figure>

<p>还可以为导入的一个名字起别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> get <span class="keyword">as</span> get_x</span><br><span class="line">get_x()</span><br></pre></td></tr></table></figure>

<p>通常在被导入的名字过长时采用起别名的方式来精简代码，另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data_format == <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> json <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是json，那么导入json模块并命名为serialize</span></span><br><span class="line"><span class="keyword">elif</span> data_format == <span class="string">&#x27;pickle&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> pickle <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是pickle，那么导入pickle模块并命名为serialize</span></span><br><span class="line"></span><br><span class="line">data=serialize.load(fn) <span class="comment">#最终调用的方式是一致的</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-循环导入问题"><a href="#2-4-循环导入问题" class="headerlink" title="2.4 循环导入问题"></a>2.4 循环导入问题</h4><p>循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码</p>
<p><strong>注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入</strong></p>
<h4 id="2-5-搜索模块的路径与优先级"><a href="#2-5-搜索模块的路径与优先级" class="headerlink" title="2.5 搜索模块的路径与优先级"></a>2.5 搜索模块的路径与优先级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模块其实分为四个通用类别，分别是：</span><br><span class="line">    1、使用纯Python代码编写的py文件</span><br><span class="line">    2、包含一系列模块的包</span><br><span class="line">    3、使用C编写并链接到Python解释器中的内置模块</span><br><span class="line">    4、使用C或C++编译的扩展模块</span><br></pre></td></tr></table></figure>

<p>在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5&#x27;</span>,</span><br><span class="line">...,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages&#x27;</span></span><br></pre></td></tr></table></figure>

<p>列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。</p>
<p>sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为/pythoner/projects/</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;/pythoner/projects/&#x27;</span>) <span class="comment">#也可以使用sys.path.insert(……)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="comment">#无论foo.py在何处,我们都可以导入它了</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-区分py文件的两种用途"><a href="#2-6-区分py文件的两种用途" class="headerlink" title="2.6 区分py文件的两种用途"></a>2.6 区分py文件的两种用途</h4><p>一个Python文件有两种用途，一种被当主程序/脚本执行，另一种被当模块导入，为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名</p>
<p>作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo.py被当做脚本执行时运行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    foo.py被当做模块导入时运行的代码</span><br></pre></td></tr></table></figure>

<p>通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。</p>
<h4 id="2-7-编写一个规范的模块"><a href="#2-7-编写一个规范的模块" class="headerlink" title="2.7 编写一个规范的模块"></a>2.7 编写一个规范的模块</h4><p>我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;The module is used to...&quot;</span> <span class="comment">#模块的文档描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span> <span class="comment">#定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="comment">#定义类,并写好类的注释</span></span><br><span class="line">    <span class="string">&#x27;Class Foo is used to...&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span> <span class="comment">#定义函数,并写好函数的注释</span></span><br><span class="line">    <span class="string">&#x27;Function test is used to…&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment">#主程序</span></span><br><span class="line">    test() <span class="comment">#在被当做脚本执行时,执行此处的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.首次导入模块发生三件事：（import方法)</span><br><span class="line">	1、会触发spam.py运行，所以会产生一个模块的名称空间</span><br><span class="line">	2、运行spam.py的代码，将运行过程中产生的名字都丢到模块的名称空间中</span><br><span class="line">	3、在当前执行文件的名称空间中拿到一个名字spam，该名字就是指向模块的名称空间的</span><br><span class="line">       （from import第3步是在当前执行文件的名称空间中拿到一个名字money，该名字就是指向模块的名称空间对应的名字）（后续的导入直接引用首次导入的成果）</span><br><span class="line"></span><br><span class="line">2.import和from import调用的区别：</span><br><span class="line">	import 导入模块，每次使用模块中的函数都要是定是哪个模块。</span><br><span class="line">	from…import * 导入模块，每次使用模块中的函数，直接使用函数就可以了</span><br><span class="line">	</span><br><span class="line">3.循环导入问题：</span><br><span class="line">	3.1循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常。</span><br><span class="line">	3.2解决方法：</span><br><span class="line">        方法一：导入语句放到最后，保证在导入时，所有名字都已经加载过</span><br><span class="line">        方法二：导入语句放到函数中，只有在调用函数时才会执行其内部代码</span><br><span class="line">        方法三：重新设计代码结构，将代码和并或者分离</span><br><span class="line">        </span><br><span class="line">4.搜索模块的路径与优先级：</span><br><span class="line">	在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。</span><br><span class="line">优先级：内存 &gt; 内置 &gt; sys.path</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/06/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/06/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="post-title-link" itemprop="url">名称空间与作用域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-06 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-06T17:27:55+08:00">2018-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="名称空间与作用域"><a href="#名称空间与作用域" class="headerlink" title="名称空间与作用域"></a>名称空间与作用域</h1><h3 id="一-名称空间"><a href="#一-名称空间" class="headerlink" title="一 .名称空间"></a>一 .名称空间</h3><p>名称空间Namespaces：存放名字与其对应的内存地址的地方</p>
<p>名称空间分为三大类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、内置名称空间：存放的是python解释器自带的名字</span><br><span class="line">		生命周期：解释器启动则产生，解释器关闭则销毁</span><br><span class="line">2.全局名称空间：存放的是顶级的名字</span><br><span class="line">		生命周期：py程序刚开始运行则立即产生，py程序结束则销毁</span><br><span class="line">3.局部名称空间：存放的是函数内的名字</span><br><span class="line">		生命周期：函数调用则产生，函数调用结束则销毁</span><br></pre></td></tr></table></figure>

<h3 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h3><h4 id="2-1-全局作用域与局部作用域"><a href="#2-1-全局作用域与局部作用域" class="headerlink" title="2.1 全局作用域与局部作用域"></a>2.1 全局作用域与局部作用域</h4><p>按照名字作用范围的不同可以将三个名称空间划分为两个区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）</span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span>局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-作用域与名字查找的优先级"><a href="#2-2-作用域与名字查找的优先级" class="headerlink" title="2.2 作用域与名字查找的优先级"></a>2.2 作用域与名字查找的优先级</h4><p>在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，没有找到，再去全局作用域查找：先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">100</span> <span class="comment">#全局作用域的名字x</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    x=<span class="number">300</span> <span class="comment">#局部作用域的名字x</span></span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">#在局部找x</span></span><br><span class="line">foo()<span class="comment">#结果为300</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    x=<span class="number">300</span> <span class="comment">#在函数调用时产生局部作用域的名字x</span></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#在全局找x,结果为100</span></span><br></pre></td></tr></table></figure>

<h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><h5 id="可以调用内建函数locals-和globals-来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals-的结果等于globals"><a href="#可以调用内建函数locals-和globals-来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals-的结果等于globals" class="headerlink" title="可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()"></a>可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()</h5><p>在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到global关键字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x <span class="comment">#声明x为全局名称空间的名字</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#结果为2</span></span><br></pre></td></tr></table></figure>

<p>当实参的值为可变类型时，函数体内对该值的修改将直接反应到原值，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">nums</span>):</span></span><br><span class="line">    nums.append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">foo(num_list)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">f1</span>():</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x=<span class="number">3</span></span><br><span class="line">    f2() <span class="comment">#调用f2(),修改f1作用域中名字x的值</span></span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">#在f1作用域查看x</span></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">    <span class="keyword">nonlocal</span> x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、名字的访问优先级：</span><br><span class="line">     基于自己当前所在的位置向外一层一层查找，L-》E-》G-》B</span><br><span class="line"></span><br><span class="line">2、名称空间的&quot;嵌套&quot;关系是函数定义阶段、扫描语法时生成的，与调用位置无关</span><br><span class="line"></span><br><span class="line">全局作用域：内置名称空间、全局名称空间</span><br><span class="line">    特点: 全局存活，全局有效</span><br><span class="line">局部作用域：局部名称空间</span><br><span class="line">    特点：临时存活，局部有效</span><br><span class="line">  </span><br><span class="line">global:用来在局部修改全局的不可变类型的值</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/03/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/03/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">函数对象和闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-03 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-03T17:27:55+08:00">2018-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数对象和闭包"><a href="#函数对象和闭包" class="headerlink" title="函数对象和闭包"></a>函数对象和闭包</h1><h3 id="一-函数对象"><a href="#一-函数对象" class="headerlink" title="一 函数对象"></a>一 函数对象</h3><p>函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用</p>
<h4 id="1-1-函数可以被引用"><a href="#1-1-函数可以被引用" class="headerlink" title="1.1 函数可以被引用"></a>1.1 函数可以被引用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">     <span class="keyword">return</span> x+y</span><br><span class="line"> </span><br><span class="line">func=add</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-函数可以作为容器类型的元素"><a href="#1-2-函数可以作为容器类型的元素" class="headerlink" title="1.2 函数可以作为容器类型的元素"></a>1.2 函数可以作为容器类型的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;<span class="string">&#x27;add&#x27;</span>:add,<span class="string">&#x27;max&#x27;</span>:<span class="built_in">max</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line">&#123;<span class="string">&#x27;add&#x27;</span>: &lt;function add at <span class="number">0x100661e18</span>&gt;, <span class="string">&#x27;max&#x27;</span>: &lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;&#125;</span><br><span class="line">dic[<span class="string">&#x27;add&#x27;</span>](<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-函数可以作为参数传入另外一个函数"><a href="#1-3-函数可以作为参数传入另外一个函数" class="headerlink" title="1.3 函数可以作为参数传入另外一个函数"></a>1.3 函数可以作为参数传入另外一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,func</span>):</span></span><br><span class="line">    <span class="keyword">return</span> func(x,y)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,add)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-函数的返回值可以是一个函数"><a href="#1-4-函数的返回值可以是一个函数" class="headerlink" title="1.4 函数的返回值可以是一个函数"></a>1.4 函数的返回值可以是一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span> </span><br><span class="line">     <span class="keyword">return</span> add </span><br><span class="line">func=bar() </span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span> </span><br></pre></td></tr></table></figure>

<h3 id="二-闭包函数"><a href="#二-闭包函数" class="headerlink" title="二 闭包函数"></a>二 闭包函数</h3><h4 id="2-1-闭与包"><a href="#2-1-闭与包" class="headerlink" title="2.1 闭与包"></a>2.1 闭与包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.闭函数：被封闭起来的函数=&gt;定义函数内部的函数，闭函数的特点是只能在函数内用</span><br><span class="line">    def outer():</span><br><span class="line">         x = 100</span><br><span class="line">         def wrapper():</span><br><span class="line">             print(x)</span><br><span class="line">2.包函数：该函数引用了一个名字，该名字是来自与e这一层的</span><br><span class="line"></span><br><span class="line">“闭”代表函数是内部的，“包”代表函数外’包裹’着对外层作用域的引用。因而无论在何处调用闭包函数，使用的仍然是包裹在其外层的变量。</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">	闭包函数指的是定义在函数内部的函数引用了一个来自于外层函数作用域中的名字</span><br></pre></td></tr></table></figure>

<p>基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">    x=<span class="number">3</span></span><br><span class="line">    f2=f1() <span class="comment">#调用f1()返回函数f2</span></span><br><span class="line">    f2() <span class="comment">#需要按照函数定义时的作用关系去执行，与调用位置无关</span></span><br><span class="line"></span><br><span class="line">f3() <span class="comment">#结果为1</span></span><br></pre></td></tr></table></figure>

<p>也就是说函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包(Closures)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func=outer()</span><br><span class="line">func() <span class="comment"># 结果为2</span></span><br></pre></td></tr></table></figure>

<p>可以通过函数的<strong>closure</strong>属性，查看到闭包函数所包裹的外部变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x10212af78</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x10028cca0</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-闭包的用途"><a href="#2-2-闭包的用途" class="headerlink" title="2.2 闭包的用途"></a>2.2 闭包的用途</h4><p>目前为止，我们得到了两种为函数体传值的方式，一种是直接将值以参数的形式传入，另外一种就是将值包给函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">方式一：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">        <span class="keyword">return</span> requests.get(url).text</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">page</span>(<span class="params">url</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">            <span class="keyword">return</span> requests.get(url).text</span><br><span class="line">        <span class="keyword">return</span> get</span><br><span class="line">    </span><br><span class="line">提示：</span><br><span class="line">	requests模块是用来模拟浏览器向网站发送请求并将页面内容下载到本地，需要事先安装：pip3 install requests</span><br></pre></td></tr></table></figure>

<p>闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><h5 id="为函数体传参有两种解决方案："><a href="#为函数体传参有两种解决方案：" class="headerlink" title="为函数体传参有两种解决方案："></a>为函数体传参有两种解决方案：</h5><p>​        方案一:直接以参数的形式传入<br>​        方案二：以闭包函数的形式传参</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/02/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/02/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">函数的基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-02 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-02T17:27:55+08:00">2018-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h1><h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一.引子"></a>一.引子</h3><p>​            基于前一部分的学习，我们已经能开发一些功能简单的小程序了，但随着程序功能的增多，代码量随之增大，此时仍不加区分地把所有功能的实现代码放到一起，将会使得程序的组织结构不清晰，可读性变差，且程序中需要频繁使用同一功能时，只能重复编写该功能的实现代码，日积月累，程序将变得冗长，并且当某一功能需要修改时，又不得不找出所有定义及使用这段功能的地方修改之，管理维护的难度极大</p>
<p>​            在程序中，具备某一功能的‘工具’指的就是函数，‘事先准备工具’的过程即函数的定义，‘拿来就用’即函数的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、什么是函数</span><br><span class="line">    函数就是盛放代码的容器，把实现某一功能的一组代码丢到一个函数中</span><br><span class="line">    就做成了一个小工具</span><br><span class="line"></span><br><span class="line">    具备某一功能的工具-》函数</span><br><span class="line">    事先准备工具的过程-》函数的定义</span><br><span class="line">    遇到应用场景拿来就用-》函数的调用</span><br><span class="line"></span><br><span class="line">2、为何要用函数</span><br><span class="line">    在没有用函数之前面临的问题：</span><br><span class="line">        1、代码冗余，程序组织结构不清晰、可读性差</span><br><span class="line">        2、扩展性差</span><br><span class="line"></span><br><span class="line">3、如何用函数</span><br><span class="line">    原则：先定义、后调用</span><br></pre></td></tr></table></figure>



<h3 id="二-定义函数"><a href="#二-定义函数" class="headerlink" title="二.定义函数"></a>二.定义函数</h3><p>​            函数的使用必须遵循’先定义，后调用’的原则。函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这和变量的定义是相似的。没有事先定义函数而直接调用，就相当于在引用一个不存在的’’变量名’’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义函数的语法:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span></span><br><span class="line">        函数体</span><br><span class="line">        <span class="keyword">return</span> 值</span><br><span class="line">   </span><br><span class="line"><span class="number">1.</span><span class="keyword">def</span>: 定义函数的关键字；</span><br><span class="line"><span class="number">2.</span>函数名：函数名指向函数内存地址，是对函数体代码的引用。函数的命名应该反映出函数的功能；</span><br><span class="line"><span class="number">3.</span>括号：括号内定义参数，参数是可有可无的，且无需指定参数的类型；</span><br><span class="line"><span class="number">4.</span>冒号：括号后要加冒号，然后在下一行开始缩进编写函数体的代码；</span><br><span class="line"><span class="number">5.</span><span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span>: 描述函数功能，参数介绍等信息的文档，非必要，但是建议加上，从而增强函数的可读性；</span><br><span class="line"><span class="number">6.</span>函数体：由语句和表达式组成；</span><br><span class="line"><span class="number">7.</span><span class="keyword">return</span> 值：定义函数的返回值，<span class="keyword">return</span>是可有可无的。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">    <span class="number">1.</span>函数在定义阶段发生的什么事情?</span><br><span class="line">		定义函数不执行函数体代码，但是会检测函数体语法</span><br><span class="line">    <span class="number">2.</span>函数在调用阶段发生的什么事情?</span><br><span class="line">		先通过函数名找到函数的内存地址，然后函数的内存地址()会触发函数体代码的运行</span><br></pre></td></tr></table></figure>

<p>参数是函数的调用者向函数体传值的媒介，若函数体代码逻辑依赖外部传来的参数时则需要定义为参函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_min</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    res=x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>否则定义为无参函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interactive</span>():</span></span><br><span class="line">    user=<span class="built_in">input</span>(<span class="string">&#x27;user&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    pwd=<span class="built_in">input</span>(<span class="string">&#x27;password&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> (user,pwd)</span><br></pre></td></tr></table></figure>

<h3 id="三-调用函数与函数返回值"><a href="#三-调用函数与函数返回值" class="headerlink" title="三 调用函数与函数返回值"></a>三 调用函数与函数返回值</h3><p>​            函数的使用分为定义阶段与调用阶段，定义函数时只检测语法，不执行函数体代码，函数名加括号即函数调用，只有调用函数时才会执行函数体代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义阶段</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in the foo&#x27;</span>)</span><br><span class="line">        bar()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in the bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">调用阶段</span><br><span class="line">	foo()</span><br><span class="line">    </span><br><span class="line">执行结果</span><br><span class="line">    <span class="keyword">in</span> the foo</span><br><span class="line">    <span class="keyword">in</span> the bar</span><br></pre></td></tr></table></figure>

<p>按照在程序出现的形式和位置，可将函数的调用形式分为三种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、语句形式：</span><br><span class="line">	foo()</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、表达式形式：</span><br><span class="line">    m=my_min(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#将调用函数的返回值赋值给x</span></span><br><span class="line">    n=<span class="number">10</span>*my_min(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#将调用函数的返回值乘以10的结果赋值给n</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、函数调用作为参数的形式：</span><br><span class="line">    my_min（<span class="number">2</span>，<span class="number">3</span>）作为函数my_min的第二个参数，实现了取<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>中的较小者赋值给m</span><br><span class="line">    m=my_min(<span class="number">1</span>，my_min（<span class="number">2</span>，<span class="number">3</span>）)</span><br><span class="line">    </span><br><span class="line">	若需要将函数体代码执行的结果返回给调用者，则需要用到<span class="keyword">return</span>。<span class="keyword">return</span>后无值或直接省略<span class="keyword">return</span>，则默认返回<span class="literal">None</span>，<span class="keyword">return</span>的返回值无类型限制，且可以将多个返回值放到一个元组内。</span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">    <span class="keyword">return</span>是一个函数结束的标志,函数内可以有多个<span class="keyword">return</span>，但只执行一次函数就结束了，并把<span class="keyword">return</span>后定义的值作为本次调用的结果返回。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/01/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="左大大">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左大大的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/01/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">函数的参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-01 17:27:55" itemprop="dateCreated datePublished" datetime="2018-06-01T17:27:55+08:00">2018-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><h3 id="一-形参与实参介绍"><a href="#一-形参与实参介绍" class="headerlink" title="一. 形参与实参介绍"></a>一. 形参与实参介绍</h3><p>​            函数的参数分为形式参数和实际参数，简称形参和实参</p>
<p>​            形参即在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。</p>
<p>​            实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：实参是常量</span><br><span class="line">	res=my_min(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：实参是变量</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    b=<span class="number">2</span></span><br><span class="line">    res=my_min(a,b)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：实参是表达式</span><br><span class="line">	res=my_min(<span class="number">10</span>*<span class="number">2</span>,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：实参可以是常量、变量、表达式的任意组合</span><br><span class="line">    a=<span class="number">2</span></span><br><span class="line">    my_min(<span class="number">1</span>,a,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h3 id="二-形参与实参的具体使用"><a href="#二-形参与实参的具体使用" class="headerlink" title="二 .形参与实参的具体使用"></a>二 .形参与实参的具体使用</h3><h4 id="2-1-位置参数"><a href="#2-1-位置参数" class="headerlink" title="2.1 位置参数"></a>2.1 位置参数</h4><p>位置即顺序，位置参数指的是按顺序定义的参数，需要从两个角度去看：        </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在定义函数时，按照从左到右的顺序依次定义形参,称为位置形参，凡是按照这种形式定义的形参都必须被传值</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,sex</span>):</span> <span class="comment">#定义位置形参：name，age，sex，三者都必须被传值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Name:%s Age:%s Sex:%s&#x27;</span> %(name,age,sex))</span><br><span class="line">    register() <span class="comment">#TypeError：缺少3个位置参数 </span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,sex</span>):</span> <span class="comment">#定义位置形参：name，age，sex，三者都必须被传值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Name:%s Age:%s Sex:%s&#x27;</span> %(name,age,sex))</span><br><span class="line">    register() <span class="comment">#TypeError：缺少3个位置参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-关键字参数"><a href="#2-2-关键字参数" class="headerlink" title="2.2 关键字参数"></a>2.2 关键字参数</h4><p>​        在调用函数时，实参可以是key=value的形式，称为关键字参数，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值        </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register(sex=<span class="string">&#x27;male&#x27;</span>,name=<span class="string">&#x27;lili&#x27;</span>,age=<span class="number">18</span>)</span><br><span class="line">==&gt; Name:lili Age:<span class="number">18</span> Sex:male</span><br></pre></td></tr></table></figure>

<p>需要注意在调用函数时，实参也可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,sex=<span class="string">&#x27;male&#x27;</span>,age=<span class="number">18</span>) <span class="comment">#正确使用</span></span><br><span class="line">register(name=<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,sex=<span class="string">&#x27;male&#x27;</span>) <span class="comment">#SyntaxError：关键字参数name=‘lili’在位置参数18之前</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,sex=<span class="string">&#x27;male&#x27;</span>,age=<span class="number">18</span>,name=<span class="string">&#x27;jack&#x27;</span>) <span class="comment">#TypeError：形参name被重复赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-默认参数"><a href="#2-3-默认参数" class="headerlink" title="2.3 默认参数"></a>2.3 默认参数</h4><p>在定义函数时，就已经为形参赋值，这类形参称之为默认参数，当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。</p>
<p>定义时就已经为参数sex赋值，意味着调用时可以不对sex赋值，这降低了函数调用的复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">register(<span class="string">&#x27;tom&#x27;</span>,<span class="number">17</span>) <span class="comment">#大多数情况,无需为sex传值,默认为male</span></span><br><span class="line">==&gt;  Name:tom Age:<span class="number">17</span> Sex:male</span><br><span class="line">register(<span class="string">&#x27;Lili&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;female&#x27;</span>) <span class="comment">#少数情况,可以为sex传值female</span></span><br><span class="line">==&gt;  Name:Lili Age:<span class="number">18</span> Sex:female</span><br><span class="line">            </span><br><span class="line">需要注意：</span><br><span class="line">    <span class="number">1.</span>默认参数必须在位置参数之后</span><br><span class="line">    <span class="number">2.</span>默认参数的值仅在函数定义阶段被赋值一次</span><br><span class="line">    <span class="number">3.</span>默认参数的值通常应设为不可变类型</span><br></pre></td></tr></table></figure>

<h4 id="2-4-可变长度的参数（-与-的用法）"><a href="#2-4-可变长度的参数（-与-的用法）" class="headerlink" title="2.4 可变长度的参数（*与**的用法）"></a>2.4 可变长度的参数（*与**的用法）</h4><h5 id="2-4-1-可变长度的位置参数"><a href="#2-4-1-可变长度的位置参数" class="headerlink" title="2.4.1 可变长度的位置参数"></a>2.4.1 可变长度的位置参数</h5><p>如果在最后一个形参名前加<em>号,那么在调用函数时，溢出的位置实参，都会被</em>接收，以元组的形式保存下来赋值给该形参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,z=<span class="number">1</span>,*args</span>):</span> <span class="comment">#在最后一个形参名args前加*号</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(z)</span><br><span class="line">     <span class="built_in">print</span>(args)</span><br><span class="line"> </span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)  <span class="comment">#实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，以元组的形式保存下来，赋值给args，即args=(4, 5, 6,7)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们事先生成了一个列表,仍然是可以传值给*args的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,*args</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(args)</span><br><span class="line"> </span><br><span class="line">L=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,*L) <span class="comment"># *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	如果在传入L时没有加*,那L就只是一个普通的位置参数了</span><br></pre></td></tr></table></figure>

<p>如果我们想要求多个值的和，*args就派上用场了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">*args</span>):</span></span><br><span class="line">     res=<span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">         res+=i</span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-可变长度的关键字参数"><a href="#2-4-2-可变长度的关键字参数" class="headerlink" title="2.4.2 可变长度的关键字参数"></a>2.4.2 可变长度的关键字参数</h5><p>如果在最后一个形参名前加<strong>号,那么在调用函数时，溢出的关键字参数，都会被</strong>接收，以字典的形式保存下来赋值给该形参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,**kwargs</span>):</span> <span class="comment">#在最后一个参数kwargs前加**</span></span><br><span class="line">     <span class="built_in">print</span>(x)        </span><br><span class="line">     <span class="built_in">print</span>(kwargs)   </span><br><span class="line"> </span><br><span class="line">foo(y=<span class="number">2</span>,x=<span class="number">1</span>,z=<span class="number">3</span>) <span class="comment">#溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们事先生成了一个字典,仍然是可以传值给**kwargs的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,**kwargs</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(x)</span><br><span class="line">     <span class="built_in">print</span>(y)</span><br><span class="line">     <span class="built_in">print</span>(kwargs)</span><br><span class="line"> </span><br><span class="line">dic=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; </span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,**dic) <span class="comment">#**dic就相当于关键字参数a=1，b=2，foo(1,2,**dic)等同foo(1,2,a=1,b=2)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	如果在传入dic时没有加**,那dic就只是一个普通的位置参数了</span><br></pre></td></tr></table></figure>

<h4 id="2-5-命名关键字参数"><a href="#2-5-命名关键字参数" class="headerlink" title="2.5 命名关键字参数"></a>2.5 命名关键字参数</h4><p>想要限定函数的调用者必须以key=value的形式传值，Python3提供了专门的语法：需要在定义形参时，用作为一个分隔符号，符号之后的形参称为命名关键字参数。对于这类参数，在函数调用时，必须按照key=value的形式为其传值，且必须被传值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,age,*,sex,height</span>):</span> <span class="comment">#sex,height为命名关键字参数</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,sex=<span class="string">&#x27;male&#x27;</span>,height=<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment">#正确使用</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment"># TypeError:未使用关键字的形式为sex和height传值</span></span><br><span class="line">register(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>,height=<span class="string">&#x27;1.8m&#x27;</span>) <span class="comment"># TypeError没有为命名关键字参数height传值。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-组合使用"><a href="#2-6-组合使用" class="headerlink" title="2.6 组合使用"></a>2.6 组合使用</h4><p>综上所述所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、*args、命名关键字参数、**kwargs</p>
<p>可变参数*args与关键字参数<strong>kwargs通常是组合在一起使用的，如果一个函数的形参为*args与</strong>kwargs，那么代表该函数可以接收任何形式、任意长度的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: *args、**kwargs中的args和kwargs被替换成其他名字并无语法错误，但使用args、kwargs是约定俗成的。</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><h4 id="一-函数参数分为两大类："><a href="#一-函数参数分为两大类：" class="headerlink" title="一 .函数参数分为两大类："></a>一 .函数参数分为两大类：</h4><p>​    1、形参：在函数定义阶段括号内定义的变量名，称之为形式参数，简称形参<br>​    2、实参：在函数调用阶段括号内传入的值，称之为实际参数，简称实参</p>
<h4 id="二-形参与实参的关系是："><a href="#二-形参与实参的关系是：" class="headerlink" title="二.形参与实参的关系是："></a>二.形参与实参的关系是：</h4><p>​    在调用函数时，实参的值会绑定给形参名，然后可以在函数内使用，函数调用完毕后，解除绑定</p>
<h4 id="三：参数详解："><a href="#三：参数详解：" class="headerlink" title="三：参数详解："></a>三：参数详解：</h4><h5 id="形参："><a href="#形参：" class="headerlink" title="形参："></a>形参：</h5><p>​    1.位置形参：：在函数定义阶段按照从左到右的顺序依次定义的形参，称之为位置形参<br>​            特点：必须被传值，多一个不行少一个也不行<br>​    2.默认形参：在函数定义阶段就已经为某个形参赋值了，称之为默认形参<br>​            特点：在函数定义阶段就已经赋值了，意味着在调用阶段可以不用为其赋值</p>
<h5 id="ps-可以混用位置形参与默认形参，但是位置形参必须在前"><a href="#ps-可以混用位置形参与默认形参，但是位置形参必须在前" class="headerlink" title="ps: 可以混用位置形参与默认形参，但是位置形参必须在前"></a>ps: 可以混用位置形参与默认形参，但是位置形参必须在前</h5><h5 id="默认形参需要注意的问题是"><a href="#默认形参需要注意的问题是" class="headerlink" title="默认形参需要注意的问题是:"></a>默认形参需要注意的问题是:</h5><p>​    1、默认形参的值只在函数定义阶段被赋值一次<br>​    2、默认形参的值通常应该是不可变类型</p>
<h5 id="实参："><a href="#实参：" class="headerlink" title="实参："></a>实参：</h5><p>​    1.位置实参：在函数调用阶段按照从左到右的顺序依次传入的值，称之为位置实参<br>​            特点：按照顺序与形参一一对应<br>​    2.关键字实参：在函数调用阶段按照key=value的格式传入的值，称之为关键字实参<br>​            特点：可以打乱顺序，但是仍然能够为指定的形参赋值</p>
<h5 id="ps：可以混用位置实参与关键字实参，但是"><a href="#ps：可以混用位置实参与关键字实参，但是" class="headerlink" title="ps：可以混用位置实参与关键字实参，但是"></a>ps：可以混用位置实参与关键字实参，但是</h5><p>​        1、位置实参必须在关键字实参前<br>​        2、不能为同一个形参重复赋值</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">左大大</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
